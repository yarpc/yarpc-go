// Code generated by thriftrw v1.0.0
// @generated

// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package gauntlet

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go.uber.org/thriftrw/ptr"
	"go.uber.org/thriftrw/wire"
	"math"
	"strconv"
	"strings"
)

type Bonk struct {
	Message *string `json:"message,omitempty"`
	Type    *int32  `json:"type,omitempty"`
}

func (v *Bonk) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = wire.NewValueI32(*(v.Type)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Bonk) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Type = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Bonk) String() string {
	var fields [2]string
	i := 0
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", *(v.Type))
		i++
	}
	return fmt.Sprintf("Bonk{%v}", strings.Join(fields[:i], ", "))
}

type BoolTest struct {
	B *bool   `json:"b,omitempty"`
	S *string `json:"s,omitempty"`
}

func (v *BoolTest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.B == nil {
		v.B = ptr.Bool(true)
	}
	{
		w, err = wire.NewValueBool(*(v.B)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.S == nil {
		v.S = ptr.String("true")
	}
	{
		w, err = wire.NewValueString(*(v.S)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *BoolTest) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.B = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.S = &x
				if err != nil {
					return err
				}
			}
		}
	}
	if v.B == nil {
		v.B = ptr.Bool(true)
	}
	if v.S == nil {
		v.S = ptr.String("true")
	}
	return nil
}

func (v *BoolTest) String() string {
	var fields [2]string
	i := 0
	if v.B != nil {
		fields[i] = fmt.Sprintf("B: %v", *(v.B))
		i++
	}
	if v.S != nil {
		fields[i] = fmt.Sprintf("S: %v", *(v.S))
		i++
	}
	return fmt.Sprintf("BoolTest{%v}", strings.Join(fields[:i], ", "))
}

type Bools struct {
	ImTrue  *bool `json:"im_true,omitempty"`
	ImFalse *bool `json:"im_false,omitempty"`
}

func (v *Bools) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ImTrue != nil {
		w, err = wire.NewValueBool(*(v.ImTrue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ImFalse != nil {
		w, err = wire.NewValueBool(*(v.ImFalse)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Bools) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ImTrue = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ImFalse = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Bools) String() string {
	var fields [2]string
	i := 0
	if v.ImTrue != nil {
		fields[i] = fmt.Sprintf("ImTrue: %v", *(v.ImTrue))
		i++
	}
	if v.ImFalse != nil {
		fields[i] = fmt.Sprintf("ImFalse: %v", *(v.ImFalse))
		i++
	}
	return fmt.Sprintf("Bools{%v}", strings.Join(fields[:i], ", "))
}

type CrazyNesting struct {
	StringField *string     `json:"string_field,omitempty"`
	SetField    []*Insanity `json:"set_field"`
	ListField   [][]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	} `json:"list_field"`
	BinaryField []byte `json:"binary_field"`
}

type _Set_Insanity_ValueList []*Insanity

func (v _Set_Insanity_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Insanity_ValueList) Size() int {
	return len(v)
}

func (_Set_Insanity_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Insanity_ValueList) Close() {
}

type _Set_I32_ValueList map[int32]struct{}

func (v _Set_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_I32_ValueList) Size() int {
	return len(v)
}

func (_Set_I32_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_Set_I32_ValueList) Close() {
}

type _Map_Insanity_String_MapItemList []struct {
	Key   *Insanity
	Value string
}

func (m _Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TStruct
}

func (_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_Insanity_String_MapItemList) Close() {
}

type _List_Map_Insanity_String_ValueList [][]struct {
	Key   *Insanity
	Value string
}

func (v _List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_Insanity_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_Insanity_String_ValueList) Close() {
}

type _Set_List_Map_Insanity_String_ValueList [][][]struct {
	Key   *Insanity
	Value string
}

func (v _Set_List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := wire.NewValueList(_List_Map_Insanity_String_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_Set_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_Set_List_Map_Insanity_String_ValueList) Close() {
}

type _Map_I32_Set_List_Map_Insanity_String_MapItemList map[int32][][][]struct {
	Key   *Insanity
	Value string
}

func (m _Map_I32_Set_List_Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueSet(_Set_List_Map_Insanity_String_ValueList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Set_List_Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Set_List_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Set_List_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TSet
}

func (_Map_I32_Set_List_Map_Insanity_String_MapItemList) Close() {
}

type _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList []struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

func (m _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueSet(_Set_I32_ValueList(k)), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueMap(_Map_I32_Set_List_Map_Insanity_String_MapItemList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TSet
}

func (_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TMap
}

func (_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) Close() {
}

type _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

func (v _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) Close() {
}

func (v *CrazyNesting) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.StringField != nil {
		w, err = wire.NewValueString(*(v.StringField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.SetField != nil {
		w, err = wire.NewValueSet(_Set_Insanity_ValueList(v.SetField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ListField == nil {
		return w, errors.New("field ListField of CrazyNesting is required")
	}
	w, err = wire.NewValueList(_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList(v.ListField)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.BinaryField != nil {
		w, err = wire.NewValueBinary(v.BinaryField), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Insanity_Read(w wire.Value) (*Insanity, error) {
	var v Insanity
	err := v.FromWire(w)
	return &v, err
}

func _Set_Insanity_Read(s wire.ValueList) ([]*Insanity, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*Insanity, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Insanity_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Set_I32_Read(s wire.ValueList) (map[int32]struct{}, error) {
	if s.ValueType() != wire.TI32 {
		return nil, nil
	}
	o := make(map[int32]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _Map_Insanity_String_Read(m wire.MapItemList) ([]struct {
	Key   *Insanity
	Value string
}, error) {
	if m.KeyType() != wire.TStruct {
		return nil, nil
	}
	if m.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make([]struct {
		Key   *Insanity
		Value string
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Insanity_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, struct {
			Key   *Insanity
			Value string
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_Insanity_String_Read(l wire.ValueList) ([][]struct {
	Key   *Insanity
	Value string
}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}
	o := make([][]struct {
		Key   *Insanity
		Value string
	}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_Insanity_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Set_List_Map_Insanity_String_Read(s wire.ValueList) ([][][]struct {
	Key   *Insanity
	Value string
}, error) {
	if s.ValueType() != wire.TList {
		return nil, nil
	}
	o := make([][][]struct {
		Key   *Insanity
		Value string
	}, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _List_Map_Insanity_String_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Map_I32_Set_List_Map_Insanity_String_Read(m wire.MapItemList) (map[int32][][][]struct {
	Key   *Insanity
	Value string
}, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}
	if m.ValueType() != wire.TSet {
		return nil, nil
	}
	o := make(map[int32][][][]struct {
		Key   *Insanity
		Value string
	}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Set_List_Map_Insanity_String_Read(x.Value.GetSet())
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(m wire.MapItemList) ([]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}, error) {
	if m.KeyType() != wire.TSet {
		return nil, nil
	}
	if m.ValueType() != wire.TMap {
		return nil, nil
	}
	o := make([]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Set_I32_Read(x.Key.GetSet())
		if err != nil {
			return err
		}
		v, err := _Map_I32_Set_List_Map_Insanity_String_Read(x.Value.GetMap())
		if err != nil {
			return err
		}
		o = append(o, struct {
			Key   map[int32]struct{}
			Value map[int32][][][]struct {
				Key   *Insanity
				Value string
			}
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(l wire.ValueList) ([][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}
	o := make([][]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *CrazyNesting) FromWire(w wire.Value) error {
	var err error
	list_fieldIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringField = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.SetField, err = _Set_Insanity_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.ListField, err = _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				list_fieldIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}
			}
		}
	}
	if !list_fieldIsSet {
		return errors.New("field ListField of CrazyNesting is required")
	}
	return nil
}

func (v *CrazyNesting) String() string {
	var fields [4]string
	i := 0
	if v.StringField != nil {
		fields[i] = fmt.Sprintf("StringField: %v", *(v.StringField))
		i++
	}
	if v.SetField != nil {
		fields[i] = fmt.Sprintf("SetField: %v", v.SetField)
		i++
	}
	fields[i] = fmt.Sprintf("ListField: %v", v.ListField)
	i++
	if v.BinaryField != nil {
		fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
		i++
	}
	return fmt.Sprintf("CrazyNesting{%v}", strings.Join(fields[:i], ", "))
}

type EmptyStruct struct{}

func (v *EmptyStruct) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *EmptyStruct) FromWire(w wire.Value) error {
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}
	return nil
}

func (v *EmptyStruct) String() string {
	var fields [0]string
	i := 0
	return fmt.Sprintf("EmptyStruct{%v}", strings.Join(fields[:i], ", "))
}

type GuessProtocolStruct struct {
	MapField map[string]string `json:"map_field"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {
}

func (v *GuessProtocolStruct) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.MapField != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.MapField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}
	if m.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *GuessProtocolStruct) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 7:
			if field.Value.Type() == wire.TMap {
				v.MapField, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *GuessProtocolStruct) String() string {
	var fields [1]string
	i := 0
	if v.MapField != nil {
		fields[i] = fmt.Sprintf("MapField: %v", v.MapField)
		i++
	}
	return fmt.Sprintf("GuessProtocolStruct{%v}", strings.Join(fields[:i], ", "))
}

type Insanity struct {
	UserMap map[Numberz]UserId `json:"userMap"`
	Xtructs []*Xtruct          `json:"xtructs"`
}

type _Map_Numberz_UserId_MapItemList map[Numberz]UserId

func (m _Map_Numberz_UserId_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := k.ToWire()
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Numberz_UserId_MapItemList) Size() int {
	return len(m)
}

func (_Map_Numberz_UserId_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_Numberz_UserId_MapItemList) ValueType() wire.Type {
	return wire.TI64
}

func (_Map_Numberz_UserId_MapItemList) Close() {
}

type _List_Xtruct_ValueList []*Xtruct

func (v _List_Xtruct_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Xtruct_ValueList) Size() int {
	return len(v)
}

func (_List_Xtruct_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Xtruct_ValueList) Close() {
}

func (v *Insanity) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.UserMap != nil {
		w, err = wire.NewValueMap(_Map_Numberz_UserId_MapItemList(v.UserMap)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Xtructs != nil {
		w, err = wire.NewValueList(_List_Xtruct_ValueList(v.Xtructs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Numberz_Read(w wire.Value) (Numberz, error) {
	var v Numberz
	err := v.FromWire(w)
	return v, err
}

func _UserId_Read(w wire.Value) (UserId, error) {
	var x UserId
	err := x.FromWire(w)
	return x, err
}

func _Map_Numberz_UserId_Read(m wire.MapItemList) (map[Numberz]UserId, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}
	if m.ValueType() != wire.TI64 {
		return nil, nil
	}
	o := make(map[Numberz]UserId, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Numberz_Read(x.Key)
		if err != nil {
			return err
		}
		v, err := _UserId_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Xtruct_Read(w wire.Value) (*Xtruct, error) {
	var v Xtruct
	err := v.FromWire(w)
	return &v, err
}

func _List_Xtruct_Read(l wire.ValueList) ([]*Xtruct, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*Xtruct, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Xtruct_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *Insanity) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.UserMap, err = _Map_Numberz_UserId_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Xtructs, err = _List_Xtruct_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Insanity) String() string {
	var fields [2]string
	i := 0
	if v.UserMap != nil {
		fields[i] = fmt.Sprintf("UserMap: %v", v.UserMap)
		i++
	}
	if v.Xtructs != nil {
		fields[i] = fmt.Sprintf("Xtructs: %v", v.Xtructs)
		i++
	}
	return fmt.Sprintf("Insanity{%v}", strings.Join(fields[:i], ", "))
}

type LargeDeltas struct {
	B1         *Bools              `json:"b1,omitempty"`
	B10        *Bools              `json:"b10,omitempty"`
	B100       *Bools              `json:"b100,omitempty"`
	CheckTrue  *bool               `json:"check_true,omitempty"`
	B1000      *Bools              `json:"b1000,omitempty"`
	CheckFalse *bool               `json:"check_false,omitempty"`
	Vertwo2000 *VersioningTestV2   `json:"vertwo2000,omitempty"`
	ASet2500   map[string]struct{} `json:"a_set2500"`
	Vertwo3000 *VersioningTestV2   `json:"vertwo3000,omitempty"`
	BigNumbers []int32             `json:"big_numbers"`
}

type _Set_String_ValueList map[string]struct{}

func (v _Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_ValueList) Size() int {
	return len(v)
}

func (_Set_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_ValueList) Close() {
}

type _List_I32_ValueList []int32

func (v _List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_I32_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_I32_ValueList) Close() {
}

func (v *LargeDeltas) ToWire() (wire.Value, error) {
	var (
		fields [10]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.B1 != nil {
		w, err = v.B1.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.B10 != nil {
		w, err = v.B10.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.B100 != nil {
		w, err = v.B100.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 100, Value: w}
		i++
	}
	if v.CheckTrue != nil {
		w, err = wire.NewValueBool(*(v.CheckTrue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 500, Value: w}
		i++
	}
	if v.B1000 != nil {
		w, err = v.B1000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1000, Value: w}
		i++
	}
	if v.CheckFalse != nil {
		w, err = wire.NewValueBool(*(v.CheckFalse)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1500, Value: w}
		i++
	}
	if v.Vertwo2000 != nil {
		w, err = v.Vertwo2000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2000, Value: w}
		i++
	}
	if v.ASet2500 != nil {
		w, err = wire.NewValueSet(_Set_String_ValueList(v.ASet2500)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2500, Value: w}
		i++
	}
	if v.Vertwo3000 != nil {
		w, err = v.Vertwo3000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3000, Value: w}
		i++
	}
	if v.BigNumbers != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.BigNumbers)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4000, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Bools_Read(w wire.Value) (*Bools, error) {
	var v Bools
	err := v.FromWire(w)
	return &v, err
}

func _VersioningTestV2_Read(w wire.Value) (*VersioningTestV2, error) {
	var v VersioningTestV2
	err := v.FromWire(w)
	return &v, err
}

func _Set_String_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _List_I32_Read(l wire.ValueList) ([]int32, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}
	o := make([]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *LargeDeltas) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.B1, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 10:
			if field.Value.Type() == wire.TStruct {
				v.B10, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 100:
			if field.Value.Type() == wire.TStruct {
				v.B100, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 500:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CheckTrue = &x
				if err != nil {
					return err
				}
			}
		case 1000:
			if field.Value.Type() == wire.TStruct {
				v.B1000, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 1500:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CheckFalse = &x
				if err != nil {
					return err
				}
			}
		case 2000:
			if field.Value.Type() == wire.TStruct {
				v.Vertwo2000, err = _VersioningTestV2_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2500:
			if field.Value.Type() == wire.TSet {
				v.ASet2500, err = _Set_String_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 3000:
			if field.Value.Type() == wire.TStruct {
				v.Vertwo3000, err = _VersioningTestV2_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 4000:
			if field.Value.Type() == wire.TList {
				v.BigNumbers, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *LargeDeltas) String() string {
	var fields [10]string
	i := 0
	if v.B1 != nil {
		fields[i] = fmt.Sprintf("B1: %v", v.B1)
		i++
	}
	if v.B10 != nil {
		fields[i] = fmt.Sprintf("B10: %v", v.B10)
		i++
	}
	if v.B100 != nil {
		fields[i] = fmt.Sprintf("B100: %v", v.B100)
		i++
	}
	if v.CheckTrue != nil {
		fields[i] = fmt.Sprintf("CheckTrue: %v", *(v.CheckTrue))
		i++
	}
	if v.B1000 != nil {
		fields[i] = fmt.Sprintf("B1000: %v", v.B1000)
		i++
	}
	if v.CheckFalse != nil {
		fields[i] = fmt.Sprintf("CheckFalse: %v", *(v.CheckFalse))
		i++
	}
	if v.Vertwo2000 != nil {
		fields[i] = fmt.Sprintf("Vertwo2000: %v", v.Vertwo2000)
		i++
	}
	if v.ASet2500 != nil {
		fields[i] = fmt.Sprintf("ASet2500: %v", v.ASet2500)
		i++
	}
	if v.Vertwo3000 != nil {
		fields[i] = fmt.Sprintf("Vertwo3000: %v", v.Vertwo3000)
		i++
	}
	if v.BigNumbers != nil {
		fields[i] = fmt.Sprintf("BigNumbers: %v", v.BigNumbers)
		i++
	}
	return fmt.Sprintf("LargeDeltas{%v}", strings.Join(fields[:i], ", "))
}

type ListBonks struct {
	Bonk []*Bonk `json:"bonk"`
}

type _List_Bonk_ValueList []*Bonk

func (v _List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Bonk_ValueList) Close() {
}

func (v *ListBonks) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Bonk != nil {
		w, err = wire.NewValueList(_List_Bonk_ValueList(v.Bonk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Bonk_Read(w wire.Value) (*Bonk, error) {
	var v Bonk
	err := v.FromWire(w)
	return &v, err
}

func _List_Bonk_Read(l wire.ValueList) ([]*Bonk, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make([]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Bonk_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *ListBonks) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Bonk, err = _List_Bonk_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *ListBonks) String() string {
	var fields [1]string
	i := 0
	if v.Bonk != nil {
		fields[i] = fmt.Sprintf("Bonk: %v", v.Bonk)
		i++
	}
	return fmt.Sprintf("ListBonks{%v}", strings.Join(fields[:i], ", "))
}

type ListTypeVersioningV1 struct {
	Myints []int32 `json:"myints"`
	Hello  *string `json:"hello,omitempty"`
}

func (v *ListTypeVersioningV1) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Myints != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Myints)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Hello != nil {
		w, err = wire.NewValueString(*(v.Hello)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *ListTypeVersioningV1) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Myints, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Hello = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *ListTypeVersioningV1) String() string {
	var fields [2]string
	i := 0
	if v.Myints != nil {
		fields[i] = fmt.Sprintf("Myints: %v", v.Myints)
		i++
	}
	if v.Hello != nil {
		fields[i] = fmt.Sprintf("Hello: %v", *(v.Hello))
		i++
	}
	return fmt.Sprintf("ListTypeVersioningV1{%v}", strings.Join(fields[:i], ", "))
}

type ListTypeVersioningV2 struct {
	Strings []string `json:"strings"`
	Hello   *string  `json:"hello,omitempty"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {
}

func (v *ListTypeVersioningV2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Strings != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Strings)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Hello != nil {
		w, err = wire.NewValueString(*(v.Hello)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}
	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *ListTypeVersioningV2) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Strings, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Hello = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *ListTypeVersioningV2) String() string {
	var fields [2]string
	i := 0
	if v.Strings != nil {
		fields[i] = fmt.Sprintf("Strings: %v", v.Strings)
		i++
	}
	if v.Hello != nil {
		fields[i] = fmt.Sprintf("Hello: %v", *(v.Hello))
		i++
	}
	return fmt.Sprintf("ListTypeVersioningV2{%v}", strings.Join(fields[:i], ", "))
}

type _Map_String_Bonk_MapItemList map[string]*Bonk

func (m _Map_String_Bonk_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Bonk_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Bonk_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Bonk_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_Bonk_MapItemList) Close() {
}

func _Map_String_Bonk_Read(m wire.MapItemList) (map[string]*Bonk, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}
	if m.ValueType() != wire.TStruct {
		return nil, nil
	}
	o := make(map[string]*Bonk, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Bonk_Read(x.Value)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

type MapType map[string]*Bonk

func (v MapType) ToWire() (wire.Value, error) {
	x := (map[string]*Bonk)(v)
	return wire.NewValueMap(_Map_String_Bonk_MapItemList(x)), error(nil)
}

func (v MapType) String() string {
	x := (map[string]*Bonk)(v)
	return fmt.Sprint(x)
}

func (v *MapType) FromWire(w wire.Value) error {
	x, err := _Map_String_Bonk_Read(w.GetMap())
	*v = (MapType)(x)
	return err
}

type NestedListsBonk struct {
	Bonk [][][]*Bonk `json:"bonk"`
}

type _List_List_Bonk_ValueList [][]*Bonk

func (v _List_List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_Bonk_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_Bonk_ValueList) Close() {
}

type _List_List_List_Bonk_ValueList [][][]*Bonk

func (v _List_List_List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_List_Bonk_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_List_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_List_Bonk_ValueList) Close() {
}

func (v *NestedListsBonk) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Bonk != nil {
		w, err = wire.NewValueList(_List_List_List_Bonk_ValueList(v.Bonk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_Bonk_Read(l wire.ValueList) ([][]*Bonk, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}
	o := make([][]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_Bonk_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_List_List_Bonk_Read(l wire.ValueList) ([][][]*Bonk, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}
	o := make([][][]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_List_Bonk_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *NestedListsBonk) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Bonk, err = _List_List_List_Bonk_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *NestedListsBonk) String() string {
	var fields [1]string
	i := 0
	if v.Bonk != nil {
		fields[i] = fmt.Sprintf("Bonk: %v", v.Bonk)
		i++
	}
	return fmt.Sprintf("NestedListsBonk{%v}", strings.Join(fields[:i], ", "))
}

type NestedListsI32x2 struct {
	Integerlist [][]int32 `json:"integerlist"`
}

type _List_List_I32_ValueList [][]int32

func (v _List_List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_List_I32_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_I32_ValueList) Close() {
}

func (v *NestedListsI32x2) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Integerlist != nil {
		w, err = wire.NewValueList(_List_List_I32_ValueList(v.Integerlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_I32_Read(l wire.ValueList) ([][]int32, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}
	o := make([][]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_I32_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *NestedListsI32x2) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Integerlist, err = _List_List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *NestedListsI32x2) String() string {
	var fields [1]string
	i := 0
	if v.Integerlist != nil {
		fields[i] = fmt.Sprintf("Integerlist: %v", v.Integerlist)
		i++
	}
	return fmt.Sprintf("NestedListsI32x2{%v}", strings.Join(fields[:i], ", "))
}

type NestedListsI32x3 struct {
	Integerlist [][][]int32 `json:"integerlist"`
}

type _List_List_List_I32_ValueList [][][]int32

func (v _List_List_List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_List_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_List_List_I32_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_List_I32_ValueList) Close() {
}

func (v *NestedListsI32x3) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Integerlist != nil {
		w, err = wire.NewValueList(_List_List_List_I32_ValueList(v.Integerlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_List_I32_Read(l wire.ValueList) ([][][]int32, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}
	o := make([][][]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_List_I32_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *NestedListsI32x3) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Integerlist, err = _List_List_List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *NestedListsI32x3) String() string {
	var fields [1]string
	i := 0
	if v.Integerlist != nil {
		fields[i] = fmt.Sprintf("Integerlist: %v", v.Integerlist)
		i++
	}
	return fmt.Sprintf("NestedListsI32x3{%v}", strings.Join(fields[:i], ", "))
}

type NestedMixedx2 struct {
	IntSetList       []map[int32]struct{}            `json:"int_set_list"`
	MapIntStrset     map[int32]map[string]struct{}   `json:"map_int_strset"`
	MapIntStrsetList []map[int32]map[string]struct{} `json:"map_int_strset_list"`
}

type _List_Set_I32_ValueList []map[int32]struct{}

func (v _List_Set_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueSet(_Set_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Set_I32_ValueList) Size() int {
	return len(v)
}

func (_List_Set_I32_ValueList) ValueType() wire.Type {
	return wire.TSet
}

func (_List_Set_I32_ValueList) Close() {
}

type _Map_I32_Set_String_MapItemList map[int32]map[string]struct{}

func (m _Map_I32_Set_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueSet(_Set_String_ValueList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Set_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Set_String_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Set_String_MapItemList) ValueType() wire.Type {
	return wire.TSet
}

func (_Map_I32_Set_String_MapItemList) Close() {
}

type _List_Map_I32_Set_String_ValueList []map[int32]map[string]struct{}

func (v _List_Map_I32_Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_I32_Set_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_I32_Set_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_I32_Set_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_I32_Set_String_ValueList) Close() {
}

func (v *NestedMixedx2) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.IntSetList != nil {
		w, err = wire.NewValueList(_List_Set_I32_ValueList(v.IntSetList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.MapIntStrset != nil {
		w, err = wire.NewValueMap(_Map_I32_Set_String_MapItemList(v.MapIntStrset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.MapIntStrsetList != nil {
		w, err = wire.NewValueList(_List_Map_I32_Set_String_ValueList(v.MapIntStrsetList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Set_I32_Read(l wire.ValueList) ([]map[int32]struct{}, error) {
	if l.ValueType() != wire.TSet {
		return nil, nil
	}
	o := make([]map[int32]struct{}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Set_I32_Read(x.GetSet())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Map_I32_Set_String_Read(m wire.MapItemList) (map[int32]map[string]struct{}, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}
	if m.ValueType() != wire.TSet {
		return nil, nil
	}
	o := make(map[int32]map[string]struct{}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}
		v, err := _Set_String_Read(x.Value.GetSet())
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_I32_Set_String_Read(l wire.ValueList) ([]map[int32]map[string]struct{}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}
	o := make([]map[int32]map[string]struct{}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_I32_Set_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func (v *NestedMixedx2) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.IntSetList, err = _List_Set_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.MapIntStrset, err = _Map_I32_Set_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.MapIntStrsetList, err = _List_Map_I32_Set_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *NestedMixedx2) String() string {
	var fields [3]string
	i := 0
	if v.IntSetList != nil {
		fields[i] = fmt.Sprintf("IntSetList: %v", v.IntSetList)
		i++
	}
	if v.MapIntStrset != nil {
		fields[i] = fmt.Sprintf("MapIntStrset: %v", v.MapIntStrset)
		i++
	}
	if v.MapIntStrsetList != nil {
		fields[i] = fmt.Sprintf("MapIntStrsetList: %v", v.MapIntStrsetList)
		i++
	}
	return fmt.Sprintf("NestedMixedx2{%v}", strings.Join(fields[:i], ", "))
}

type Numberz int32

const (
	NumberzOne   Numberz = 1
	NumberzTwo   Numberz = 2
	NumberzThree Numberz = 3
	NumberzFive  Numberz = 5
	NumberzSix   Numberz = 6
	NumberzEight Numberz = 8
)

func (v Numberz) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

func (v *Numberz) FromWire(w wire.Value) error {
	*v = (Numberz)(w.GetI32())
	return nil
}

func (v Numberz) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "ONE"
	case 2:
		return "TWO"
	case 3:
		return "THREE"
	case 5:
		return "FIVE"
	case 6:
		return "SIX"
	case 8:
		return "EIGHT"
	}
	return fmt.Sprintf("Numberz(%d)", w)
}

func (v Numberz) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"ONE\""), nil
	case 2:
		return ([]byte)("\"TWO\""), nil
	case 3:
		return ([]byte)("\"THREE\""), nil
	case 5:
		return ([]byte)("\"FIVE\""), nil
	case 6:
		return ([]byte)("\"SIX\""), nil
	case 8:
		return ([]byte)("\"EIGHT\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

func (v *Numberz) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}
	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Numberz")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Numberz")
		}
		*v = (Numberz)(x)
		return nil
	case string:
		switch w {
		case "ONE":
			*v = NumberzOne
			return nil
		case "TWO":
			*v = NumberzTwo
			return nil
		case "THREE":
			*v = NumberzThree
			return nil
		case "FIVE":
			*v = NumberzFive
			return nil
		case "SIX":
			*v = NumberzSix
			return nil
		case "EIGHT":
			*v = NumberzEight
			return nil
		default:
			return fmt.Errorf("unknown enum value %q for %q", w, "Numberz")
		}
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Numberz")
	}
}

type OneField struct {
	Field *EmptyStruct `json:"field,omitempty"`
}

func (v *OneField) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Field != nil {
		w, err = v.Field.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EmptyStruct_Read(w wire.Value) (*EmptyStruct, error) {
	var v EmptyStruct
	err := v.FromWire(w)
	return &v, err
}

func (v *OneField) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Field, err = _EmptyStruct_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *OneField) String() string {
	var fields [1]string
	i := 0
	if v.Field != nil {
		fields[i] = fmt.Sprintf("Field: %v", v.Field)
		i++
	}
	return fmt.Sprintf("OneField{%v}", strings.Join(fields[:i], ", "))
}

type StructA struct {
	S string `json:"s"`
}

func (v *StructA) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	w, err = wire.NewValueString(v.S), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *StructA) FromWire(w wire.Value) error {
	var err error
	sIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.S, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				sIsSet = true
			}
		}
	}
	if !sIsSet {
		return errors.New("field S of StructA is required")
	}
	return nil
}

func (v *StructA) String() string {
	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("S: %v", v.S)
	i++
	return fmt.Sprintf("StructA{%v}", strings.Join(fields[:i], ", "))
}

type StructB struct {
	Aa *StructA `json:"aa,omitempty"`
	Ab *StructA `json:"ab"`
}

func (v *StructB) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.Aa != nil {
		w, err = v.Aa.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Ab == nil {
		return w, errors.New("field Ab of StructB is required")
	}
	w, err = v.Ab.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _StructA_Read(w wire.Value) (*StructA, error) {
	var v StructA
	err := v.FromWire(w)
	return &v, err
}

func (v *StructB) FromWire(w wire.Value) error {
	var err error
	abIsSet := false
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Aa, err = _StructA_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Ab, err = _StructA_Read(field.Value)
				if err != nil {
					return err
				}
				abIsSet = true
			}
		}
	}
	if !abIsSet {
		return errors.New("field Ab of StructB is required")
	}
	return nil
}

func (v *StructB) String() string {
	var fields [2]string
	i := 0
	if v.Aa != nil {
		fields[i] = fmt.Sprintf("Aa: %v", v.Aa)
		i++
	}
	fields[i] = fmt.Sprintf("Ab: %v", v.Ab)
	i++
	return fmt.Sprintf("StructB{%v}", strings.Join(fields[:i], ", "))
}

type UserId int64

func (v UserId) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

func (v UserId) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

func (v *UserId) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (UserId)(x)
	return err
}

type VersioningTestV1 struct {
	BeginInBoth *int32  `json:"begin_in_both,omitempty"`
	OldString   *string `json:"old_string,omitempty"`
	EndInBoth   *int32  `json:"end_in_both,omitempty"`
}

func (v *VersioningTestV1) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.BeginInBoth != nil {
		w, err = wire.NewValueI32(*(v.BeginInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.OldString != nil {
		w, err = wire.NewValueString(*(v.OldString)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.EndInBoth != nil {
		w, err = wire.NewValueI32(*(v.EndInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *VersioningTestV1) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BeginInBoth = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.OldString = &x
				if err != nil {
					return err
				}
			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EndInBoth = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *VersioningTestV1) String() string {
	var fields [3]string
	i := 0
	if v.BeginInBoth != nil {
		fields[i] = fmt.Sprintf("BeginInBoth: %v", *(v.BeginInBoth))
		i++
	}
	if v.OldString != nil {
		fields[i] = fmt.Sprintf("OldString: %v", *(v.OldString))
		i++
	}
	if v.EndInBoth != nil {
		fields[i] = fmt.Sprintf("EndInBoth: %v", *(v.EndInBoth))
		i++
	}
	return fmt.Sprintf("VersioningTestV1{%v}", strings.Join(fields[:i], ", "))
}

type VersioningTestV2 struct {
	BeginInBoth *int32             `json:"begin_in_both,omitempty"`
	Newint      *int32             `json:"newint,omitempty"`
	Newbyte     *int8              `json:"newbyte,omitempty"`
	Newshort    *int16             `json:"newshort,omitempty"`
	Newlong     *int64             `json:"newlong,omitempty"`
	Newdouble   *float64           `json:"newdouble,omitempty"`
	Newstruct   *Bonk              `json:"newstruct,omitempty"`
	Newlist     []int32            `json:"newlist"`
	Newset      map[int32]struct{} `json:"newset"`
	Newmap      map[int32]int32    `json:"newmap"`
	Newstring   *string            `json:"newstring,omitempty"`
	EndInBoth   *int32             `json:"end_in_both,omitempty"`
}

type _Map_I32_I32_MapItemList map[int32]int32

func (m _Map_I32_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}
		vw, err := wire.NewValueI32(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_I32_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_I32_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_I32_I32_MapItemList) Close() {
}

func (v *VersioningTestV2) ToWire() (wire.Value, error) {
	var (
		fields [12]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.BeginInBoth != nil {
		w, err = wire.NewValueI32(*(v.BeginInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Newint != nil {
		w, err = wire.NewValueI32(*(v.Newint)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Newbyte != nil {
		w, err = wire.NewValueI8(*(v.Newbyte)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Newshort != nil {
		w, err = wire.NewValueI16(*(v.Newshort)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Newlong != nil {
		w, err = wire.NewValueI64(*(v.Newlong)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Newdouble != nil {
		w, err = wire.NewValueDouble(*(v.Newdouble)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.Newstruct != nil {
		w, err = v.Newstruct.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.Newlist != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Newlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}
	if v.Newset != nil {
		w, err = wire.NewValueSet(_Set_I32_ValueList(v.Newset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.Newmap != nil {
		w, err = wire.NewValueMap(_Map_I32_I32_MapItemList(v.Newmap)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Newstring != nil {
		w, err = wire.NewValueString(*(v.Newstring)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	if v.EndInBoth != nil {
		w, err = wire.NewValueI32(*(v.EndInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_I32_I32_Read(m wire.MapItemList) (map[int32]int32, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}
	if m.ValueType() != wire.TI32 {
		return nil, nil
	}
	o := make(map[int32]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}
		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}
		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func (v *VersioningTestV2) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BeginInBoth = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Newint = &x
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.Newbyte = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Newshort = &x
				if err != nil {
					return err
				}
			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Newlong = &x
				if err != nil {
					return err
				}
			}
		case 6:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.Newdouble = &x
				if err != nil {
					return err
				}
			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.Newstruct, err = _Bonk_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 8:
			if field.Value.Type() == wire.TList {
				v.Newlist, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}
			}
		case 9:
			if field.Value.Type() == wire.TSet {
				v.Newset, err = _Set_I32_Read(field.Value.GetSet())
				if err != nil {
					return err
				}
			}
		case 10:
			if field.Value.Type() == wire.TMap {
				v.Newmap, err = _Map_I32_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}
			}
		case 11:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Newstring = &x
				if err != nil {
					return err
				}
			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EndInBoth = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *VersioningTestV2) String() string {
	var fields [12]string
	i := 0
	if v.BeginInBoth != nil {
		fields[i] = fmt.Sprintf("BeginInBoth: %v", *(v.BeginInBoth))
		i++
	}
	if v.Newint != nil {
		fields[i] = fmt.Sprintf("Newint: %v", *(v.Newint))
		i++
	}
	if v.Newbyte != nil {
		fields[i] = fmt.Sprintf("Newbyte: %v", *(v.Newbyte))
		i++
	}
	if v.Newshort != nil {
		fields[i] = fmt.Sprintf("Newshort: %v", *(v.Newshort))
		i++
	}
	if v.Newlong != nil {
		fields[i] = fmt.Sprintf("Newlong: %v", *(v.Newlong))
		i++
	}
	if v.Newdouble != nil {
		fields[i] = fmt.Sprintf("Newdouble: %v", *(v.Newdouble))
		i++
	}
	if v.Newstruct != nil {
		fields[i] = fmt.Sprintf("Newstruct: %v", v.Newstruct)
		i++
	}
	if v.Newlist != nil {
		fields[i] = fmt.Sprintf("Newlist: %v", v.Newlist)
		i++
	}
	if v.Newset != nil {
		fields[i] = fmt.Sprintf("Newset: %v", v.Newset)
		i++
	}
	if v.Newmap != nil {
		fields[i] = fmt.Sprintf("Newmap: %v", v.Newmap)
		i++
	}
	if v.Newstring != nil {
		fields[i] = fmt.Sprintf("Newstring: %v", *(v.Newstring))
		i++
	}
	if v.EndInBoth != nil {
		fields[i] = fmt.Sprintf("EndInBoth: %v", *(v.EndInBoth))
		i++
	}
	return fmt.Sprintf("VersioningTestV2{%v}", strings.Join(fields[:i], ", "))
}

type Xception struct {
	ErrorCode *int32  `json:"errorCode,omitempty"`
	Message   *string `json:"message,omitempty"`
}

func (v *Xception) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Xception) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Xception) String() string {
	var fields [2]string
	i := 0
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	return fmt.Sprintf("Xception{%v}", strings.Join(fields[:i], ", "))
}

func (v *Xception) Error() string {
	return v.String()
}

type Xception2 struct {
	ErrorCode   *int32  `json:"errorCode,omitempty"`
	StructThing *Xtruct `json:"struct_thing,omitempty"`
}

func (v *Xception2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StructThing != nil {
		w, err = v.StructThing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Xception2) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.StructThing, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Xception2) String() string {
	var fields [2]string
	i := 0
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	if v.StructThing != nil {
		fields[i] = fmt.Sprintf("StructThing: %v", v.StructThing)
		i++
	}
	return fmt.Sprintf("Xception2{%v}", strings.Join(fields[:i], ", "))
}

func (v *Xception2) Error() string {
	return v.String()
}

type Xtruct struct {
	StringThing *string `json:"string_thing,omitempty"`
	ByteThing   *int8   `json:"byte_thing,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
	I64Thing    *int64  `json:"i64_thing,omitempty"`
}

func (v *Xtruct) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.StringThing != nil {
		w, err = wire.NewValueString(*(v.StringThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ByteThing != nil {
		w, err = wire.NewValueI8(*(v.ByteThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.I64Thing != nil {
		w, err = wire.NewValueI64(*(v.I64Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Xtruct) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringThing = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteThing = &x
				if err != nil {
					return err
				}
			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}
			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.I64Thing = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Xtruct) String() string {
	var fields [4]string
	i := 0
	if v.StringThing != nil {
		fields[i] = fmt.Sprintf("StringThing: %v", *(v.StringThing))
		i++
	}
	if v.ByteThing != nil {
		fields[i] = fmt.Sprintf("ByteThing: %v", *(v.ByteThing))
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}
	if v.I64Thing != nil {
		fields[i] = fmt.Sprintf("I64Thing: %v", *(v.I64Thing))
		i++
	}
	return fmt.Sprintf("Xtruct{%v}", strings.Join(fields[:i], ", "))
}

type Xtruct2 struct {
	ByteThing   *int8   `json:"byte_thing,omitempty"`
	StructThing *Xtruct `json:"struct_thing,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
}

func (v *Xtruct2) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.ByteThing != nil {
		w, err = wire.NewValueI8(*(v.ByteThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StructThing != nil {
		w, err = v.StructThing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Xtruct2) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteThing = &x
				if err != nil {
					return err
				}
			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.StructThing, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}
			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Xtruct2) String() string {
	var fields [3]string
	i := 0
	if v.ByteThing != nil {
		fields[i] = fmt.Sprintf("ByteThing: %v", *(v.ByteThing))
		i++
	}
	if v.StructThing != nil {
		fields[i] = fmt.Sprintf("StructThing: %v", v.StructThing)
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}
	return fmt.Sprintf("Xtruct2{%v}", strings.Join(fields[:i], ", "))
}

type Xtruct3 struct {
	StringThing *string `json:"string_thing,omitempty"`
	Changed     *int32  `json:"changed,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
	I64Thing    *int64  `json:"i64_thing,omitempty"`
}

func (v *Xtruct3) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)
	if v.StringThing != nil {
		w, err = wire.NewValueString(*(v.StringThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Changed != nil {
		w, err = wire.NewValueI32(*(v.Changed)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.I64Thing != nil {
		w, err = wire.NewValueI64(*(v.I64Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func (v *Xtruct3) FromWire(w wire.Value) error {
	var err error
	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringThing = &x
				if err != nil {
					return err
				}
			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Changed = &x
				if err != nil {
					return err
				}
			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}
			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.I64Thing = &x
				if err != nil {
					return err
				}
			}
		}
	}
	return nil
}

func (v *Xtruct3) String() string {
	var fields [4]string
	i := 0
	if v.StringThing != nil {
		fields[i] = fmt.Sprintf("StringThing: %v", *(v.StringThing))
		i++
	}
	if v.Changed != nil {
		fields[i] = fmt.Sprintf("Changed: %v", *(v.Changed))
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}
	if v.I64Thing != nil {
		fields[i] = fmt.Sprintf("I64Thing: %v", *(v.I64Thing))
		i++
	}
	return fmt.Sprintf("Xtruct3{%v}", strings.Join(fields[:i], ", "))
}
