// Code generated by protoc-gen-yarpc-go
// source: src/keyvalue/key_value.proto
// DO NOT EDIT!

package keyvaluepb

import (
	context "context"
	fmt "fmt"
	proto "github.com/gogo/protobuf/proto"
	fx "go.uber.org/fx"
	yarpc "go.uber.org/yarpc/v2"
	yarpcprotobuf "go.uber.org/yarpc/v2/yarpcprotobuf"
	common "go.uber.org/yarpc/v2/yarpcprotobuf/protoc-gen-yarpc-go/internal/tests/gen/proto/src/common"
	reflection "go.uber.org/yarpc/v2/yarpcprotobuf/reflection"
)

// StoreYARPCClient is the Store service's client interface.
type StoreYARPCClient interface {
	Get(
		context.Context,
		*common.GetRequest,
		...yarpc.CallOption,
	) (*common.GetResponse, error)
	Set(
		context.Context,
		*common.SetRequest,
		...yarpc.CallOption,
	) (*common.SetResponse, error)
}

// NewStoreYARPCClient builds a new YARPC client for the Store service.
func NewStoreYARPCClient(c yarpc.Client, opts ...yarpcprotobuf.ClientOption) StoreYARPCClient {
	return &_StoreYARPCClient{stream: yarpcprotobuf.NewStreamClient(c, "keyvalue.Store", opts...)}
}

type _StoreYARPCClient struct {
	stream yarpcprotobuf.StreamClient
}

var _ StoreYARPCClient = (*_StoreYARPCClient)(nil)

func (c *_StoreYARPCClient) Get(ctx context.Context, req *common.GetRequest, opts ...yarpc.CallOption) (*common.GetResponse, error) {
	msg, err := c.stream.Call(ctx, "Get", req, new(common.GetResponse), opts...)
	if err != nil {
		return nil, err
	}
	res, ok := msg.(*common.GetResponse)
	if !ok {
		return nil, yarpcprotobuf.CastError(new(common.GetResponse), res)
	}
	return res, nil
}

func (c *_StoreYARPCClient) Set(ctx context.Context, req *common.SetRequest, opts ...yarpc.CallOption) (*common.SetResponse, error) {
	msg, err := c.stream.Call(ctx, "Set", req, new(common.SetResponse), opts...)
	if err != nil {
		return nil, err
	}
	res, ok := msg.(*common.SetResponse)
	if !ok {
		return nil, yarpcprotobuf.CastError(new(common.SetResponse), res)
	}
	return res, nil
}

// StoreYARPCServer is the Store service's server interface.
type StoreYARPCServer interface {
	Get(
		context.Context,
		*common.GetRequest,
	) (*common.GetResponse, error)
	Set(
		context.Context,
		*common.SetRequest,
	) (*common.SetResponse, error)
}

// BuildUnaryStoreYARPCProcedures constructs the YARPC unary procedures for the Store service.
func BuildUnaryStoreYARPCProcedures(s StoreYARPCServer) []yarpc.EncodingProcedure {
	h := &_StoreYARPCServer{server: s}
	return yarpcprotobuf.UnaryProcedures(
		yarpcprotobuf.UnaryProceduresParams{
			Service: "keyvalue.Store",
			Unary: []yarpcprotobuf.UnaryProcedure{
				{
					Method: "Get",
					Handler: yarpcprotobuf.NewUnaryHandler(
						yarpcprotobuf.UnaryHandlerParams{
							Handle: h.Get,
						},
					),
					RequestType: func() proto.Message { return new(common.GetRequest) },
				},
				{
					Method: "Set",
					Handler: yarpcprotobuf.NewUnaryHandler(
						yarpcprotobuf.UnaryHandlerParams{
							Handle: h.Set,
						},
					),
					RequestType: func() proto.Message { return new(common.SetRequest) },
				},
			},
		},
	)
}

type _StoreYARPCServer struct {
	server StoreYARPCServer
}

func (h *_StoreYARPCServer) Get(ctx context.Context, m proto.Message) (proto.Message, error) {
	req, _ := m.(*common.GetRequest)
	if req == nil {
		return nil, yarpcprotobuf.CastError(new(common.GetRequest), m)
	}

	// This is intentional. While it seems like
	//
	//   return h.server.Get(ctx, req)
	//
	// will behave the same way, the dynamic value of the nil returned is
	// strongly typed. When carried around later as  interface{} (specifically in
	// `codec.Encode(...)`), this nil response gets carried as a nil-of-type-response
	// value, making it non-nil. We prefer to replace it with an absolute nil
	// before we pass it up.
	// This issue is akin to https://golang.org/doc/faq#nil_error.
	res, err := h.server.Get(ctx, req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

func (h *_StoreYARPCServer) Set(ctx context.Context, m proto.Message) (proto.Message, error) {
	req, _ := m.(*common.SetRequest)
	if req == nil {
		return nil, yarpcprotobuf.CastError(new(common.SetRequest), m)
	}

	// This is intentional. While it seems like
	//
	//   return h.server.Set(ctx, req)
	//
	// will behave the same way, the dynamic value of the nil returned is
	// strongly typed. When carried around later as  interface{} (specifically in
	// `codec.Encode(...)`), this nil response gets carried as a nil-of-type-response
	// value, making it non-nil. We prefer to replace it with an absolute nil
	// before we pass it up.
	// This issue is akin to https://golang.org/doc/faq#nil_error.
	res, err := h.server.Set(ctx, req)
	if err != nil {
		return nil, err
	}
	return res, nil
}

// FxStoreYARPCClientParams defines the parameters
// required to provide a StoreYARPCClient into an
// Fx application.
type FxStoreYARPCClientParams struct {
	fx.In

	ClientProvider yarpc.ClientProvider
}

// FxStoreYARPCClientResult provides a StoreYARPCClient
// into an Fx application.
type FxStoreYARPCClientResult struct {
	fx.Out

	Client StoreYARPCClient
}

// NewFxStoreYARPCClient provides a StoreYARPCClient
// into an Fx application, using the given
// name for routing.
//
//  fx.Provide(
//    keyvaluepb.NewFxStoreYARPCClient("service-name"),
//    ...
//  )
func NewFxStoreYARPCClient(name string, opts ...yarpcprotobuf.ClientOption) interface{} {
	return func(p FxStoreYARPCClientParams) (FxStoreYARPCClientResult, error) {
		client, ok := p.ClientProvider.Client(name)
		if !ok {
			return FxStoreYARPCClientResult{},
				fmt.Errorf("generated code could not retrieve client for %q", name)
		}
		return FxStoreYARPCClientResult{
			Client: NewStoreYARPCClient(client, opts...),
		}, nil
	}
}

// FxStoreYARPCServerParams defines the paramaters
// required to provide the StoreYARPCServer procedures
// into an Fx application.
type FxStoreYARPCServerParams struct {
	fx.In

	Server StoreYARPCServer
}

// FxStoreYARPCServerResult provides the StoreYARPCServer
// procedures into an Fx application.
type FxStoreYARPCServerResult struct {
	fx.Out

	UnaryProcedures []yarpc.EncodingProcedure `group:"yarpcfx"`

	ReflectionMeta reflection.ServerMeta `group:"yarpcfx"`
}

// NewFxStoreYARPCServer provides the StoreYARPCServer
// procedures to an Fx application. It expects
// a StoreYARPCServer to be present in the container.
//
//  fx.Provide(
//    keyvaluepb.NewFxStoreYARPCServer(),
//    ...
//  )
func NewFxStoreYARPCServer() interface{} {
	return func(p FxStoreYARPCServerParams) FxStoreYARPCServerResult {
		return FxStoreYARPCServerResult{
			UnaryProcedures: BuildUnaryStoreYARPCProcedures(p.Server),

			ReflectionMeta: reflection.ServerMeta{
				ServiceName:     "keyvalue.Store",
				FileDescriptors: yarpcFileDescriptorClosure8a9b3e67e16f054c,
			},
		}
	}
}

var yarpcFileDescriptorClosure8a9b3e67e16f054c = [][]byte{
	// src/keyvalue/key_value.proto
	[]byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x92, 0x29, 0x2e, 0x4a, 0xd6,
		0xcf, 0x4e, 0xad, 0x2c, 0x4b, 0xcc, 0x29, 0x4d, 0x05, 0x31, 0xe2, 0xc1, 0x2c, 0xbd, 0x82, 0xa2,
		0xfc, 0x92, 0x7c, 0x21, 0x0e, 0x98, 0x8c, 0x94, 0x38, 0x48, 0x5d, 0x72, 0x7e, 0x6e, 0x6e, 0x7e,
		0x1e, 0x94, 0x82, 0x28, 0x31, 0x4a, 0xe7, 0x62, 0x0d, 0x2e, 0xc9, 0x2f, 0x4a, 0x15, 0xd2, 0xe3,
		0x62, 0x76, 0x4f, 0x2d, 0x11, 0x12, 0xd2, 0x83, 0x4a, 0xbb, 0xa7, 0x96, 0x04, 0xa5, 0x16, 0x96,
		0xa6, 0x16, 0x97, 0x48, 0x09, 0xa3, 0x88, 0x15, 0x17, 0xe4, 0xe7, 0x15, 0x83, 0xd5, 0x07, 0x23,
		0xab, 0x0f, 0xc6, 0xa2, 0x3e, 0x18, 0xa1, 0xde, 0xc9, 0xe1, 0xc2, 0x43, 0x39, 0x86, 0x1b, 0x0f,
		0xe5, 0x18, 0x3e, 0x3c, 0x94, 0x63, 0x6c, 0x78, 0x24, 0xc7, 0xb8, 0xe2, 0x91, 0x1c, 0xe3, 0x89,
		0x47, 0x72, 0x8c, 0x17, 0x1e, 0xc9, 0x31, 0x3e, 0x78, 0x24, 0xc7, 0xf8, 0xe2, 0x91, 0x1c, 0xc3,
		0x87, 0x47, 0x72, 0x8c, 0x13, 0x1e, 0xcb, 0x31, 0x5c, 0x78, 0x2c, 0xc7, 0x70, 0xe3, 0xb1, 0x1c,
		0x43, 0x14, 0x17, 0xcc, 0x07, 0x05, 0x49, 0x49, 0x6c, 0x60, 0x17, 0x1b, 0x03, 0x02, 0x00, 0x00,
		0xff, 0xff, 0x44, 0xde, 0x7f, 0xa2, 0xf4, 0x00, 0x00, 0x00,
	},
	// src/common/common.proto
	[]byte{
		0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0xe2, 0x12, 0x2f, 0x2e, 0x4a, 0xd6,
		0x4f, 0xce, 0xcf, 0xcd, 0xcd, 0xcf, 0x83, 0x52, 0x7a, 0x05, 0x45, 0xf9, 0x25, 0xf9, 0x42, 0x6c,
		0x10, 0x9e, 0x92, 0x1c, 0x17, 0x97, 0x7b, 0x6a, 0x49, 0x50, 0x6a, 0x61, 0x69, 0x6a, 0x71, 0x89,
		0x90, 0x00, 0x17, 0x73, 0x76, 0x6a, 0xa5, 0x04, 0xa3, 0x02, 0xa3, 0x06, 0x67, 0x10, 0x88, 0xa9,
		0xa4, 0xcc, 0xc5, 0x0d, 0x96, 0x2f, 0x2e, 0xc8, 0xcf, 0x2b, 0x4e, 0x15, 0x12, 0xe1, 0x62, 0x2d,
		0x4b, 0xcc, 0x29, 0x4d, 0x85, 0x2a, 0x81, 0x70, 0x94, 0x4c, 0xb8, 0xb8, 0x82, 0xf1, 0x18, 0x82,
		0xd0, 0xc5, 0x84, 0xac, 0x8b, 0x97, 0x8b, 0x3b, 0x18, 0x61, 0xb4, 0x93, 0xdd, 0x85, 0x87, 0x72,
		0x0c, 0x37, 0x1e, 0xca, 0x31, 0x7c, 0x78, 0x28, 0xc7, 0xd8, 0xf0, 0x48, 0x8e, 0x71, 0xc5, 0x23,
		0x39, 0xc6, 0x13, 0x8f, 0xe4, 0x18, 0x2f, 0x3c, 0x92, 0x63, 0x7c, 0xf0, 0x48, 0x8e, 0xf1, 0xc5,
		0x23, 0x39, 0x86, 0x0f, 0x8f, 0xe4, 0x18, 0x27, 0x3c, 0x96, 0x63, 0xb8, 0xf0, 0x58, 0x8e, 0xe1,
		0xc6, 0x63, 0x39, 0x86, 0x28, 0x0e, 0x88, 0x3f, 0x0a, 0x92, 0x92, 0xd8, 0xc0, 0x1e, 0x33, 0x06,
		0x04, 0x00, 0x00, 0xff, 0xff, 0x81, 0x3b, 0x0d, 0xe0, 0xf3, 0x00, 0x00, 0x00,
	},
}
