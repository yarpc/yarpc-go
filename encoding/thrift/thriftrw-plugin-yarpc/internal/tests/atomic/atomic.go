// Code generated by thriftrw v1.28.0. DO NOT EDIT.
// @generated

package atomic

import (
	errors "errors"
	fmt "fmt"
	multierr "go.uber.org/multierr"
	stream "go.uber.org/thriftrw/protocol/stream"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	common "go.uber.org/yarpc/encoding/thrift/thriftrw-plugin-yarpc/internal/tests/common"
	zapcore "go.uber.org/zap/zapcore"
	strings "strings"
)

type CompareAndSwap struct {
	Key          string `json:"key,required"`
	CurrentValue int64  `json:"currentValue,required"`
	NewValue     int64  `json:"newValue,required"`
}

// ToWire translates a CompareAndSwap struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CompareAndSwap) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.Key), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueI64(v.CurrentValue), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	w, err = wire.NewValueI64(v.NewValue), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a CompareAndSwap struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CompareAndSwap struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CompareAndSwap
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CompareAndSwap) FromWire(w wire.Value) error {
	var err error

	keyIsSet := false
	currentValueIsSet := false
	newValueIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Key, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				keyIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				v.CurrentValue, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				currentValueIsSet = true
			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				v.NewValue, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				newValueIsSet = true
			}
		}
	}

	if !keyIsSet {
		return errors.New("field Key of CompareAndSwap is required")
	}

	if !currentValueIsSet {
		return errors.New("field CurrentValue of CompareAndSwap is required")
	}

	if !newValueIsSet {
		return errors.New("field NewValue of CompareAndSwap is required")
	}

	return nil
}

// Encode serializes a CompareAndSwap struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a CompareAndSwap struct could not be encoded.
func (v *CompareAndSwap) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
		return err
	}
	if err := sw.WriteString(v.Key); err != nil {
		return err
	}
	if err := sw.WriteFieldEnd(); err != nil {
		return err
	}

	if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TI64}); err != nil {
		return err
	}
	if err := sw.WriteInt64(v.CurrentValue); err != nil {
		return err
	}
	if err := sw.WriteFieldEnd(); err != nil {
		return err
	}

	if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI64}); err != nil {
		return err
	}
	if err := sw.WriteInt64(v.NewValue); err != nil {
		return err
	}
	if err := sw.WriteFieldEnd(); err != nil {
		return err
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a CompareAndSwap struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a CompareAndSwap struct could not be generated from the wire
// representation.
func (v *CompareAndSwap) Decode(sr stream.Reader) error {

	keyIsSet := false
	currentValueIsSet := false
	newValueIsSet := false

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TBinary {
				v.Key, err = sr.ReadString()
				if err != nil {
					return err
				}
				keyIsSet = true
			}
		case 2:
			if fh.Type == wire.TI64 {
				v.CurrentValue, err = sr.ReadInt64()
				if err != nil {
					return err
				}
				currentValueIsSet = true
			}
		case 3:
			if fh.Type == wire.TI64 {
				v.NewValue, err = sr.ReadInt64()
				if err != nil {
					return err
				}
				newValueIsSet = true
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	if !keyIsSet {
		return errors.New("field Key of CompareAndSwap is required")
	}

	if !currentValueIsSet {
		return errors.New("field CurrentValue of CompareAndSwap is required")
	}

	if !newValueIsSet {
		return errors.New("field NewValue of CompareAndSwap is required")
	}

	return nil
}

// String returns a readable string representation of a CompareAndSwap
// struct.
func (v *CompareAndSwap) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	fields[i] = fmt.Sprintf("Key: %v", v.Key)
	i++
	fields[i] = fmt.Sprintf("CurrentValue: %v", v.CurrentValue)
	i++
	fields[i] = fmt.Sprintf("NewValue: %v", v.NewValue)
	i++

	return fmt.Sprintf("CompareAndSwap{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this CompareAndSwap match the
// provided CompareAndSwap.
//
// This function performs a deep comparison.
func (v *CompareAndSwap) Equals(rhs *CompareAndSwap) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.Key == rhs.Key) {
		return false
	}
	if !(v.CurrentValue == rhs.CurrentValue) {
		return false
	}
	if !(v.NewValue == rhs.NewValue) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CompareAndSwap.
func (v *CompareAndSwap) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("key", v.Key)
	enc.AddInt64("currentValue", v.CurrentValue)
	enc.AddInt64("newValue", v.NewValue)
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *CompareAndSwap) GetKey() (o string) {
	if v != nil {
		o = v.Key
	}
	return
}

// GetCurrentValue returns the value of CurrentValue if it is set or its
// zero value if it is unset.
func (v *CompareAndSwap) GetCurrentValue() (o int64) {
	if v != nil {
		o = v.CurrentValue
	}
	return
}

// GetNewValue returns the value of NewValue if it is set or its
// zero value if it is unset.
func (v *CompareAndSwap) GetNewValue() (o int64) {
	if v != nil {
		o = v.NewValue
	}
	return
}

type IntegerMismatchError struct {
	ExpectedValue int64 `json:"expectedValue,required"`
	GotValue      int64 `json:"gotValue,required"`
}

// ToWire translates a IntegerMismatchError struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *IntegerMismatchError) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueI64(v.ExpectedValue), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	w, err = wire.NewValueI64(v.GotValue), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a IntegerMismatchError struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a IntegerMismatchError struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v IntegerMismatchError
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *IntegerMismatchError) FromWire(w wire.Value) error {
	var err error

	expectedValueIsSet := false
	gotValueIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				v.ExpectedValue, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				expectedValueIsSet = true
			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				v.GotValue, err = field.Value.GetI64(), error(nil)
				if err != nil {
					return err
				}
				gotValueIsSet = true
			}
		}
	}

	if !expectedValueIsSet {
		return errors.New("field ExpectedValue of IntegerMismatchError is required")
	}

	if !gotValueIsSet {
		return errors.New("field GotValue of IntegerMismatchError is required")
	}

	return nil
}

// Encode serializes a IntegerMismatchError struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a IntegerMismatchError struct could not be encoded.
func (v *IntegerMismatchError) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TI64}); err != nil {
		return err
	}
	if err := sw.WriteInt64(v.ExpectedValue); err != nil {
		return err
	}
	if err := sw.WriteFieldEnd(); err != nil {
		return err
	}

	if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TI64}); err != nil {
		return err
	}
	if err := sw.WriteInt64(v.GotValue); err != nil {
		return err
	}
	if err := sw.WriteFieldEnd(); err != nil {
		return err
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a IntegerMismatchError struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a IntegerMismatchError struct could not be generated from the wire
// representation.
func (v *IntegerMismatchError) Decode(sr stream.Reader) error {

	expectedValueIsSet := false
	gotValueIsSet := false

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TI64 {
				v.ExpectedValue, err = sr.ReadInt64()
				if err != nil {
					return err
				}
				expectedValueIsSet = true
			}
		case 2:
			if fh.Type == wire.TI64 {
				v.GotValue, err = sr.ReadInt64()
				if err != nil {
					return err
				}
				gotValueIsSet = true
			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	if !expectedValueIsSet {
		return errors.New("field ExpectedValue of IntegerMismatchError is required")
	}

	if !gotValueIsSet {
		return errors.New("field GotValue of IntegerMismatchError is required")
	}

	return nil
}

// String returns a readable string representation of a IntegerMismatchError
// struct.
func (v *IntegerMismatchError) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	fields[i] = fmt.Sprintf("ExpectedValue: %v", v.ExpectedValue)
	i++
	fields[i] = fmt.Sprintf("GotValue: %v", v.GotValue)
	i++

	return fmt.Sprintf("IntegerMismatchError{%v}", strings.Join(fields[:i], ", "))
}

// ErrorName is the name of this type as defined in the Thrift
// file.
func (*IntegerMismatchError) ErrorName() string {
	return "IntegerMismatchError"
}

// Equals returns true if all the fields of this IntegerMismatchError match the
// provided IntegerMismatchError.
//
// This function performs a deep comparison.
func (v *IntegerMismatchError) Equals(rhs *IntegerMismatchError) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.ExpectedValue == rhs.ExpectedValue) {
		return false
	}
	if !(v.GotValue == rhs.GotValue) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of IntegerMismatchError.
func (v *IntegerMismatchError) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddInt64("expectedValue", v.ExpectedValue)
	enc.AddInt64("gotValue", v.GotValue)
	return err
}

// GetExpectedValue returns the value of ExpectedValue if it is set or its
// zero value if it is unset.
func (v *IntegerMismatchError) GetExpectedValue() (o int64) {
	if v != nil {
		o = v.ExpectedValue
	}
	return
}

// GetGotValue returns the value of GotValue if it is set or its
// zero value if it is unset.
func (v *IntegerMismatchError) GetGotValue() (o int64) {
	if v != nil {
		o = v.GotValue
	}
	return
}

func (v *IntegerMismatchError) Error() string {
	return v.String()
}

type KeyDoesNotExist struct {
	Key *string `json:"key,omitempty"`
}

// ToWire translates a KeyDoesNotExist struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *KeyDoesNotExist) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = wire.NewValueString(*(v.Key)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a KeyDoesNotExist struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a KeyDoesNotExist struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v KeyDoesNotExist
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *KeyDoesNotExist) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Key = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a KeyDoesNotExist struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a KeyDoesNotExist struct could not be encoded.
func (v *KeyDoesNotExist) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Key != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Key)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a KeyDoesNotExist struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a KeyDoesNotExist struct could not be generated from the wire
// representation.
func (v *KeyDoesNotExist) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TBinary {
				var x string
				x, err = sr.ReadString()
				v.Key = &x
				if err != nil {
					return err
				}

			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a KeyDoesNotExist
// struct.
func (v *KeyDoesNotExist) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", *(v.Key))
		i++
	}

	return fmt.Sprintf("KeyDoesNotExist{%v}", strings.Join(fields[:i], ", "))
}

// ErrorName is the name of this type as defined in the Thrift
// file.
func (*KeyDoesNotExist) ErrorName() string {
	return "KeyDoesNotExist"
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this KeyDoesNotExist match the
// provided KeyDoesNotExist.
//
// This function performs a deep comparison.
func (v *KeyDoesNotExist) Equals(rhs *KeyDoesNotExist) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Key, rhs.Key) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of KeyDoesNotExist.
func (v *KeyDoesNotExist) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		enc.AddString("key", *v.Key)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *KeyDoesNotExist) GetKey() (o string) {
	if v != nil && v.Key != nil {
		return *v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *KeyDoesNotExist) IsSetKey() bool {
	return v != nil && v.Key != nil
}

func (v *KeyDoesNotExist) Error() string {
	return v.String()
}

type OptionalCompareAndSwap struct {
	Key          *string `json:"key,omitempty"`
	CurrentValue *int64  `json:"currentValue,omitempty"`
	NewValue     *int64  `json:"newValue,omitempty"`
}

// ToWire translates a OptionalCompareAndSwap struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *OptionalCompareAndSwap) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = wire.NewValueString(*(v.Key)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.CurrentValue != nil {
		w, err = wire.NewValueI64(*(v.CurrentValue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.NewValue != nil {
		w, err = wire.NewValueI64(*(v.NewValue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a OptionalCompareAndSwap struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a OptionalCompareAndSwap struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v OptionalCompareAndSwap
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *OptionalCompareAndSwap) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Key = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.CurrentValue = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.NewValue = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a OptionalCompareAndSwap struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a OptionalCompareAndSwap struct could not be encoded.
func (v *OptionalCompareAndSwap) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Key != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Key)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.CurrentValue != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.CurrentValue)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.NewValue != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 3, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.NewValue)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a OptionalCompareAndSwap struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a OptionalCompareAndSwap struct could not be generated from the wire
// representation.
func (v *OptionalCompareAndSwap) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TBinary {
				var x string
				x, err = sr.ReadString()
				v.Key = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if fh.Type == wire.TI64 {
				var x int64
				x, err = sr.ReadInt64()
				v.CurrentValue = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if fh.Type == wire.TI64 {
				var x int64
				x, err = sr.ReadInt64()
				v.NewValue = &x
				if err != nil {
					return err
				}

			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a OptionalCompareAndSwap
// struct.
func (v *OptionalCompareAndSwap) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", *(v.Key))
		i++
	}
	if v.CurrentValue != nil {
		fields[i] = fmt.Sprintf("CurrentValue: %v", *(v.CurrentValue))
		i++
	}
	if v.NewValue != nil {
		fields[i] = fmt.Sprintf("NewValue: %v", *(v.NewValue))
		i++
	}

	return fmt.Sprintf("OptionalCompareAndSwap{%v}", strings.Join(fields[:i], ", "))
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this OptionalCompareAndSwap match the
// provided OptionalCompareAndSwap.
//
// This function performs a deep comparison.
func (v *OptionalCompareAndSwap) Equals(rhs *OptionalCompareAndSwap) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Key, rhs.Key) {
		return false
	}
	if !_I64_EqualsPtr(v.CurrentValue, rhs.CurrentValue) {
		return false
	}
	if !_I64_EqualsPtr(v.NewValue, rhs.NewValue) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of OptionalCompareAndSwap.
func (v *OptionalCompareAndSwap) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		enc.AddString("key", *v.Key)
	}
	if v.CurrentValue != nil {
		enc.AddInt64("currentValue", *v.CurrentValue)
	}
	if v.NewValue != nil {
		enc.AddInt64("newValue", *v.NewValue)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *OptionalCompareAndSwap) GetKey() (o string) {
	if v != nil && v.Key != nil {
		return *v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *OptionalCompareAndSwap) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetCurrentValue returns the value of CurrentValue if it is set or its
// zero value if it is unset.
func (v *OptionalCompareAndSwap) GetCurrentValue() (o int64) {
	if v != nil && v.CurrentValue != nil {
		return *v.CurrentValue
	}

	return
}

// IsSetCurrentValue returns true if CurrentValue is not nil.
func (v *OptionalCompareAndSwap) IsSetCurrentValue() bool {
	return v != nil && v.CurrentValue != nil
}

// GetNewValue returns the value of NewValue if it is set or its
// zero value if it is unset.
func (v *OptionalCompareAndSwap) GetNewValue() (o int64) {
	if v != nil && v.NewValue != nil {
		return *v.NewValue
	}

	return
}

// IsSetNewValue returns true if NewValue is not nil.
func (v *OptionalCompareAndSwap) IsSetNewValue() bool {
	return v != nil && v.NewValue != nil
}

type OptionalCompareAndSwapWrapper struct {
	Cas *OptionalCompareAndSwap `json:"cas,omitempty"`
}

// ToWire translates a OptionalCompareAndSwapWrapper struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *OptionalCompareAndSwapWrapper) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Cas != nil {
		w, err = v.Cas.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _OptionalCompareAndSwap_Read(w wire.Value) (*OptionalCompareAndSwap, error) {
	var v OptionalCompareAndSwap
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a OptionalCompareAndSwapWrapper struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a OptionalCompareAndSwapWrapper struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v OptionalCompareAndSwapWrapper
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *OptionalCompareAndSwapWrapper) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Cas, err = _OptionalCompareAndSwap_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a OptionalCompareAndSwapWrapper struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a OptionalCompareAndSwapWrapper struct could not be encoded.
func (v *OptionalCompareAndSwapWrapper) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Cas != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Cas.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _OptionalCompareAndSwap_Decode(sr stream.Reader) (*OptionalCompareAndSwap, error) {
	var v OptionalCompareAndSwap
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a OptionalCompareAndSwapWrapper struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a OptionalCompareAndSwapWrapper struct could not be generated from the wire
// representation.
func (v *OptionalCompareAndSwapWrapper) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TStruct {
				v.Cas, err = _OptionalCompareAndSwap_Decode(sr)
				if err != nil {
					return err
				}

			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a OptionalCompareAndSwapWrapper
// struct.
func (v *OptionalCompareAndSwapWrapper) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Cas != nil {
		fields[i] = fmt.Sprintf("Cas: %v", v.Cas)
		i++
	}

	return fmt.Sprintf("OptionalCompareAndSwapWrapper{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this OptionalCompareAndSwapWrapper match the
// provided OptionalCompareAndSwapWrapper.
//
// This function performs a deep comparison.
func (v *OptionalCompareAndSwapWrapper) Equals(rhs *OptionalCompareAndSwapWrapper) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Cas == nil && rhs.Cas == nil) || (v.Cas != nil && rhs.Cas != nil && v.Cas.Equals(rhs.Cas))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of OptionalCompareAndSwapWrapper.
func (v *OptionalCompareAndSwapWrapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Cas != nil {
		err = multierr.Append(err, enc.AddObject("cas", v.Cas))
	}
	return err
}

// GetCas returns the value of Cas if it is set or its
// zero value if it is unset.
func (v *OptionalCompareAndSwapWrapper) GetCas() (o *OptionalCompareAndSwap) {
	if v != nil && v.Cas != nil {
		return v.Cas
	}

	return
}

// IsSetCas returns true if Cas is not nil.
func (v *OptionalCompareAndSwapWrapper) IsSetCas() bool {
	return v != nil && v.Cas != nil
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "atomic",
	Package:  "go.uber.org/yarpc/encoding/thrift/thriftrw-plugin-yarpc/internal/tests/atomic",
	FilePath: "atomic.thrift",
	SHA1:     "86799ad54683404a517c661f6f10d83cf7afa99e",
	Includes: []*thriftreflect.ThriftModule{
		common.ThriftModule,
	},
	Raw: rawIDL,
}

const rawIDL = "include \"./common.thrift\"\n\nexception KeyDoesNotExist {\n    1: optional string key\n} (\n    rpc.code = \"INVALID_ARGUMENT\"\n)\n\nexception IntegerMismatchError {\n    1: required i64 expectedValue\n    2: required i64 gotValue\n} (\n    rpc.code = \"INVALID_ARGUMENT\"\n)\n\nstruct CompareAndSwap {\n    1: required string key\n    2: required i64 currentValue\n    3: required i64 newValue\n}\n\nservice ReadOnlyStore extends common.BaseService {\n    i64 integer(1: string key) throws (1: KeyDoesNotExist doesNotExist)\n}\n\nservice Store extends ReadOnlyStore {\n    void increment(1: string key, 2: i64 value)\n\n    void compareAndSwap(1: CompareAndSwap request)\n        throws (1: IntegerMismatchError mismatch)\n\n    oneway void forget(1: string key)\n}\n\n\n// This struct intentionally has the same shape as the `CompareAndSwap` wrapper\n// `Store_CompareAndSwap_Args`, except all fields are optional.\n\n// We use this to generate an invalid payload for testing.\nstruct OptionalCompareAndSwapWrapper {\n    1: optional OptionalCompareAndSwap cas\n}\n\nstruct OptionalCompareAndSwap {\n    1: optional string key\n    2: optional i64 currentValue\n    3: optional i64 newValue\n}\n"

// ReadOnlyStore_Integer_Args represents the arguments for the ReadOnlyStore.integer function.
//
// The arguments for integer are sent and received over the wire as this struct.
type ReadOnlyStore_Integer_Args struct {
	Key *string `json:"key,omitempty"`
}

// ToWire translates a ReadOnlyStore_Integer_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ReadOnlyStore_Integer_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = wire.NewValueString(*(v.Key)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ReadOnlyStore_Integer_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ReadOnlyStore_Integer_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ReadOnlyStore_Integer_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ReadOnlyStore_Integer_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Key = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a ReadOnlyStore_Integer_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ReadOnlyStore_Integer_Args struct could not be encoded.
func (v *ReadOnlyStore_Integer_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Key != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Key)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a ReadOnlyStore_Integer_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ReadOnlyStore_Integer_Args struct could not be generated from the wire
// representation.
func (v *ReadOnlyStore_Integer_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TBinary {
				var x string
				x, err = sr.ReadString()
				v.Key = &x
				if err != nil {
					return err
				}

			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a ReadOnlyStore_Integer_Args
// struct.
func (v *ReadOnlyStore_Integer_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", *(v.Key))
		i++
	}

	return fmt.Sprintf("ReadOnlyStore_Integer_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ReadOnlyStore_Integer_Args match the
// provided ReadOnlyStore_Integer_Args.
//
// This function performs a deep comparison.
func (v *ReadOnlyStore_Integer_Args) Equals(rhs *ReadOnlyStore_Integer_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Key, rhs.Key) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ReadOnlyStore_Integer_Args.
func (v *ReadOnlyStore_Integer_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		enc.AddString("key", *v.Key)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *ReadOnlyStore_Integer_Args) GetKey() (o string) {
	if v != nil && v.Key != nil {
		return *v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *ReadOnlyStore_Integer_Args) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "integer" for this struct.
func (v *ReadOnlyStore_Integer_Args) MethodName() string {
	return "integer"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ReadOnlyStore_Integer_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ReadOnlyStore_Integer_Helper provides functions that aid in handling the
// parameters and return values of the ReadOnlyStore.integer
// function.
var ReadOnlyStore_Integer_Helper = struct {
	// Args accepts the parameters of integer in-order and returns
	// the arguments struct for the function.
	Args func(
		key *string,
	) *ReadOnlyStore_Integer_Args

	// IsException returns true if the given error can be thrown
	// by integer.
	//
	// An error can be thrown by integer only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for integer
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// integer into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by integer
	//
	//   value, err := integer(args)
	//   result, err := ReadOnlyStore_Integer_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from integer: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(int64, error) (*ReadOnlyStore_Integer_Result, error)

	// UnwrapResponse takes the result struct for integer
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if integer threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ReadOnlyStore_Integer_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ReadOnlyStore_Integer_Result) (int64, error)
}{}

func init() {
	ReadOnlyStore_Integer_Helper.Args = func(
		key *string,
	) *ReadOnlyStore_Integer_Args {
		return &ReadOnlyStore_Integer_Args{
			Key: key,
		}
	}

	ReadOnlyStore_Integer_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *KeyDoesNotExist:
			return true
		default:
			return false
		}
	}

	ReadOnlyStore_Integer_Helper.WrapResponse = func(success int64, err error) (*ReadOnlyStore_Integer_Result, error) {
		if err == nil {
			return &ReadOnlyStore_Integer_Result{Success: &success}, nil
		}

		switch e := err.(type) {
		case *KeyDoesNotExist:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for ReadOnlyStore_Integer_Result.DoesNotExist")
			}
			return &ReadOnlyStore_Integer_Result{DoesNotExist: e}, nil
		}

		return nil, err
	}
	ReadOnlyStore_Integer_Helper.UnwrapResponse = func(result *ReadOnlyStore_Integer_Result) (success int64, err error) {
		if result.DoesNotExist != nil {
			err = result.DoesNotExist
			return
		}

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ReadOnlyStore_Integer_Result represents the result of a ReadOnlyStore.integer function call.
//
// The result of a integer execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ReadOnlyStore_Integer_Result struct {
	// Value returned by integer after a successful execution.
	Success      *int64           `json:"success,omitempty"`
	DoesNotExist *KeyDoesNotExist `json:"doesNotExist,omitempty"`
}

// ToWire translates a ReadOnlyStore_Integer_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ReadOnlyStore_Integer_Result) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueI64(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.DoesNotExist != nil {
		w, err = v.DoesNotExist.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ReadOnlyStore_Integer_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _KeyDoesNotExist_Read(w wire.Value) (*KeyDoesNotExist, error) {
	var v KeyDoesNotExist
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a ReadOnlyStore_Integer_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ReadOnlyStore_Integer_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ReadOnlyStore_Integer_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ReadOnlyStore_Integer_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.DoesNotExist, err = _KeyDoesNotExist_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.DoesNotExist != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ReadOnlyStore_Integer_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a ReadOnlyStore_Integer_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a ReadOnlyStore_Integer_Result struct could not be encoded.
func (v *ReadOnlyStore_Integer_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Success != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 0, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Success)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.DoesNotExist != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.DoesNotExist.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.DoesNotExist != nil {
		count++
	}

	if count != 1 {
		return fmt.Errorf("ReadOnlyStore_Integer_Result should have exactly one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _KeyDoesNotExist_Decode(sr stream.Reader) (*KeyDoesNotExist, error) {
	var v KeyDoesNotExist
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a ReadOnlyStore_Integer_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a ReadOnlyStore_Integer_Result struct could not be generated from the wire
// representation.
func (v *ReadOnlyStore_Integer_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 0:
			if fh.Type == wire.TI64 {
				var x int64
				x, err = sr.ReadInt64()
				v.Success = &x
				if err != nil {
					return err
				}

			}
		case 1:
			if fh.Type == wire.TStruct {
				v.DoesNotExist, err = _KeyDoesNotExist_Decode(sr)
				if err != nil {
					return err
				}

			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.DoesNotExist != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ReadOnlyStore_Integer_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ReadOnlyStore_Integer_Result
// struct.
func (v *ReadOnlyStore_Integer_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}
	if v.DoesNotExist != nil {
		fields[i] = fmt.Sprintf("DoesNotExist: %v", v.DoesNotExist)
		i++
	}

	return fmt.Sprintf("ReadOnlyStore_Integer_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ReadOnlyStore_Integer_Result match the
// provided ReadOnlyStore_Integer_Result.
//
// This function performs a deep comparison.
func (v *ReadOnlyStore_Integer_Result) Equals(rhs *ReadOnlyStore_Integer_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Success, rhs.Success) {
		return false
	}
	if !((v.DoesNotExist == nil && rhs.DoesNotExist == nil) || (v.DoesNotExist != nil && rhs.DoesNotExist != nil && v.DoesNotExist.Equals(rhs.DoesNotExist))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ReadOnlyStore_Integer_Result.
func (v *ReadOnlyStore_Integer_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddInt64("success", *v.Success)
	}
	if v.DoesNotExist != nil {
		err = multierr.Append(err, enc.AddObject("doesNotExist", v.DoesNotExist))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ReadOnlyStore_Integer_Result) GetSuccess() (o int64) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ReadOnlyStore_Integer_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetDoesNotExist returns the value of DoesNotExist if it is set or its
// zero value if it is unset.
func (v *ReadOnlyStore_Integer_Result) GetDoesNotExist() (o *KeyDoesNotExist) {
	if v != nil && v.DoesNotExist != nil {
		return v.DoesNotExist
	}

	return
}

// IsSetDoesNotExist returns true if DoesNotExist is not nil.
func (v *ReadOnlyStore_Integer_Result) IsSetDoesNotExist() bool {
	return v != nil && v.DoesNotExist != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "integer" for this struct.
func (v *ReadOnlyStore_Integer_Result) MethodName() string {
	return "integer"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ReadOnlyStore_Integer_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Store_CompareAndSwap_Args represents the arguments for the Store.compareAndSwap function.
//
// The arguments for compareAndSwap are sent and received over the wire as this struct.
type Store_CompareAndSwap_Args struct {
	Request *CompareAndSwap `json:"request,omitempty"`
}

// ToWire translates a Store_CompareAndSwap_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Store_CompareAndSwap_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Request != nil {
		w, err = v.Request.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _CompareAndSwap_Read(w wire.Value) (*CompareAndSwap, error) {
	var v CompareAndSwap
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Store_CompareAndSwap_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Store_CompareAndSwap_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Store_CompareAndSwap_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Store_CompareAndSwap_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Request, err = _CompareAndSwap_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Store_CompareAndSwap_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Store_CompareAndSwap_Args struct could not be encoded.
func (v *Store_CompareAndSwap_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Request != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Request.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

func _CompareAndSwap_Decode(sr stream.Reader) (*CompareAndSwap, error) {
	var v CompareAndSwap
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Store_CompareAndSwap_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Store_CompareAndSwap_Args struct could not be generated from the wire
// representation.
func (v *Store_CompareAndSwap_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TStruct {
				v.Request, err = _CompareAndSwap_Decode(sr)
				if err != nil {
					return err
				}

			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Store_CompareAndSwap_Args
// struct.
func (v *Store_CompareAndSwap_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Request != nil {
		fields[i] = fmt.Sprintf("Request: %v", v.Request)
		i++
	}

	return fmt.Sprintf("Store_CompareAndSwap_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Store_CompareAndSwap_Args match the
// provided Store_CompareAndSwap_Args.
//
// This function performs a deep comparison.
func (v *Store_CompareAndSwap_Args) Equals(rhs *Store_CompareAndSwap_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Request == nil && rhs.Request == nil) || (v.Request != nil && rhs.Request != nil && v.Request.Equals(rhs.Request))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Store_CompareAndSwap_Args.
func (v *Store_CompareAndSwap_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Request != nil {
		err = multierr.Append(err, enc.AddObject("request", v.Request))
	}
	return err
}

// GetRequest returns the value of Request if it is set or its
// zero value if it is unset.
func (v *Store_CompareAndSwap_Args) GetRequest() (o *CompareAndSwap) {
	if v != nil && v.Request != nil {
		return v.Request
	}

	return
}

// IsSetRequest returns true if Request is not nil.
func (v *Store_CompareAndSwap_Args) IsSetRequest() bool {
	return v != nil && v.Request != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "compareAndSwap" for this struct.
func (v *Store_CompareAndSwap_Args) MethodName() string {
	return "compareAndSwap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Store_CompareAndSwap_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Store_CompareAndSwap_Helper provides functions that aid in handling the
// parameters and return values of the Store.compareAndSwap
// function.
var Store_CompareAndSwap_Helper = struct {
	// Args accepts the parameters of compareAndSwap in-order and returns
	// the arguments struct for the function.
	Args func(
		request *CompareAndSwap,
	) *Store_CompareAndSwap_Args

	// IsException returns true if the given error can be thrown
	// by compareAndSwap.
	//
	// An error can be thrown by compareAndSwap only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for compareAndSwap
	// given the error returned by it. The provided error may
	// be nil if compareAndSwap did not fail.
	//
	// This allows mapping errors returned by compareAndSwap into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// compareAndSwap
	//
	//   err := compareAndSwap(args)
	//   result, err := Store_CompareAndSwap_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from compareAndSwap: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Store_CompareAndSwap_Result, error)

	// UnwrapResponse takes the result struct for compareAndSwap
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if compareAndSwap threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Store_CompareAndSwap_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Store_CompareAndSwap_Result) error
}{}

func init() {
	Store_CompareAndSwap_Helper.Args = func(
		request *CompareAndSwap,
	) *Store_CompareAndSwap_Args {
		return &Store_CompareAndSwap_Args{
			Request: request,
		}
	}

	Store_CompareAndSwap_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *IntegerMismatchError:
			return true
		default:
			return false
		}
	}

	Store_CompareAndSwap_Helper.WrapResponse = func(err error) (*Store_CompareAndSwap_Result, error) {
		if err == nil {
			return &Store_CompareAndSwap_Result{}, nil
		}

		switch e := err.(type) {
		case *IntegerMismatchError:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for Store_CompareAndSwap_Result.Mismatch")
			}
			return &Store_CompareAndSwap_Result{Mismatch: e}, nil
		}

		return nil, err
	}
	Store_CompareAndSwap_Helper.UnwrapResponse = func(result *Store_CompareAndSwap_Result) (err error) {
		if result.Mismatch != nil {
			err = result.Mismatch
			return
		}
		return
	}

}

// Store_CompareAndSwap_Result represents the result of a Store.compareAndSwap function call.
//
// The result of a compareAndSwap execution is sent and received over the wire as this struct.
type Store_CompareAndSwap_Result struct {
	Mismatch *IntegerMismatchError `json:"mismatch,omitempty"`
}

// ToWire translates a Store_CompareAndSwap_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Store_CompareAndSwap_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Mismatch != nil {
		w, err = v.Mismatch.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("Store_CompareAndSwap_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _IntegerMismatchError_Read(w wire.Value) (*IntegerMismatchError, error) {
	var v IntegerMismatchError
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a Store_CompareAndSwap_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Store_CompareAndSwap_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Store_CompareAndSwap_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Store_CompareAndSwap_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Mismatch, err = _IntegerMismatchError_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Mismatch != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Store_CompareAndSwap_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// Encode serializes a Store_CompareAndSwap_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Store_CompareAndSwap_Result struct could not be encoded.
func (v *Store_CompareAndSwap_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Mismatch != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TStruct}); err != nil {
			return err
		}
		if err := v.Mismatch.Encode(sw); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	count := 0
	if v.Mismatch != nil {
		count++
	}

	if count > 1 {
		return fmt.Errorf("Store_CompareAndSwap_Result should have at most one field: got %v fields", count)
	}

	return sw.WriteStructEnd()
}

func _IntegerMismatchError_Decode(sr stream.Reader) (*IntegerMismatchError, error) {
	var v IntegerMismatchError
	err := v.Decode(sr)
	return &v, err
}

// Decode deserializes a Store_CompareAndSwap_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Store_CompareAndSwap_Result struct could not be generated from the wire
// representation.
func (v *Store_CompareAndSwap_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TStruct {
				v.Mismatch, err = _IntegerMismatchError_Decode(sr)
				if err != nil {
					return err
				}

			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	count := 0
	if v.Mismatch != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("Store_CompareAndSwap_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a Store_CompareAndSwap_Result
// struct.
func (v *Store_CompareAndSwap_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Mismatch != nil {
		fields[i] = fmt.Sprintf("Mismatch: %v", v.Mismatch)
		i++
	}

	return fmt.Sprintf("Store_CompareAndSwap_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Store_CompareAndSwap_Result match the
// provided Store_CompareAndSwap_Result.
//
// This function performs a deep comparison.
func (v *Store_CompareAndSwap_Result) Equals(rhs *Store_CompareAndSwap_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Mismatch == nil && rhs.Mismatch == nil) || (v.Mismatch != nil && rhs.Mismatch != nil && v.Mismatch.Equals(rhs.Mismatch))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Store_CompareAndSwap_Result.
func (v *Store_CompareAndSwap_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Mismatch != nil {
		err = multierr.Append(err, enc.AddObject("mismatch", v.Mismatch))
	}
	return err
}

// GetMismatch returns the value of Mismatch if it is set or its
// zero value if it is unset.
func (v *Store_CompareAndSwap_Result) GetMismatch() (o *IntegerMismatchError) {
	if v != nil && v.Mismatch != nil {
		return v.Mismatch
	}

	return
}

// IsSetMismatch returns true if Mismatch is not nil.
func (v *Store_CompareAndSwap_Result) IsSetMismatch() bool {
	return v != nil && v.Mismatch != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "compareAndSwap" for this struct.
func (v *Store_CompareAndSwap_Result) MethodName() string {
	return "compareAndSwap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Store_CompareAndSwap_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// Store_Forget_Args represents the arguments for the Store.forget function.
//
// The arguments for forget are sent and received over the wire as this struct.
type Store_Forget_Args struct {
	Key *string `json:"key,omitempty"`
}

// ToWire translates a Store_Forget_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Store_Forget_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = wire.NewValueString(*(v.Key)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Store_Forget_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Store_Forget_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Store_Forget_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Store_Forget_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Key = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Store_Forget_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Store_Forget_Args struct could not be encoded.
func (v *Store_Forget_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Key != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Key)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Store_Forget_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Store_Forget_Args struct could not be generated from the wire
// representation.
func (v *Store_Forget_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TBinary {
				var x string
				x, err = sr.ReadString()
				v.Key = &x
				if err != nil {
					return err
				}

			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Store_Forget_Args
// struct.
func (v *Store_Forget_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", *(v.Key))
		i++
	}

	return fmt.Sprintf("Store_Forget_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Store_Forget_Args match the
// provided Store_Forget_Args.
//
// This function performs a deep comparison.
func (v *Store_Forget_Args) Equals(rhs *Store_Forget_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Key, rhs.Key) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Store_Forget_Args.
func (v *Store_Forget_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		enc.AddString("key", *v.Key)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *Store_Forget_Args) GetKey() (o string) {
	if v != nil && v.Key != nil {
		return *v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *Store_Forget_Args) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "forget" for this struct.
func (v *Store_Forget_Args) MethodName() string {
	return "forget"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be OneWay for this struct.
func (v *Store_Forget_Args) EnvelopeType() wire.EnvelopeType {
	return wire.OneWay
}

// Store_Forget_Helper provides functions that aid in handling the
// parameters and return values of the Store.forget
// function.
var Store_Forget_Helper = struct {
	// Args accepts the parameters of forget in-order and returns
	// the arguments struct for the function.
	Args func(
		key *string,
	) *Store_Forget_Args
}{}

func init() {
	Store_Forget_Helper.Args = func(
		key *string,
	) *Store_Forget_Args {
		return &Store_Forget_Args{
			Key: key,
		}
	}

}

// Store_Increment_Args represents the arguments for the Store.increment function.
//
// The arguments for increment are sent and received over the wire as this struct.
type Store_Increment_Args struct {
	Key   *string `json:"key,omitempty"`
	Value *int64  `json:"value,omitempty"`
}

// ToWire translates a Store_Increment_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Store_Increment_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Key != nil {
		w, err = wire.NewValueString(*(v.Key)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Value != nil {
		w, err = wire.NewValueI64(*(v.Value)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Store_Increment_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Store_Increment_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Store_Increment_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Store_Increment_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Key = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Value = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// Encode serializes a Store_Increment_Args struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Store_Increment_Args struct could not be encoded.
func (v *Store_Increment_Args) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	if v.Key != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 1, Type: wire.TBinary}); err != nil {
			return err
		}
		if err := sw.WriteString(*(v.Key)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	if v.Value != nil {
		if err := sw.WriteFieldBegin(stream.FieldHeader{ID: 2, Type: wire.TI64}); err != nil {
			return err
		}
		if err := sw.WriteInt64(*(v.Value)); err != nil {
			return err
		}
		if err := sw.WriteFieldEnd(); err != nil {
			return err
		}
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Store_Increment_Args struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Store_Increment_Args struct could not be generated from the wire
// representation.
func (v *Store_Increment_Args) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		case 1:
			if fh.Type == wire.TBinary {
				var x string
				x, err = sr.ReadString()
				v.Key = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if fh.Type == wire.TI64 {
				var x int64
				x, err = sr.ReadInt64()
				v.Value = &x
				if err != nil {
					return err
				}

			}
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Store_Increment_Args
// struct.
func (v *Store_Increment_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Key != nil {
		fields[i] = fmt.Sprintf("Key: %v", *(v.Key))
		i++
	}
	if v.Value != nil {
		fields[i] = fmt.Sprintf("Value: %v", *(v.Value))
		i++
	}

	return fmt.Sprintf("Store_Increment_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Store_Increment_Args match the
// provided Store_Increment_Args.
//
// This function performs a deep comparison.
func (v *Store_Increment_Args) Equals(rhs *Store_Increment_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Key, rhs.Key) {
		return false
	}
	if !_I64_EqualsPtr(v.Value, rhs.Value) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Store_Increment_Args.
func (v *Store_Increment_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Key != nil {
		enc.AddString("key", *v.Key)
	}
	if v.Value != nil {
		enc.AddInt64("value", *v.Value)
	}
	return err
}

// GetKey returns the value of Key if it is set or its
// zero value if it is unset.
func (v *Store_Increment_Args) GetKey() (o string) {
	if v != nil && v.Key != nil {
		return *v.Key
	}

	return
}

// IsSetKey returns true if Key is not nil.
func (v *Store_Increment_Args) IsSetKey() bool {
	return v != nil && v.Key != nil
}

// GetValue returns the value of Value if it is set or its
// zero value if it is unset.
func (v *Store_Increment_Args) GetValue() (o int64) {
	if v != nil && v.Value != nil {
		return *v.Value
	}

	return
}

// IsSetValue returns true if Value is not nil.
func (v *Store_Increment_Args) IsSetValue() bool {
	return v != nil && v.Value != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "increment" for this struct.
func (v *Store_Increment_Args) MethodName() string {
	return "increment"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *Store_Increment_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// Store_Increment_Helper provides functions that aid in handling the
// parameters and return values of the Store.increment
// function.
var Store_Increment_Helper = struct {
	// Args accepts the parameters of increment in-order and returns
	// the arguments struct for the function.
	Args func(
		key *string,
		value *int64,
	) *Store_Increment_Args

	// IsException returns true if the given error can be thrown
	// by increment.
	//
	// An error can be thrown by increment only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for increment
	// given the error returned by it. The provided error may
	// be nil if increment did not fail.
	//
	// This allows mapping errors returned by increment into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// increment
	//
	//   err := increment(args)
	//   result, err := Store_Increment_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from increment: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*Store_Increment_Result, error)

	// UnwrapResponse takes the result struct for increment
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if increment threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := Store_Increment_Helper.UnwrapResponse(result)
	UnwrapResponse func(*Store_Increment_Result) error
}{}

func init() {
	Store_Increment_Helper.Args = func(
		key *string,
		value *int64,
	) *Store_Increment_Args {
		return &Store_Increment_Args{
			Key:   key,
			Value: value,
		}
	}

	Store_Increment_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	Store_Increment_Helper.WrapResponse = func(err error) (*Store_Increment_Result, error) {
		if err == nil {
			return &Store_Increment_Result{}, nil
		}

		return nil, err
	}
	Store_Increment_Helper.UnwrapResponse = func(result *Store_Increment_Result) (err error) {
		return
	}

}

// Store_Increment_Result represents the result of a Store.increment function call.
//
// The result of a increment execution is sent and received over the wire as this struct.
type Store_Increment_Result struct {
}

// ToWire translates a Store_Increment_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Store_Increment_Result) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Store_Increment_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Store_Increment_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Store_Increment_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Store_Increment_Result) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// Encode serializes a Store_Increment_Result struct directly into bytes, without going
// through an intermediary type.
//
// An error is returned if a Store_Increment_Result struct could not be encoded.
func (v *Store_Increment_Result) Encode(sw stream.Writer) error {
	if err := sw.WriteStructBegin(); err != nil {
		return err
	}

	return sw.WriteStructEnd()
}

// Decode deserializes a Store_Increment_Result struct directly from its Thrift-level
// representation, without going through an intemediary type.
//
// An error is returned if a Store_Increment_Result struct could not be generated from the wire
// representation.
func (v *Store_Increment_Result) Decode(sr stream.Reader) error {

	if err := sr.ReadStructBegin(); err != nil {
		return err
	}

	fh, ok, err := sr.ReadFieldBegin()
	if err != nil {
		return err
	}

	for ok {
		switch fh.ID {
		}

		if err := sr.ReadFieldEnd(); err != nil {
			return err
		}

		if fh, ok, err = sr.ReadFieldBegin(); err != nil {
			return err
		}
	}

	if err := sr.ReadStructEnd(); err != nil {
		return err
	}

	return nil
}

// String returns a readable string representation of a Store_Increment_Result
// struct.
func (v *Store_Increment_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("Store_Increment_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Store_Increment_Result match the
// provided Store_Increment_Result.
//
// This function performs a deep comparison.
func (v *Store_Increment_Result) Equals(rhs *Store_Increment_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Store_Increment_Result.
func (v *Store_Increment_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "increment" for this struct.
func (v *Store_Increment_Result) MethodName() string {
	return "increment"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *Store_Increment_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}
