// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package thrift

import (
	"context"

	"go.uber.org/yarpc/api/transport"

	"go.uber.org/thriftrw/protocol"
	"go.uber.org/thriftrw/wire"
)

// Register calls the RouteTable's Register method.
//
// This function exists for backwards compatibility only. It will be removed
// in a future version.
//
// Deprecated: Use the RouteTable's Register method directly.
func Register(r transport.RouteTable, rs []transport.Procedure) {
	r.Register(rs)
}

// UnaryHandler represents a Thrift request handler. It speaks in raw Thrift payloads.
//
// Users should use the server package generated by the code generator rather
// than using this directly.
type UnaryHandler interface {
	Handle(ctx context.Context, body wire.Value) (Response, error)
}

// OnewayHandler represents a Thrift request handler. It speaks in raw Thrift payloads.
//
// Users should use the server package generated by the code generator rather
// than using this directly.
type OnewayHandler interface {
	HandleOneway(ctx context.Context, body wire.Value) error
}

// UnaryHandlerFunc is a convenience type alias for functions that act as Handlers.
type UnaryHandlerFunc func(context.Context, wire.Value) (Response, error)

// OnewayHandlerFunc is a convenience type alias for functions that act as OnewayHandlers.
type OnewayHandlerFunc func(context.Context, wire.Value) error

// Handle forwards the request to the underlying function.
func (f UnaryHandlerFunc) Handle(ctx context.Context, body wire.Value) (Response, error) {
	return f(ctx, body)
}

// HandleOneway forwards the request to the underlying function.
func (f OnewayHandlerFunc) HandleOneway(ctx context.Context, body wire.Value) error {
	return f(ctx, body)
}

// Service is a generic Thrift service implementation.
type Service struct {
	// Name of the Thrift service. This is the name specified for the service
	// in the IDL.
	Name          string
	Methods       map[string]UnaryHandler
	OnewayMethods map[string]OnewayHandler
}

// BuildProcedures builds a list of Procedures from a Thrift service
// specification.
func BuildProcedures(s Service, opts ...RegisterOption) []transport.Procedure {
	var rc registerConfig
	for _, opt := range opts {
		opt.applyRegisterOption(&rc)
	}

	proto := protocol.Binary
	if rc.Protocol != nil {
		proto = rc.Protocol
	}

	rs := make([]transport.Procedure, 0, len(s.Methods))

	// unary procedures
	for methodName, handler := range s.Methods {
		spec := transport.NewUnaryHandlerSpec(thriftUnaryHandler{
			UnaryHandler: handler,
			Protocol:     proto,
			Enveloping:   rc.Enveloping,
		})

		rs = append(rs, transport.Procedure{
			Name:        procedureName(s.Name, methodName),
			HandlerSpec: spec,
		})
	}

	// oneway procedures
	for methodName, handler := range s.OnewayMethods {
		spec := transport.NewOnewayHandlerSpec(thriftOnewayHandler{
			OnewayHandler: handler,
			Protocol:      proto,
			Enveloping:    rc.Enveloping,
		})

		rs = append(rs, transport.Procedure{
			Name:        procedureName(s.Name, methodName),
			HandlerSpec: spec,
		})
	}

	return rs
}
