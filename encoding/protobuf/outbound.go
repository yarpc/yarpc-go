// Copyright (c) 2016 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package protobuf

import (
	"bytes"
	"context"
	"errors"
	"io/ioutil"
	"reflect"

	"github.com/golang/protobuf/proto"

	"go.uber.org/yarpc"
	"go.uber.org/yarpc/api/transport"
	"go.uber.org/yarpc/encoding/protobuf/internal"
	"go.uber.org/yarpc/internal/encoding"
	"go.uber.org/yarpc/internal/meta"
)

// Client is a generic protobuf client.
//
// Users should use the client generated by the code generator rather than using this directly.
type Client interface {
	Call(
		ctx context.Context,
		reqMeta yarpc.CallReqMeta,
		reqMethodName string,
		reqMessage proto.Message,
		newResponse func() proto.Message,
	) (proto.Message, yarpc.CallResMeta, error)
}

// NewClient creates a new client.
func NewClient(serviceName string, transportClientConfig transport.ClientConfig, opts ...ClientOption) Client {
	clientConfig := &clientConfig{}
	for _, opt := range opts {
		opt.applyClientOption(clientConfig)
	}
	return &client{serviceName, transportClientConfig}
}

type client struct {
	serviceName  string
	clientConfig transport.ClientConfig
}

func (c *client) Call(
	ctx context.Context,
	reqMeta yarpc.CallReqMeta,
	reqMethodName string,
	reqMessage proto.Message,
	newResponse func() proto.Message,
) (proto.Message, yarpc.CallResMeta, error) {
	transportRequest := &transport.Request{
		Caller:   c.clientConfig.Caller(),
		Service:  c.clientConfig.Service(),
		Encoding: Encoding,
	}
	meta.ToTransportRequest(reqMeta, transportRequest)
	// thrift was doing this, should understand why
	transportRequest.Procedure = toProcedureName(c.serviceName, reqMethodName)
	if reqMessage != nil {
		reqData, err := protoMarshal(reqMessage)
		if err != nil {
			return nil, nil, encoding.RequestBodyEncodeError(transportRequest, err)
		}
		if reqData != nil {
			transportRequest.Body = bytes.NewReader(reqData)
		}
	}
	transportResponse, err := c.clientConfig.GetUnaryOutbound().Call(ctx, transportRequest)
	if err != nil {
		return nil, nil, err
	}
	// thrift is not checking the error, should be consistent
	defer transportResponse.Body.Close()
	// not sure if this is ever nil, need to check
	resData, err := ioutil.ReadAll(transportResponse.Body)
	if err != nil {
		return nil, nil, err
	}
	if resData == nil {
		return nil, nil, nil
	}
	internalResponse := &internal.Response{}
	if err := proto.Unmarshal(resData, internalResponse); err != nil {
		return nil, nil, encoding.ResponseBodyDecodeError(transportRequest, err)
	}
	var response proto.Message
	if internalResponse.Payload != nil {
		response = newResponse()
		if err := proto.Unmarshal(internalResponse.Payload, response); err != nil {
			return nil, nil, encoding.ResponseBodyDecodeError(transportRequest, err)
		}
	}
	if internalResponse.ApplicationError != nil {
		if internalResponse.ApplicationError.MessageName == "" {
			return response, nil, errors.New(string(internalResponse.ApplicationError.Payload))
		}
		// TODO: this is a complete mess, this will panic like crazy if things arent imported properly
		message := reflect.New(proto.MessageType(internalResponse.ApplicationError.MessageName).Elem()).Interface().(proto.Message)
		if err := proto.Unmarshal(internalResponse.ApplicationError.Payload, message); err != nil {
			return response, nil, encoding.ResponseBodyDecodeError(transportRequest, err)
		}
		return response, nil, NewApplicationError(message)
	}
	return response, nil, nil
}
