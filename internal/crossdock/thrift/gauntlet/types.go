// Code generated by thriftrw v1.14.0. DO NOT EDIT.
// @generated

// Copyright (c) 2018 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package gauntlet

import (
	"bytes"
	"encoding/base64"
	"encoding/json"
	"errors"
	"fmt"
	"go.uber.org/multierr"
	"go.uber.org/thriftrw/ptr"
	"go.uber.org/thriftrw/wire"
	"go.uber.org/zap/zapcore"
	"math"
	"strconv"
	"strings"
)

type Bonk struct {
	Message *string `json:"message,omitempty"`
	Type    *int32  `json:"type,omitempty"`
}

// ToWire translates a Bonk struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bonk) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = wire.NewValueI32(*(v.Type)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bonk struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bonk struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bonk
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bonk) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Type = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Bonk
// struct.
func (v *Bonk) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", *(v.Type))
		i++
	}

	return fmt.Sprintf("Bonk{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Bonk match the
// provided Bonk.
//
// This function performs a deep comparison.
func (v *Bonk) Equals(rhs *Bonk) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_I32_EqualsPtr(v.Type, rhs.Type) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bonk.
func (v *Bonk) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	if v.Type != nil {
		enc.AddInt32("type", *v.Type)
	}
	return err
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *Bonk) GetMessage() (o string) {
	if v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *Bonk) IsSetMessage() bool {
	return v.Message != nil
}

// GetType returns the value of Type if it is set or its
// zero value if it is unset.
func (v *Bonk) GetType() (o int32) {
	if v.Type != nil {
		return *v.Type
	}

	return
}

// IsSetType returns true if Type is not nil.
func (v *Bonk) IsSetType() bool {
	return v.Type != nil
}

type BoolTest struct {
	B *bool   `json:"b,omitempty"`
	S *string `json:"s,omitempty"`
}

// ToWire translates a BoolTest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BoolTest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.B == nil {
		v.B = ptr.Bool(true)
	}
	{
		w, err = wire.NewValueBool(*(v.B)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.S == nil {
		v.S = ptr.String("true")
	}
	{
		w, err = wire.NewValueString(*(v.S)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a BoolTest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BoolTest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BoolTest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BoolTest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.B = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.S = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if v.B == nil {
		v.B = ptr.Bool(true)
	}

	if v.S == nil {
		v.S = ptr.String("true")
	}

	return nil
}

// String returns a readable string representation of a BoolTest
// struct.
func (v *BoolTest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.B != nil {
		fields[i] = fmt.Sprintf("B: %v", *(v.B))
		i++
	}
	if v.S != nil {
		fields[i] = fmt.Sprintf("S: %v", *(v.S))
		i++
	}

	return fmt.Sprintf("BoolTest{%v}", strings.Join(fields[:i], ", "))
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this BoolTest match the
// provided BoolTest.
//
// This function performs a deep comparison.
func (v *BoolTest) Equals(rhs *BoolTest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.B, rhs.B) {
		return false
	}
	if !_String_EqualsPtr(v.S, rhs.S) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BoolTest.
func (v *BoolTest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.B != nil {
		enc.AddBool("b", *v.B)
	}
	if v.S != nil {
		enc.AddString("s", *v.S)
	}
	return err
}

// GetB returns the value of B if it is set or its
// default value if it is unset.
func (v *BoolTest) GetB() (o bool) {
	if v.B != nil {
		return *v.B
	}
	o = true
	return
}

// IsSetB returns true if B is not nil.
func (v *BoolTest) IsSetB() bool {
	return v.B != nil
}

// GetS returns the value of S if it is set or its
// default value if it is unset.
func (v *BoolTest) GetS() (o string) {
	if v.S != nil {
		return *v.S
	}
	o = "true"
	return
}

// IsSetS returns true if S is not nil.
func (v *BoolTest) IsSetS() bool {
	return v.S != nil
}

type Bools struct {
	ImTrue  *bool `json:"im_true,omitempty"`
	ImFalse *bool `json:"im_false,omitempty"`
}

// ToWire translates a Bools struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bools) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ImTrue != nil {
		w, err = wire.NewValueBool(*(v.ImTrue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ImFalse != nil {
		w, err = wire.NewValueBool(*(v.ImFalse)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bools struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bools struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bools
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bools) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ImTrue = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ImFalse = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Bools
// struct.
func (v *Bools) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ImTrue != nil {
		fields[i] = fmt.Sprintf("ImTrue: %v", *(v.ImTrue))
		i++
	}
	if v.ImFalse != nil {
		fields[i] = fmt.Sprintf("ImFalse: %v", *(v.ImFalse))
		i++
	}

	return fmt.Sprintf("Bools{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bools match the
// provided Bools.
//
// This function performs a deep comparison.
func (v *Bools) Equals(rhs *Bools) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.ImTrue, rhs.ImTrue) {
		return false
	}
	if !_Bool_EqualsPtr(v.ImFalse, rhs.ImFalse) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bools.
func (v *Bools) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ImTrue != nil {
		enc.AddBool("im_true", *v.ImTrue)
	}
	if v.ImFalse != nil {
		enc.AddBool("im_false", *v.ImFalse)
	}
	return err
}

// GetImTrue returns the value of ImTrue if it is set or its
// zero value if it is unset.
func (v *Bools) GetImTrue() (o bool) {
	if v.ImTrue != nil {
		return *v.ImTrue
	}

	return
}

// IsSetImTrue returns true if ImTrue is not nil.
func (v *Bools) IsSetImTrue() bool {
	return v.ImTrue != nil
}

// GetImFalse returns the value of ImFalse if it is set or its
// zero value if it is unset.
func (v *Bools) GetImFalse() (o bool) {
	if v.ImFalse != nil {
		return *v.ImFalse
	}

	return
}

// IsSetImFalse returns true if ImFalse is not nil.
func (v *Bools) IsSetImFalse() bool {
	return v.ImFalse != nil
}

type CrazyNesting struct {
	StringField *string     `json:"string_field,omitempty"`
	SetField    []*Insanity `json:"set_field,omitempty"`
	ListField   [][]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	} `json:"list_field,required"`
	BinaryField []byte `json:"binary_field,omitempty"`
}

type _Set_Insanity_ValueList []*Insanity

func (v _Set_Insanity_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Insanity_ValueList) Size() int {
	return len(v)
}

func (_Set_Insanity_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Insanity_ValueList) Close() {}

type _Set_I32_ValueList map[int32]struct{}

func (v _Set_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_I32_ValueList) Size() int {
	return len(v)
}

func (_Set_I32_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_Set_I32_ValueList) Close() {}

type _Map_Insanity_String_MapItemList []struct {
	Key   *Insanity
	Value string
}

func (m _Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TStruct
}

func (_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_Insanity_String_MapItemList) Close() {}

type _List_Map_Insanity_String_ValueList [][]struct {
	Key   *Insanity
	Value string
}

func (v _List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_Insanity_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_Insanity_String_ValueList) Close() {}

type _Set_List_Map_Insanity_String_ValueList [][][]struct {
	Key   *Insanity
	Value string
}

func (v _Set_List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := wire.NewValueList(_List_Map_Insanity_String_ValueList(x)), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_Set_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_Set_List_Map_Insanity_String_ValueList) Close() {}

type _Map_I32_Set_List_Map_Insanity_String_MapItemList map[int32][][][]struct {
	Key   *Insanity
	Value string
}

func (m _Map_I32_Set_List_Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueSet(_Set_List_Map_Insanity_String_ValueList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Set_List_Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Set_List_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Set_List_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TSet
}

func (_Map_I32_Set_List_Map_Insanity_String_MapItemList) Close() {}

type _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList []struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

func (m _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueSet(_Set_I32_ValueList(k)), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueMap(_Map_I32_Set_List_Map_Insanity_String_MapItemList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TSet
}

func (_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TMap
}

func (_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) Close() {}

type _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

func (v _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) Close() {}

// ToWire translates a CrazyNesting struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CrazyNesting) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StringField != nil {
		w, err = wire.NewValueString(*(v.StringField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.SetField != nil {
		w, err = wire.NewValueSet(_Set_Insanity_ValueList(v.SetField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ListField == nil {
		return w, errors.New("field ListField of CrazyNesting is required")
	}
	w, err = wire.NewValueList(_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList(v.ListField)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.BinaryField != nil {
		w, err = wire.NewValueBinary(v.BinaryField), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Insanity_Read(w wire.Value) (*Insanity, error) {
	var v Insanity
	err := v.FromWire(w)
	return &v, err
}

func _Set_Insanity_Read(s wire.ValueList) ([]*Insanity, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Insanity, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Insanity_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Set_I32_Read(s wire.ValueList) (map[int32]struct{}, error) {
	if s.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[int32]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _Map_Insanity_String_Read(m wire.MapItemList) ([]struct {
	Key   *Insanity
	Value string
}, error) {
	if m.KeyType() != wire.TStruct {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]struct {
		Key   *Insanity
		Value string
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Insanity_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o = append(o, struct {
			Key   *Insanity
			Value string
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_Insanity_String_Read(l wire.ValueList) ([][]struct {
	Key   *Insanity
	Value string
}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([][]struct {
		Key   *Insanity
		Value string
	}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_Insanity_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Set_List_Map_Insanity_String_Read(s wire.ValueList) ([][][]struct {
	Key   *Insanity
	Value string
}, error) {
	if s.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][][]struct {
		Key   *Insanity
		Value string
	}, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _List_Map_Insanity_String_Read(x.GetList())
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Map_I32_Set_List_Map_Insanity_String_Read(m wire.MapItemList) (map[int32][][][]struct {
	Key   *Insanity
	Value string
}, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TSet {
		return nil, nil
	}

	o := make(map[int32][][][]struct {
		Key   *Insanity
		Value string
	}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Set_List_Map_Insanity_String_Read(x.Value.GetSet())
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(m wire.MapItemList) ([]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}, error) {
	if m.KeyType() != wire.TSet {
		return nil, nil
	}

	if m.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Set_I32_Read(x.Key.GetSet())
		if err != nil {
			return err
		}

		v, err := _Map_I32_Set_List_Map_Insanity_String_Read(x.Value.GetMap())
		if err != nil {
			return err
		}

		o = append(o, struct {
			Key   map[int32]struct{}
			Value map[int32][][][]struct {
				Key   *Insanity
				Value string
			}
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(l wire.ValueList) ([][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([][]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a CrazyNesting struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CrazyNesting struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CrazyNesting
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CrazyNesting) FromWire(w wire.Value) error {
	var err error

	list_fieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringField = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.SetField, err = _Set_Insanity_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.ListField, err = _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				list_fieldIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	if !list_fieldIsSet {
		return errors.New("field ListField of CrazyNesting is required")
	}

	return nil
}

// String returns a readable string representation of a CrazyNesting
// struct.
func (v *CrazyNesting) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.StringField != nil {
		fields[i] = fmt.Sprintf("StringField: %v", *(v.StringField))
		i++
	}
	if v.SetField != nil {
		fields[i] = fmt.Sprintf("SetField: %v", v.SetField)
		i++
	}
	fields[i] = fmt.Sprintf("ListField: %v", v.ListField)
	i++
	if v.BinaryField != nil {
		fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
		i++
	}

	return fmt.Sprintf("CrazyNesting{%v}", strings.Join(fields[:i], ", "))
}

func _Set_Insanity_Equals(lhs, rhs []*Insanity) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

func _Set_I32_Equals(lhs, rhs map[int32]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

func _Map_Insanity_String_Equals(lhs, rhs []struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !lk.Equals(rk) {
				continue
			}

			if !(lv == rv) {
				return false
			}
			ok = true
			break
		}

		if !ok {
			return false
		}
	}
	return true
}

func _List_Map_Insanity_String_Equals(lhs, rhs [][]struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Map_Insanity_String_Equals(lv, rv) {
			return false
		}
	}

	return true
}

func _Set_List_Map_Insanity_String_Equals(lhs, rhs [][][]struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if _List_Map_Insanity_String_Equals(x, y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

func _Map_I32_Set_List_Map_Insanity_String_Equals(lhs, rhs map[int32][][][]struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !_Set_List_Map_Insanity_String_Equals(lv, rv) {
			return false
		}
	}
	return true
}

func _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Equals(lhs, rhs []struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !_Set_I32_Equals(lk, rk) {
				continue
			}

			if !_Map_I32_Set_List_Map_Insanity_String_Equals(lv, rv) {
				return false
			}
			ok = true
			break
		}

		if !ok {
			return false
		}
	}
	return true
}

func _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Equals(lhs, rhs [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this CrazyNesting match the
// provided CrazyNesting.
//
// This function performs a deep comparison.
func (v *CrazyNesting) Equals(rhs *CrazyNesting) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.StringField, rhs.StringField) {
		return false
	}
	if !((v.SetField == nil && rhs.SetField == nil) || (v.SetField != nil && rhs.SetField != nil && _Set_Insanity_Equals(v.SetField, rhs.SetField))) {
		return false
	}
	if !_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Equals(v.ListField, rhs.ListField) {
		return false
	}
	if !((v.BinaryField == nil && rhs.BinaryField == nil) || (v.BinaryField != nil && rhs.BinaryField != nil && bytes.Equal(v.BinaryField, rhs.BinaryField))) {
		return false
	}

	return true
}

type _Set_Insanity_Zapper []*Insanity

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Insanity_Zapper.
func (s _Set_Insanity_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type _Set_I32_Zapper map[int32]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_I32_Zapper.
func (s _Set_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		enc.AppendInt32(v)
	}
	return err
}

type _Map_Insanity_String_Item_Zapper struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Insanity_String_Item_Zapper.
func (v _Map_Insanity_String_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddObject("key", v.Key))
	enc.AddString("value", v.Value)
	return err
}

type _Map_Insanity_String_Zapper []struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Insanity_String_Zapper.
func (m _Map_Insanity_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, i := range m {
		k := i.Key
		v := i.Value
		err = multierr.Append(err, enc.AppendObject(_Map_Insanity_String_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _List_Map_Insanity_String_Zapper [][]struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Map_Insanity_String_Zapper.
func (l _List_Map_Insanity_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_Map_Insanity_String_Zapper)(v)))
	}
	return err
}

type _Set_List_Map_Insanity_String_Zapper [][][]struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_List_Map_Insanity_String_Zapper.
func (s _Set_List_Map_Insanity_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendArray((_List_Map_Insanity_String_Zapper)(v)))
	}
	return err
}

type _Map_I32_Set_List_Map_Insanity_String_Item_Zapper struct {
	Key   int32
	Value [][][]struct {
		Key   *Insanity
		Value string
	}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Set_List_Map_Insanity_String_Item_Zapper.
func (v _Map_I32_Set_List_Map_Insanity_String_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	err = multierr.Append(err, enc.AddArray("value", (_Set_List_Map_Insanity_String_Zapper)(v.Value)))
	return err
}

type _Map_I32_Set_List_Map_Insanity_String_Zapper map[int32][][][]struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Set_List_Map_Insanity_String_Zapper.
func (m _Map_I32_Set_List_Map_Insanity_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_Set_List_Map_Insanity_String_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Item_Zapper struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Item_Zapper.
func (v _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddArray("key", (_Set_I32_Zapper)(v.Key)))
	err = multierr.Append(err, enc.AddArray("value", (_Map_I32_Set_List_Map_Insanity_String_Zapper)(v.Value)))
	return err
}

type _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Zapper []struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Zapper.
func (m _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, i := range m {
		k := i.Key
		v := i.Value
		err = multierr.Append(err, enc.AppendObject(_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Zapper [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Zapper.
func (l _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CrazyNesting.
func (v *CrazyNesting) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.StringField != nil {
		enc.AddString("string_field", *v.StringField)
	}
	if v.SetField != nil {
		err = multierr.Append(err, enc.AddArray("set_field", (_Set_Insanity_Zapper)(v.SetField)))
	}
	err = multierr.Append(err, enc.AddArray("list_field", (_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Zapper)(v.ListField)))
	if v.BinaryField != nil {
		enc.AddString("binary_field", base64.StdEncoding.EncodeToString(v.BinaryField))
	}
	return err
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *CrazyNesting) GetStringField() (o string) {
	if v.StringField != nil {
		return *v.StringField
	}

	return
}

// IsSetStringField returns true if StringField is not nil.
func (v *CrazyNesting) IsSetStringField() bool {
	return v.StringField != nil
}

// GetSetField returns the value of SetField if it is set or its
// zero value if it is unset.
func (v *CrazyNesting) GetSetField() (o []*Insanity) {
	if v.SetField != nil {
		return v.SetField
	}

	return
}

// IsSetSetField returns true if SetField is not nil.
func (v *CrazyNesting) IsSetSetField() bool {
	return v.SetField != nil
}

// GetListField returns the value of ListField if it is set or its
// zero value if it is unset.
func (v *CrazyNesting) GetListField() (o [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}) {
	return v.ListField
}

// IsSetListField returns true if ListField is not nil.
func (v *CrazyNesting) IsSetListField() bool {
	return v.ListField != nil
}

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *CrazyNesting) GetBinaryField() (o []byte) {
	if v.BinaryField != nil {
		return v.BinaryField
	}

	return
}

// IsSetBinaryField returns true if BinaryField is not nil.
func (v *CrazyNesting) IsSetBinaryField() bool {
	return v.BinaryField != nil
}

type EmptyStruct struct {
}

// ToWire translates a EmptyStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *EmptyStruct) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a EmptyStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a EmptyStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v EmptyStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *EmptyStruct) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a EmptyStruct
// struct.
func (v *EmptyStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("EmptyStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this EmptyStruct match the
// provided EmptyStruct.
//
// This function performs a deep comparison.
func (v *EmptyStruct) Equals(rhs *EmptyStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of EmptyStruct.
func (v *EmptyStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

type GuessProtocolStruct struct {
	MapField map[string]string `json:"map_field,omitempty"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a GuessProtocolStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GuessProtocolStruct) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.MapField != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.MapField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a GuessProtocolStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GuessProtocolStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GuessProtocolStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GuessProtocolStruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 7:
			if field.Value.Type() == wire.TMap {
				v.MapField, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GuessProtocolStruct
// struct.
func (v *GuessProtocolStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.MapField != nil {
		fields[i] = fmt.Sprintf("MapField: %v", v.MapField)
		i++
	}

	return fmt.Sprintf("GuessProtocolStruct{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this GuessProtocolStruct match the
// provided GuessProtocolStruct.
//
// This function performs a deep comparison.
func (v *GuessProtocolStruct) Equals(rhs *GuessProtocolStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.MapField == nil && rhs.MapField == nil) || (v.MapField != nil && rhs.MapField != nil && _Map_String_String_Equals(v.MapField, rhs.MapField))) {
		return false
	}

	return true
}

type _Map_String_String_Zapper map[string]string

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_String_Zapper.
func (m _Map_String_String_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GuessProtocolStruct.
func (v *GuessProtocolStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.MapField != nil {
		err = multierr.Append(err, enc.AddObject("map_field", (_Map_String_String_Zapper)(v.MapField)))
	}
	return err
}

// GetMapField returns the value of MapField if it is set or its
// zero value if it is unset.
func (v *GuessProtocolStruct) GetMapField() (o map[string]string) {
	if v.MapField != nil {
		return v.MapField
	}

	return
}

// IsSetMapField returns true if MapField is not nil.
func (v *GuessProtocolStruct) IsSetMapField() bool {
	return v.MapField != nil
}

type Insanity struct {
	UserMap map[Numberz]UserId `json:"userMap,omitempty"`
	Xtructs []*Xtruct          `json:"xtructs,omitempty"`
}

type _Map_Numberz_UserId_MapItemList map[Numberz]UserId

func (m _Map_Numberz_UserId_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Numberz_UserId_MapItemList) Size() int {
	return len(m)
}

func (_Map_Numberz_UserId_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_Numberz_UserId_MapItemList) ValueType() wire.Type {
	return wire.TI64
}

func (_Map_Numberz_UserId_MapItemList) Close() {}

type _List_Xtruct_ValueList []*Xtruct

func (v _List_Xtruct_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Xtruct_ValueList) Size() int {
	return len(v)
}

func (_List_Xtruct_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Xtruct_ValueList) Close() {}

// ToWire translates a Insanity struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Insanity) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.UserMap != nil {
		w, err = wire.NewValueMap(_Map_Numberz_UserId_MapItemList(v.UserMap)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Xtructs != nil {
		w, err = wire.NewValueList(_List_Xtruct_ValueList(v.Xtructs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Numberz_Read(w wire.Value) (Numberz, error) {
	var v Numberz
	err := v.FromWire(w)
	return v, err
}

func _UserId_Read(w wire.Value) (UserId, error) {
	var x UserId
	err := x.FromWire(w)
	return x, err
}

func _Map_Numberz_UserId_Read(m wire.MapItemList) (map[Numberz]UserId, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TI64 {
		return nil, nil
	}

	o := make(map[Numberz]UserId, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Numberz_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _UserId_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Xtruct_Read(w wire.Value) (*Xtruct, error) {
	var v Xtruct
	err := v.FromWire(w)
	return &v, err
}

func _List_Xtruct_Read(l wire.ValueList) ([]*Xtruct, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Xtruct, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Xtruct_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Insanity struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Insanity struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Insanity
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Insanity) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.UserMap, err = _Map_Numberz_UserId_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Xtructs, err = _List_Xtruct_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Insanity
// struct.
func (v *Insanity) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.UserMap != nil {
		fields[i] = fmt.Sprintf("UserMap: %v", v.UserMap)
		i++
	}
	if v.Xtructs != nil {
		fields[i] = fmt.Sprintf("Xtructs: %v", v.Xtructs)
		i++
	}

	return fmt.Sprintf("Insanity{%v}", strings.Join(fields[:i], ", "))
}

func _Map_Numberz_UserId_Equals(lhs, rhs map[Numberz]UserId) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func _List_Xtruct_Equals(lhs, rhs []*Xtruct) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Insanity match the
// provided Insanity.
//
// This function performs a deep comparison.
func (v *Insanity) Equals(rhs *Insanity) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.UserMap == nil && rhs.UserMap == nil) || (v.UserMap != nil && rhs.UserMap != nil && _Map_Numberz_UserId_Equals(v.UserMap, rhs.UserMap))) {
		return false
	}
	if !((v.Xtructs == nil && rhs.Xtructs == nil) || (v.Xtructs != nil && rhs.Xtructs != nil && _List_Xtruct_Equals(v.Xtructs, rhs.Xtructs))) {
		return false
	}

	return true
}

type _Map_Numberz_UserId_Item_Zapper struct {
	Key   Numberz
	Value UserId
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Numberz_UserId_Item_Zapper.
func (v _Map_Numberz_UserId_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddObject("key", v.Key))
	enc.AddInt64("value", (int64)(v.Value))
	return err
}

type _Map_Numberz_UserId_Zapper map[Numberz]UserId

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Numberz_UserId_Zapper.
func (m _Map_Numberz_UserId_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_Numberz_UserId_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _List_Xtruct_Zapper []*Xtruct

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Xtruct_Zapper.
func (l _List_Xtruct_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Insanity.
func (v *Insanity) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.UserMap != nil {
		err = multierr.Append(err, enc.AddArray("userMap", (_Map_Numberz_UserId_Zapper)(v.UserMap)))
	}
	if v.Xtructs != nil {
		err = multierr.Append(err, enc.AddArray("xtructs", (_List_Xtruct_Zapper)(v.Xtructs)))
	}
	return err
}

// GetUserMap returns the value of UserMap if it is set or its
// zero value if it is unset.
func (v *Insanity) GetUserMap() (o map[Numberz]UserId) {
	if v.UserMap != nil {
		return v.UserMap
	}

	return
}

// IsSetUserMap returns true if UserMap is not nil.
func (v *Insanity) IsSetUserMap() bool {
	return v.UserMap != nil
}

// GetXtructs returns the value of Xtructs if it is set or its
// zero value if it is unset.
func (v *Insanity) GetXtructs() (o []*Xtruct) {
	if v.Xtructs != nil {
		return v.Xtructs
	}

	return
}

// IsSetXtructs returns true if Xtructs is not nil.
func (v *Insanity) IsSetXtructs() bool {
	return v.Xtructs != nil
}

type LargeDeltas struct {
	B1         *Bools              `json:"b1,omitempty"`
	B10        *Bools              `json:"b10,omitempty"`
	B100       *Bools              `json:"b100,omitempty"`
	CheckTrue  *bool               `json:"check_true,omitempty"`
	B1000      *Bools              `json:"b1000,omitempty"`
	CheckFalse *bool               `json:"check_false,omitempty"`
	Vertwo2000 *VersioningTestV2   `json:"vertwo2000,omitempty"`
	ASet2500   map[string]struct{} `json:"a_set2500,omitempty"`
	Vertwo3000 *VersioningTestV2   `json:"vertwo3000,omitempty"`
	BigNumbers []int32             `json:"big_numbers,omitempty"`
}

type _Set_String_ValueList map[string]struct{}

func (v _Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_ValueList) Size() int {
	return len(v)
}

func (_Set_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_ValueList) Close() {}

type _List_I32_ValueList []int32

func (v _List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_I32_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_I32_ValueList) Close() {}

// ToWire translates a LargeDeltas struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *LargeDeltas) ToWire() (wire.Value, error) {
	var (
		fields [10]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.B1 != nil {
		w, err = v.B1.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.B10 != nil {
		w, err = v.B10.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.B100 != nil {
		w, err = v.B100.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 100, Value: w}
		i++
	}
	if v.CheckTrue != nil {
		w, err = wire.NewValueBool(*(v.CheckTrue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 500, Value: w}
		i++
	}
	if v.B1000 != nil {
		w, err = v.B1000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1000, Value: w}
		i++
	}
	if v.CheckFalse != nil {
		w, err = wire.NewValueBool(*(v.CheckFalse)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1500, Value: w}
		i++
	}
	if v.Vertwo2000 != nil {
		w, err = v.Vertwo2000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2000, Value: w}
		i++
	}
	if v.ASet2500 != nil {
		w, err = wire.NewValueSet(_Set_String_ValueList(v.ASet2500)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2500, Value: w}
		i++
	}
	if v.Vertwo3000 != nil {
		w, err = v.Vertwo3000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3000, Value: w}
		i++
	}
	if v.BigNumbers != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.BigNumbers)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4000, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Bools_Read(w wire.Value) (*Bools, error) {
	var v Bools
	err := v.FromWire(w)
	return &v, err
}

func _VersioningTestV2_Read(w wire.Value) (*VersioningTestV2, error) {
	var v VersioningTestV2
	err := v.FromWire(w)
	return &v, err
}

func _Set_String_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _List_I32_Read(l wire.ValueList) ([]int32, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a LargeDeltas struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a LargeDeltas struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v LargeDeltas
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *LargeDeltas) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.B1, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 10:
			if field.Value.Type() == wire.TStruct {
				v.B10, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 100:
			if field.Value.Type() == wire.TStruct {
				v.B100, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 500:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CheckTrue = &x
				if err != nil {
					return err
				}

			}
		case 1000:
			if field.Value.Type() == wire.TStruct {
				v.B1000, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1500:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CheckFalse = &x
				if err != nil {
					return err
				}

			}
		case 2000:
			if field.Value.Type() == wire.TStruct {
				v.Vertwo2000, err = _VersioningTestV2_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2500:
			if field.Value.Type() == wire.TSet {
				v.ASet2500, err = _Set_String_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 3000:
			if field.Value.Type() == wire.TStruct {
				v.Vertwo3000, err = _VersioningTestV2_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4000:
			if field.Value.Type() == wire.TList {
				v.BigNumbers, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a LargeDeltas
// struct.
func (v *LargeDeltas) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [10]string
	i := 0
	if v.B1 != nil {
		fields[i] = fmt.Sprintf("B1: %v", v.B1)
		i++
	}
	if v.B10 != nil {
		fields[i] = fmt.Sprintf("B10: %v", v.B10)
		i++
	}
	if v.B100 != nil {
		fields[i] = fmt.Sprintf("B100: %v", v.B100)
		i++
	}
	if v.CheckTrue != nil {
		fields[i] = fmt.Sprintf("CheckTrue: %v", *(v.CheckTrue))
		i++
	}
	if v.B1000 != nil {
		fields[i] = fmt.Sprintf("B1000: %v", v.B1000)
		i++
	}
	if v.CheckFalse != nil {
		fields[i] = fmt.Sprintf("CheckFalse: %v", *(v.CheckFalse))
		i++
	}
	if v.Vertwo2000 != nil {
		fields[i] = fmt.Sprintf("Vertwo2000: %v", v.Vertwo2000)
		i++
	}
	if v.ASet2500 != nil {
		fields[i] = fmt.Sprintf("ASet2500: %v", v.ASet2500)
		i++
	}
	if v.Vertwo3000 != nil {
		fields[i] = fmt.Sprintf("Vertwo3000: %v", v.Vertwo3000)
		i++
	}
	if v.BigNumbers != nil {
		fields[i] = fmt.Sprintf("BigNumbers: %v", v.BigNumbers)
		i++
	}

	return fmt.Sprintf("LargeDeltas{%v}", strings.Join(fields[:i], ", "))
}

func _Set_String_Equals(lhs, rhs map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

func _List_I32_Equals(lhs, rhs []int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this LargeDeltas match the
// provided LargeDeltas.
//
// This function performs a deep comparison.
func (v *LargeDeltas) Equals(rhs *LargeDeltas) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.B1 == nil && rhs.B1 == nil) || (v.B1 != nil && rhs.B1 != nil && v.B1.Equals(rhs.B1))) {
		return false
	}
	if !((v.B10 == nil && rhs.B10 == nil) || (v.B10 != nil && rhs.B10 != nil && v.B10.Equals(rhs.B10))) {
		return false
	}
	if !((v.B100 == nil && rhs.B100 == nil) || (v.B100 != nil && rhs.B100 != nil && v.B100.Equals(rhs.B100))) {
		return false
	}
	if !_Bool_EqualsPtr(v.CheckTrue, rhs.CheckTrue) {
		return false
	}
	if !((v.B1000 == nil && rhs.B1000 == nil) || (v.B1000 != nil && rhs.B1000 != nil && v.B1000.Equals(rhs.B1000))) {
		return false
	}
	if !_Bool_EqualsPtr(v.CheckFalse, rhs.CheckFalse) {
		return false
	}
	if !((v.Vertwo2000 == nil && rhs.Vertwo2000 == nil) || (v.Vertwo2000 != nil && rhs.Vertwo2000 != nil && v.Vertwo2000.Equals(rhs.Vertwo2000))) {
		return false
	}
	if !((v.ASet2500 == nil && rhs.ASet2500 == nil) || (v.ASet2500 != nil && rhs.ASet2500 != nil && _Set_String_Equals(v.ASet2500, rhs.ASet2500))) {
		return false
	}
	if !((v.Vertwo3000 == nil && rhs.Vertwo3000 == nil) || (v.Vertwo3000 != nil && rhs.Vertwo3000 != nil && v.Vertwo3000.Equals(rhs.Vertwo3000))) {
		return false
	}
	if !((v.BigNumbers == nil && rhs.BigNumbers == nil) || (v.BigNumbers != nil && rhs.BigNumbers != nil && _List_I32_Equals(v.BigNumbers, rhs.BigNumbers))) {
		return false
	}

	return true
}

type _Set_String_Zapper map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_String_Zapper.
func (s _Set_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		enc.AppendString(v)
	}
	return err
}

type _List_I32_Zapper []int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_I32_Zapper.
func (l _List_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendInt32(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of LargeDeltas.
func (v *LargeDeltas) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.B1 != nil {
		err = multierr.Append(err, enc.AddObject("b1", v.B1))
	}
	if v.B10 != nil {
		err = multierr.Append(err, enc.AddObject("b10", v.B10))
	}
	if v.B100 != nil {
		err = multierr.Append(err, enc.AddObject("b100", v.B100))
	}
	if v.CheckTrue != nil {
		enc.AddBool("check_true", *v.CheckTrue)
	}
	if v.B1000 != nil {
		err = multierr.Append(err, enc.AddObject("b1000", v.B1000))
	}
	if v.CheckFalse != nil {
		enc.AddBool("check_false", *v.CheckFalse)
	}
	if v.Vertwo2000 != nil {
		err = multierr.Append(err, enc.AddObject("vertwo2000", v.Vertwo2000))
	}
	if v.ASet2500 != nil {
		err = multierr.Append(err, enc.AddArray("a_set2500", (_Set_String_Zapper)(v.ASet2500)))
	}
	if v.Vertwo3000 != nil {
		err = multierr.Append(err, enc.AddObject("vertwo3000", v.Vertwo3000))
	}
	if v.BigNumbers != nil {
		err = multierr.Append(err, enc.AddArray("big_numbers", (_List_I32_Zapper)(v.BigNumbers)))
	}
	return err
}

// GetB1 returns the value of B1 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetB1() (o *Bools) {
	if v.B1 != nil {
		return v.B1
	}

	return
}

// IsSetB1 returns true if B1 is not nil.
func (v *LargeDeltas) IsSetB1() bool {
	return v.B1 != nil
}

// GetB10 returns the value of B10 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetB10() (o *Bools) {
	if v.B10 != nil {
		return v.B10
	}

	return
}

// IsSetB10 returns true if B10 is not nil.
func (v *LargeDeltas) IsSetB10() bool {
	return v.B10 != nil
}

// GetB100 returns the value of B100 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetB100() (o *Bools) {
	if v.B100 != nil {
		return v.B100
	}

	return
}

// IsSetB100 returns true if B100 is not nil.
func (v *LargeDeltas) IsSetB100() bool {
	return v.B100 != nil
}

// GetCheckTrue returns the value of CheckTrue if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetCheckTrue() (o bool) {
	if v.CheckTrue != nil {
		return *v.CheckTrue
	}

	return
}

// IsSetCheckTrue returns true if CheckTrue is not nil.
func (v *LargeDeltas) IsSetCheckTrue() bool {
	return v.CheckTrue != nil
}

// GetB1000 returns the value of B1000 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetB1000() (o *Bools) {
	if v.B1000 != nil {
		return v.B1000
	}

	return
}

// IsSetB1000 returns true if B1000 is not nil.
func (v *LargeDeltas) IsSetB1000() bool {
	return v.B1000 != nil
}

// GetCheckFalse returns the value of CheckFalse if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetCheckFalse() (o bool) {
	if v.CheckFalse != nil {
		return *v.CheckFalse
	}

	return
}

// IsSetCheckFalse returns true if CheckFalse is not nil.
func (v *LargeDeltas) IsSetCheckFalse() bool {
	return v.CheckFalse != nil
}

// GetVertwo2000 returns the value of Vertwo2000 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetVertwo2000() (o *VersioningTestV2) {
	if v.Vertwo2000 != nil {
		return v.Vertwo2000
	}

	return
}

// IsSetVertwo2000 returns true if Vertwo2000 is not nil.
func (v *LargeDeltas) IsSetVertwo2000() bool {
	return v.Vertwo2000 != nil
}

// GetASet2500 returns the value of ASet2500 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetASet2500() (o map[string]struct{}) {
	if v.ASet2500 != nil {
		return v.ASet2500
	}

	return
}

// IsSetASet2500 returns true if ASet2500 is not nil.
func (v *LargeDeltas) IsSetASet2500() bool {
	return v.ASet2500 != nil
}

// GetVertwo3000 returns the value of Vertwo3000 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetVertwo3000() (o *VersioningTestV2) {
	if v.Vertwo3000 != nil {
		return v.Vertwo3000
	}

	return
}

// IsSetVertwo3000 returns true if Vertwo3000 is not nil.
func (v *LargeDeltas) IsSetVertwo3000() bool {
	return v.Vertwo3000 != nil
}

// GetBigNumbers returns the value of BigNumbers if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetBigNumbers() (o []int32) {
	if v.BigNumbers != nil {
		return v.BigNumbers
	}

	return
}

// IsSetBigNumbers returns true if BigNumbers is not nil.
func (v *LargeDeltas) IsSetBigNumbers() bool {
	return v.BigNumbers != nil
}

type ListBonks struct {
	Bonk []*Bonk `json:"bonk,omitempty"`
}

type _List_Bonk_ValueList []*Bonk

func (v _List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Bonk_ValueList) Close() {}

// ToWire translates a ListBonks struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListBonks) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Bonk != nil {
		w, err = wire.NewValueList(_List_Bonk_ValueList(v.Bonk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Bonk_Read(w wire.Value) (*Bonk, error) {
	var v Bonk
	err := v.FromWire(w)
	return &v, err
}

func _List_Bonk_Read(l wire.ValueList) ([]*Bonk, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Bonk_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ListBonks struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListBonks struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListBonks
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListBonks) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Bonk, err = _List_Bonk_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListBonks
// struct.
func (v *ListBonks) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Bonk != nil {
		fields[i] = fmt.Sprintf("Bonk: %v", v.Bonk)
		i++
	}

	return fmt.Sprintf("ListBonks{%v}", strings.Join(fields[:i], ", "))
}

func _List_Bonk_Equals(lhs, rhs []*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ListBonks match the
// provided ListBonks.
//
// This function performs a deep comparison.
func (v *ListBonks) Equals(rhs *ListBonks) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Bonk == nil && rhs.Bonk == nil) || (v.Bonk != nil && rhs.Bonk != nil && _List_Bonk_Equals(v.Bonk, rhs.Bonk))) {
		return false
	}

	return true
}

type _List_Bonk_Zapper []*Bonk

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Bonk_Zapper.
func (l _List_Bonk_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListBonks.
func (v *ListBonks) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Bonk != nil {
		err = multierr.Append(err, enc.AddArray("bonk", (_List_Bonk_Zapper)(v.Bonk)))
	}
	return err
}

// GetBonk returns the value of Bonk if it is set or its
// zero value if it is unset.
func (v *ListBonks) GetBonk() (o []*Bonk) {
	if v.Bonk != nil {
		return v.Bonk
	}

	return
}

// IsSetBonk returns true if Bonk is not nil.
func (v *ListBonks) IsSetBonk() bool {
	return v.Bonk != nil
}

type ListTypeVersioningV1 struct {
	Myints []int32 `json:"myints,omitempty"`
	Hello  *string `json:"hello,omitempty"`
}

// ToWire translates a ListTypeVersioningV1 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListTypeVersioningV1) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Myints != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Myints)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Hello != nil {
		w, err = wire.NewValueString(*(v.Hello)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ListTypeVersioningV1 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListTypeVersioningV1 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListTypeVersioningV1
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListTypeVersioningV1) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Myints, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Hello = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListTypeVersioningV1
// struct.
func (v *ListTypeVersioningV1) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Myints != nil {
		fields[i] = fmt.Sprintf("Myints: %v", v.Myints)
		i++
	}
	if v.Hello != nil {
		fields[i] = fmt.Sprintf("Hello: %v", *(v.Hello))
		i++
	}

	return fmt.Sprintf("ListTypeVersioningV1{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ListTypeVersioningV1 match the
// provided ListTypeVersioningV1.
//
// This function performs a deep comparison.
func (v *ListTypeVersioningV1) Equals(rhs *ListTypeVersioningV1) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Myints == nil && rhs.Myints == nil) || (v.Myints != nil && rhs.Myints != nil && _List_I32_Equals(v.Myints, rhs.Myints))) {
		return false
	}
	if !_String_EqualsPtr(v.Hello, rhs.Hello) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListTypeVersioningV1.
func (v *ListTypeVersioningV1) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Myints != nil {
		err = multierr.Append(err, enc.AddArray("myints", (_List_I32_Zapper)(v.Myints)))
	}
	if v.Hello != nil {
		enc.AddString("hello", *v.Hello)
	}
	return err
}

// GetMyints returns the value of Myints if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV1) GetMyints() (o []int32) {
	if v.Myints != nil {
		return v.Myints
	}

	return
}

// IsSetMyints returns true if Myints is not nil.
func (v *ListTypeVersioningV1) IsSetMyints() bool {
	return v.Myints != nil
}

// GetHello returns the value of Hello if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV1) GetHello() (o string) {
	if v.Hello != nil {
		return *v.Hello
	}

	return
}

// IsSetHello returns true if Hello is not nil.
func (v *ListTypeVersioningV1) IsSetHello() bool {
	return v.Hello != nil
}

type ListTypeVersioningV2 struct {
	Strings []string `json:"strings,omitempty"`
	Hello   *string  `json:"hello,omitempty"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

// ToWire translates a ListTypeVersioningV2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListTypeVersioningV2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Strings != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Strings)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Hello != nil {
		w, err = wire.NewValueString(*(v.Hello)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ListTypeVersioningV2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListTypeVersioningV2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListTypeVersioningV2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListTypeVersioningV2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Strings, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Hello = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListTypeVersioningV2
// struct.
func (v *ListTypeVersioningV2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Strings != nil {
		fields[i] = fmt.Sprintf("Strings: %v", v.Strings)
		i++
	}
	if v.Hello != nil {
		fields[i] = fmt.Sprintf("Hello: %v", *(v.Hello))
		i++
	}

	return fmt.Sprintf("ListTypeVersioningV2{%v}", strings.Join(fields[:i], ", "))
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ListTypeVersioningV2 match the
// provided ListTypeVersioningV2.
//
// This function performs a deep comparison.
func (v *ListTypeVersioningV2) Equals(rhs *ListTypeVersioningV2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Strings == nil && rhs.Strings == nil) || (v.Strings != nil && rhs.Strings != nil && _List_String_Equals(v.Strings, rhs.Strings))) {
		return false
	}
	if !_String_EqualsPtr(v.Hello, rhs.Hello) {
		return false
	}

	return true
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListTypeVersioningV2.
func (v *ListTypeVersioningV2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Strings != nil {
		err = multierr.Append(err, enc.AddArray("strings", (_List_String_Zapper)(v.Strings)))
	}
	if v.Hello != nil {
		enc.AddString("hello", *v.Hello)
	}
	return err
}

// GetStrings returns the value of Strings if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV2) GetStrings() (o []string) {
	if v.Strings != nil {
		return v.Strings
	}

	return
}

// IsSetStrings returns true if Strings is not nil.
func (v *ListTypeVersioningV2) IsSetStrings() bool {
	return v.Strings != nil
}

// GetHello returns the value of Hello if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV2) GetHello() (o string) {
	if v.Hello != nil {
		return *v.Hello
	}

	return
}

// IsSetHello returns true if Hello is not nil.
func (v *ListTypeVersioningV2) IsSetHello() bool {
	return v.Hello != nil
}

type _Map_String_Bonk_MapItemList map[string]*Bonk

func (m _Map_String_Bonk_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Bonk_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Bonk_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Bonk_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_Bonk_MapItemList) Close() {}

func _Map_String_Bonk_Read(m wire.MapItemList) (map[string]*Bonk, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[string]*Bonk, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Bonk_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_String_Bonk_Equals(lhs, rhs map[string]*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

type _Map_String_Bonk_Zapper map[string]*Bonk

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_Bonk_Zapper.
func (m _Map_String_Bonk_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AddObject((string)(k), v))
	}
	return err
}

type MapType map[string]*Bonk

// ToWire translates MapType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v MapType) ToWire() (wire.Value, error) {
	x := (map[string]*Bonk)(v)
	return wire.NewValueMap(_Map_String_Bonk_MapItemList(x)), error(nil)
}

// String returns a readable string representation of MapType.
func (v MapType) String() string {
	x := (map[string]*Bonk)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes MapType from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *MapType) FromWire(w wire.Value) error {
	x, err := _Map_String_Bonk_Read(w.GetMap())
	*v = (MapType)(x)
	return err
}

// Equals returns true if this MapType is equal to the provided
// MapType.
func (lhs MapType) Equals(rhs MapType) bool {
	return _Map_String_Bonk_Equals((map[string]*Bonk)(lhs), (map[string]*Bonk)(rhs))
}

func (v MapType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return ((_Map_String_Bonk_Zapper)((map[string]*Bonk)(v))).MarshalLogObject(enc)
}

type NestedListsBonk struct {
	Bonk [][][]*Bonk `json:"bonk,omitempty"`
}

type _List_List_Bonk_ValueList [][]*Bonk

func (v _List_List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_Bonk_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_Bonk_ValueList) Close() {}

type _List_List_List_Bonk_ValueList [][][]*Bonk

func (v _List_List_List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_List_Bonk_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_List_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_List_Bonk_ValueList) Close() {}

// ToWire translates a NestedListsBonk struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedListsBonk) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Bonk != nil {
		w, err = wire.NewValueList(_List_List_List_Bonk_ValueList(v.Bonk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_Bonk_Read(l wire.ValueList) ([][]*Bonk, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_Bonk_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_List_List_Bonk_Read(l wire.ValueList) ([][][]*Bonk, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][][]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_List_Bonk_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedListsBonk struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedListsBonk struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedListsBonk
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedListsBonk) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Bonk, err = _List_List_List_Bonk_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedListsBonk
// struct.
func (v *NestedListsBonk) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Bonk != nil {
		fields[i] = fmt.Sprintf("Bonk: %v", v.Bonk)
		i++
	}

	return fmt.Sprintf("NestedListsBonk{%v}", strings.Join(fields[:i], ", "))
}

func _List_List_Bonk_Equals(lhs, rhs [][]*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_Bonk_Equals(lv, rv) {
			return false
		}
	}

	return true
}

func _List_List_List_Bonk_Equals(lhs, rhs [][][]*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_List_Bonk_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedListsBonk match the
// provided NestedListsBonk.
//
// This function performs a deep comparison.
func (v *NestedListsBonk) Equals(rhs *NestedListsBonk) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Bonk == nil && rhs.Bonk == nil) || (v.Bonk != nil && rhs.Bonk != nil && _List_List_List_Bonk_Equals(v.Bonk, rhs.Bonk))) {
		return false
	}

	return true
}

type _List_List_Bonk_Zapper [][]*Bonk

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_List_Bonk_Zapper.
func (l _List_List_Bonk_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_List_Bonk_Zapper)(v)))
	}
	return err
}

type _List_List_List_Bonk_Zapper [][][]*Bonk

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_List_List_Bonk_Zapper.
func (l _List_List_List_Bonk_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_List_List_Bonk_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of NestedListsBonk.
func (v *NestedListsBonk) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Bonk != nil {
		err = multierr.Append(err, enc.AddArray("bonk", (_List_List_List_Bonk_Zapper)(v.Bonk)))
	}
	return err
}

// GetBonk returns the value of Bonk if it is set or its
// zero value if it is unset.
func (v *NestedListsBonk) GetBonk() (o [][][]*Bonk) {
	if v.Bonk != nil {
		return v.Bonk
	}

	return
}

// IsSetBonk returns true if Bonk is not nil.
func (v *NestedListsBonk) IsSetBonk() bool {
	return v.Bonk != nil
}

type NestedListsI32x2 struct {
	Integerlist [][]int32 `json:"integerlist,omitempty"`
}

type _List_List_I32_ValueList [][]int32

func (v _List_List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_List_I32_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_I32_ValueList) Close() {}

// ToWire translates a NestedListsI32x2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedListsI32x2) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Integerlist != nil {
		w, err = wire.NewValueList(_List_List_I32_ValueList(v.Integerlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_I32_Read(l wire.ValueList) ([][]int32, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_I32_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedListsI32x2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedListsI32x2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedListsI32x2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedListsI32x2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Integerlist, err = _List_List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedListsI32x2
// struct.
func (v *NestedListsI32x2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Integerlist != nil {
		fields[i] = fmt.Sprintf("Integerlist: %v", v.Integerlist)
		i++
	}

	return fmt.Sprintf("NestedListsI32x2{%v}", strings.Join(fields[:i], ", "))
}

func _List_List_I32_Equals(lhs, rhs [][]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_I32_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedListsI32x2 match the
// provided NestedListsI32x2.
//
// This function performs a deep comparison.
func (v *NestedListsI32x2) Equals(rhs *NestedListsI32x2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Integerlist == nil && rhs.Integerlist == nil) || (v.Integerlist != nil && rhs.Integerlist != nil && _List_List_I32_Equals(v.Integerlist, rhs.Integerlist))) {
		return false
	}

	return true
}

type _List_List_I32_Zapper [][]int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_List_I32_Zapper.
func (l _List_List_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_List_I32_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of NestedListsI32x2.
func (v *NestedListsI32x2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Integerlist != nil {
		err = multierr.Append(err, enc.AddArray("integerlist", (_List_List_I32_Zapper)(v.Integerlist)))
	}
	return err
}

// GetIntegerlist returns the value of Integerlist if it is set or its
// zero value if it is unset.
func (v *NestedListsI32x2) GetIntegerlist() (o [][]int32) {
	if v.Integerlist != nil {
		return v.Integerlist
	}

	return
}

// IsSetIntegerlist returns true if Integerlist is not nil.
func (v *NestedListsI32x2) IsSetIntegerlist() bool {
	return v.Integerlist != nil
}

type NestedListsI32x3 struct {
	Integerlist [][][]int32 `json:"integerlist,omitempty"`
}

type _List_List_List_I32_ValueList [][][]int32

func (v _List_List_List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_List_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_List_List_I32_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_List_I32_ValueList) Close() {}

// ToWire translates a NestedListsI32x3 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedListsI32x3) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Integerlist != nil {
		w, err = wire.NewValueList(_List_List_List_I32_ValueList(v.Integerlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_List_I32_Read(l wire.ValueList) ([][][]int32, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][][]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_List_I32_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedListsI32x3 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedListsI32x3 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedListsI32x3
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedListsI32x3) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Integerlist, err = _List_List_List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedListsI32x3
// struct.
func (v *NestedListsI32x3) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Integerlist != nil {
		fields[i] = fmt.Sprintf("Integerlist: %v", v.Integerlist)
		i++
	}

	return fmt.Sprintf("NestedListsI32x3{%v}", strings.Join(fields[:i], ", "))
}

func _List_List_List_I32_Equals(lhs, rhs [][][]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_List_I32_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedListsI32x3 match the
// provided NestedListsI32x3.
//
// This function performs a deep comparison.
func (v *NestedListsI32x3) Equals(rhs *NestedListsI32x3) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Integerlist == nil && rhs.Integerlist == nil) || (v.Integerlist != nil && rhs.Integerlist != nil && _List_List_List_I32_Equals(v.Integerlist, rhs.Integerlist))) {
		return false
	}

	return true
}

type _List_List_List_I32_Zapper [][][]int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_List_List_I32_Zapper.
func (l _List_List_List_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_List_List_I32_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of NestedListsI32x3.
func (v *NestedListsI32x3) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Integerlist != nil {
		err = multierr.Append(err, enc.AddArray("integerlist", (_List_List_List_I32_Zapper)(v.Integerlist)))
	}
	return err
}

// GetIntegerlist returns the value of Integerlist if it is set or its
// zero value if it is unset.
func (v *NestedListsI32x3) GetIntegerlist() (o [][][]int32) {
	if v.Integerlist != nil {
		return v.Integerlist
	}

	return
}

// IsSetIntegerlist returns true if Integerlist is not nil.
func (v *NestedListsI32x3) IsSetIntegerlist() bool {
	return v.Integerlist != nil
}

type NestedMixedx2 struct {
	IntSetList       []map[int32]struct{}            `json:"int_set_list,omitempty"`
	MapIntStrset     map[int32]map[string]struct{}   `json:"map_int_strset,omitempty"`
	MapIntStrsetList []map[int32]map[string]struct{} `json:"map_int_strset_list,omitempty"`
}

type _List_Set_I32_ValueList []map[int32]struct{}

func (v _List_Set_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueSet(_Set_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Set_I32_ValueList) Size() int {
	return len(v)
}

func (_List_Set_I32_ValueList) ValueType() wire.Type {
	return wire.TSet
}

func (_List_Set_I32_ValueList) Close() {}

type _Map_I32_Set_String_MapItemList map[int32]map[string]struct{}

func (m _Map_I32_Set_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueSet(_Set_String_ValueList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Set_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Set_String_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Set_String_MapItemList) ValueType() wire.Type {
	return wire.TSet
}

func (_Map_I32_Set_String_MapItemList) Close() {}

type _List_Map_I32_Set_String_ValueList []map[int32]map[string]struct{}

func (v _List_Map_I32_Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_I32_Set_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_I32_Set_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_I32_Set_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_I32_Set_String_ValueList) Close() {}

// ToWire translates a NestedMixedx2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedMixedx2) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.IntSetList != nil {
		w, err = wire.NewValueList(_List_Set_I32_ValueList(v.IntSetList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.MapIntStrset != nil {
		w, err = wire.NewValueMap(_Map_I32_Set_String_MapItemList(v.MapIntStrset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.MapIntStrsetList != nil {
		w, err = wire.NewValueList(_List_Map_I32_Set_String_ValueList(v.MapIntStrsetList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Set_I32_Read(l wire.ValueList) ([]map[int32]struct{}, error) {
	if l.ValueType() != wire.TSet {
		return nil, nil
	}

	o := make([]map[int32]struct{}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Set_I32_Read(x.GetSet())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Map_I32_Set_String_Read(m wire.MapItemList) (map[int32]map[string]struct{}, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TSet {
		return nil, nil
	}

	o := make(map[int32]map[string]struct{}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Set_String_Read(x.Value.GetSet())
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_I32_Set_String_Read(l wire.ValueList) ([]map[int32]map[string]struct{}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([]map[int32]map[string]struct{}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_I32_Set_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedMixedx2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedMixedx2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedMixedx2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedMixedx2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.IntSetList, err = _List_Set_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.MapIntStrset, err = _Map_I32_Set_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.MapIntStrsetList, err = _List_Map_I32_Set_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedMixedx2
// struct.
func (v *NestedMixedx2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.IntSetList != nil {
		fields[i] = fmt.Sprintf("IntSetList: %v", v.IntSetList)
		i++
	}
	if v.MapIntStrset != nil {
		fields[i] = fmt.Sprintf("MapIntStrset: %v", v.MapIntStrset)
		i++
	}
	if v.MapIntStrsetList != nil {
		fields[i] = fmt.Sprintf("MapIntStrsetList: %v", v.MapIntStrsetList)
		i++
	}

	return fmt.Sprintf("NestedMixedx2{%v}", strings.Join(fields[:i], ", "))
}

func _List_Set_I32_Equals(lhs, rhs []map[int32]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Set_I32_Equals(lv, rv) {
			return false
		}
	}

	return true
}

func _Map_I32_Set_String_Equals(lhs, rhs map[int32]map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !_Set_String_Equals(lv, rv) {
			return false
		}
	}
	return true
}

func _List_Map_I32_Set_String_Equals(lhs, rhs []map[int32]map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Map_I32_Set_String_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedMixedx2 match the
// provided NestedMixedx2.
//
// This function performs a deep comparison.
func (v *NestedMixedx2) Equals(rhs *NestedMixedx2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.IntSetList == nil && rhs.IntSetList == nil) || (v.IntSetList != nil && rhs.IntSetList != nil && _List_Set_I32_Equals(v.IntSetList, rhs.IntSetList))) {
		return false
	}
	if !((v.MapIntStrset == nil && rhs.MapIntStrset == nil) || (v.MapIntStrset != nil && rhs.MapIntStrset != nil && _Map_I32_Set_String_Equals(v.MapIntStrset, rhs.MapIntStrset))) {
		return false
	}
	if !((v.MapIntStrsetList == nil && rhs.MapIntStrsetList == nil) || (v.MapIntStrsetList != nil && rhs.MapIntStrsetList != nil && _List_Map_I32_Set_String_Equals(v.MapIntStrsetList, rhs.MapIntStrsetList))) {
		return false
	}

	return true
}

type _List_Set_I32_Zapper []map[int32]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Set_I32_Zapper.
func (l _List_Set_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_Set_I32_Zapper)(v)))
	}
	return err
}

type _Map_I32_Set_String_Item_Zapper struct {
	Key   int32
	Value map[string]struct{}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Set_String_Item_Zapper.
func (v _Map_I32_Set_String_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	err = multierr.Append(err, enc.AddArray("value", (_Set_String_Zapper)(v.Value)))
	return err
}

type _Map_I32_Set_String_Zapper map[int32]map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Set_String_Zapper.
func (m _Map_I32_Set_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_Set_String_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _List_Map_I32_Set_String_Zapper []map[int32]map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Map_I32_Set_String_Zapper.
func (l _List_Map_I32_Set_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_Map_I32_Set_String_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of NestedMixedx2.
func (v *NestedMixedx2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.IntSetList != nil {
		err = multierr.Append(err, enc.AddArray("int_set_list", (_List_Set_I32_Zapper)(v.IntSetList)))
	}
	if v.MapIntStrset != nil {
		err = multierr.Append(err, enc.AddArray("map_int_strset", (_Map_I32_Set_String_Zapper)(v.MapIntStrset)))
	}
	if v.MapIntStrsetList != nil {
		err = multierr.Append(err, enc.AddArray("map_int_strset_list", (_List_Map_I32_Set_String_Zapper)(v.MapIntStrsetList)))
	}
	return err
}

// GetIntSetList returns the value of IntSetList if it is set or its
// zero value if it is unset.
func (v *NestedMixedx2) GetIntSetList() (o []map[int32]struct{}) {
	if v.IntSetList != nil {
		return v.IntSetList
	}

	return
}

// IsSetIntSetList returns true if IntSetList is not nil.
func (v *NestedMixedx2) IsSetIntSetList() bool {
	return v.IntSetList != nil
}

// GetMapIntStrset returns the value of MapIntStrset if it is set or its
// zero value if it is unset.
func (v *NestedMixedx2) GetMapIntStrset() (o map[int32]map[string]struct{}) {
	if v.MapIntStrset != nil {
		return v.MapIntStrset
	}

	return
}

// IsSetMapIntStrset returns true if MapIntStrset is not nil.
func (v *NestedMixedx2) IsSetMapIntStrset() bool {
	return v.MapIntStrset != nil
}

// GetMapIntStrsetList returns the value of MapIntStrsetList if it is set or its
// zero value if it is unset.
func (v *NestedMixedx2) GetMapIntStrsetList() (o []map[int32]map[string]struct{}) {
	if v.MapIntStrsetList != nil {
		return v.MapIntStrsetList
	}

	return
}

// IsSetMapIntStrsetList returns true if MapIntStrsetList is not nil.
func (v *NestedMixedx2) IsSetMapIntStrsetList() bool {
	return v.MapIntStrsetList != nil
}

// Docstring!
type Numberz int32

const (
	NumberzOne   Numberz = 1
	NumberzTwo   Numberz = 2
	NumberzThree Numberz = 3
	NumberzFive  Numberz = 5
	NumberzSix   Numberz = 6
	NumberzEight Numberz = 8
)

// Numberz_Values returns all recognized values of Numberz.
func Numberz_Values() []Numberz {
	return []Numberz{
		NumberzOne,
		NumberzTwo,
		NumberzThree,
		NumberzFive,
		NumberzSix,
		NumberzEight,
	}
}

// UnmarshalText tries to decode Numberz from a byte slice
// containing its name.
//
//   var v Numberz
//   err := v.UnmarshalText([]byte("ONE"))
func (v *Numberz) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "ONE":
		*v = NumberzOne
		return nil
	case "TWO":
		*v = NumberzTwo
		return nil
	case "THREE":
		*v = NumberzThree
		return nil
	case "FIVE":
		*v = NumberzFive
		return nil
	case "SIX":
		*v = NumberzSix
		return nil
	case "EIGHT":
		*v = NumberzEight
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "Numberz", err)
		}
		*v = Numberz(val)
		return nil
	}
}

// MarshalText encodes Numberz to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v Numberz) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 1:
		return []byte("ONE"), nil
	case 2:
		return []byte("TWO"), nil
	case 3:
		return []byte("THREE"), nil
	case 5:
		return []byte("FIVE"), nil
	case 6:
		return []byte("SIX"), nil
	case 8:
		return []byte("EIGHT"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Numberz.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v Numberz) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 1:
		enc.AddString("name", "ONE")
	case 2:
		enc.AddString("name", "TWO")
	case 3:
		enc.AddString("name", "THREE")
	case 5:
		enc.AddString("name", "FIVE")
	case 6:
		enc.AddString("name", "SIX")
	case 8:
		enc.AddString("name", "EIGHT")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v Numberz) Ptr() *Numberz {
	return &v
}

// ToWire translates Numberz into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v Numberz) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes Numberz from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return Numberz(0), err
//   }
//
//   var v Numberz
//   if err := v.FromWire(x); err != nil {
//     return Numberz(0), err
//   }
//   return v, nil
func (v *Numberz) FromWire(w wire.Value) error {
	*v = (Numberz)(w.GetI32())
	return nil
}

// String returns a readable string representation of Numberz.
func (v Numberz) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "ONE"
	case 2:
		return "TWO"
	case 3:
		return "THREE"
	case 5:
		return "FIVE"
	case 6:
		return "SIX"
	case 8:
		return "EIGHT"
	}
	return fmt.Sprintf("Numberz(%d)", w)
}

// Equals returns true if this Numberz value matches the provided
// value.
func (v Numberz) Equals(rhs Numberz) bool {
	return v == rhs
}

// MarshalJSON serializes Numberz into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v Numberz) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"ONE\""), nil
	case 2:
		return ([]byte)("\"TWO\""), nil
	case 3:
		return ([]byte)("\"THREE\""), nil
	case 5:
		return ([]byte)("\"FIVE\""), nil
	case 6:
		return ([]byte)("\"SIX\""), nil
	case 8:
		return ([]byte)("\"EIGHT\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode Numberz from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *Numberz) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Numberz")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Numberz")
		}
		*v = (Numberz)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Numberz")
	}
}

type OneField struct {
	Field *EmptyStruct `json:"field,omitempty"`
}

// ToWire translates a OneField struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *OneField) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Field != nil {
		w, err = v.Field.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EmptyStruct_Read(w wire.Value) (*EmptyStruct, error) {
	var v EmptyStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a OneField struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a OneField struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v OneField
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *OneField) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Field, err = _EmptyStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a OneField
// struct.
func (v *OneField) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Field != nil {
		fields[i] = fmt.Sprintf("Field: %v", v.Field)
		i++
	}

	return fmt.Sprintf("OneField{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this OneField match the
// provided OneField.
//
// This function performs a deep comparison.
func (v *OneField) Equals(rhs *OneField) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Field == nil && rhs.Field == nil) || (v.Field != nil && rhs.Field != nil && v.Field.Equals(rhs.Field))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of OneField.
func (v *OneField) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Field != nil {
		err = multierr.Append(err, enc.AddObject("field", v.Field))
	}
	return err
}

// GetField returns the value of Field if it is set or its
// zero value if it is unset.
func (v *OneField) GetField() (o *EmptyStruct) {
	if v.Field != nil {
		return v.Field
	}

	return
}

// IsSetField returns true if Field is not nil.
func (v *OneField) IsSetField() bool {
	return v.Field != nil
}

type StructA struct {
	S string `json:"s,required"`
}

// ToWire translates a StructA struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StructA) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.S), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StructA struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StructA struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StructA
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StructA) FromWire(w wire.Value) error {
	var err error

	sIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.S, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				sIsSet = true
			}
		}
	}

	if !sIsSet {
		return errors.New("field S of StructA is required")
	}

	return nil
}

// String returns a readable string representation of a StructA
// struct.
func (v *StructA) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("S: %v", v.S)
	i++

	return fmt.Sprintf("StructA{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StructA match the
// provided StructA.
//
// This function performs a deep comparison.
func (v *StructA) Equals(rhs *StructA) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.S == rhs.S) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StructA.
func (v *StructA) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("s", v.S)
	return err
}

// GetS returns the value of S if it is set or its
// zero value if it is unset.
func (v *StructA) GetS() (o string) { return v.S }

type StructB struct {
	Aa *StructA `json:"aa,omitempty"`
	Ab *StructA `json:"ab,required"`
}

// ToWire translates a StructB struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StructB) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Aa != nil {
		w, err = v.Aa.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Ab == nil {
		return w, errors.New("field Ab of StructB is required")
	}
	w, err = v.Ab.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _StructA_Read(w wire.Value) (*StructA, error) {
	var v StructA
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a StructB struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StructB struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StructB
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StructB) FromWire(w wire.Value) error {
	var err error

	abIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Aa, err = _StructA_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Ab, err = _StructA_Read(field.Value)
				if err != nil {
					return err
				}
				abIsSet = true
			}
		}
	}

	if !abIsSet {
		return errors.New("field Ab of StructB is required")
	}

	return nil
}

// String returns a readable string representation of a StructB
// struct.
func (v *StructB) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Aa != nil {
		fields[i] = fmt.Sprintf("Aa: %v", v.Aa)
		i++
	}
	fields[i] = fmt.Sprintf("Ab: %v", v.Ab)
	i++

	return fmt.Sprintf("StructB{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StructB match the
// provided StructB.
//
// This function performs a deep comparison.
func (v *StructB) Equals(rhs *StructB) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Aa == nil && rhs.Aa == nil) || (v.Aa != nil && rhs.Aa != nil && v.Aa.Equals(rhs.Aa))) {
		return false
	}
	if !v.Ab.Equals(rhs.Ab) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StructB.
func (v *StructB) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Aa != nil {
		err = multierr.Append(err, enc.AddObject("aa", v.Aa))
	}
	err = multierr.Append(err, enc.AddObject("ab", v.Ab))
	return err
}

// GetAa returns the value of Aa if it is set or its
// zero value if it is unset.
func (v *StructB) GetAa() (o *StructA) {
	if v.Aa != nil {
		return v.Aa
	}

	return
}

// IsSetAa returns true if Aa is not nil.
func (v *StructB) IsSetAa() bool {
	return v.Aa != nil
}

// GetAb returns the value of Ab if it is set or its
// zero value if it is unset.
func (v *StructB) GetAb() (o *StructA) { return v.Ab }

// IsSetAb returns true if Ab is not nil.
func (v *StructB) IsSetAb() bool {
	return v.Ab != nil
}

type UserId int64

// ToWire translates UserId into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v UserId) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

// String returns a readable string representation of UserId.
func (v UserId) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes UserId from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *UserId) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (UserId)(x)
	return err
}

// Equals returns true if this UserId is equal to the provided
// UserId.
func (lhs UserId) Equals(rhs UserId) bool {
	return ((int64)(lhs) == (int64)(rhs))
}

type VersioningTestV1 struct {
	BeginInBoth *int32  `json:"begin_in_both,omitempty"`
	OldString   *string `json:"old_string,omitempty"`
	EndInBoth   *int32  `json:"end_in_both,omitempty"`
}

// ToWire translates a VersioningTestV1 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *VersioningTestV1) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BeginInBoth != nil {
		w, err = wire.NewValueI32(*(v.BeginInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.OldString != nil {
		w, err = wire.NewValueString(*(v.OldString)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.EndInBoth != nil {
		w, err = wire.NewValueI32(*(v.EndInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a VersioningTestV1 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a VersioningTestV1 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v VersioningTestV1
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *VersioningTestV1) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BeginInBoth = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.OldString = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EndInBoth = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a VersioningTestV1
// struct.
func (v *VersioningTestV1) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.BeginInBoth != nil {
		fields[i] = fmt.Sprintf("BeginInBoth: %v", *(v.BeginInBoth))
		i++
	}
	if v.OldString != nil {
		fields[i] = fmt.Sprintf("OldString: %v", *(v.OldString))
		i++
	}
	if v.EndInBoth != nil {
		fields[i] = fmt.Sprintf("EndInBoth: %v", *(v.EndInBoth))
		i++
	}

	return fmt.Sprintf("VersioningTestV1{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this VersioningTestV1 match the
// provided VersioningTestV1.
//
// This function performs a deep comparison.
func (v *VersioningTestV1) Equals(rhs *VersioningTestV1) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.BeginInBoth, rhs.BeginInBoth) {
		return false
	}
	if !_String_EqualsPtr(v.OldString, rhs.OldString) {
		return false
	}
	if !_I32_EqualsPtr(v.EndInBoth, rhs.EndInBoth) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of VersioningTestV1.
func (v *VersioningTestV1) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BeginInBoth != nil {
		enc.AddInt32("begin_in_both", *v.BeginInBoth)
	}
	if v.OldString != nil {
		enc.AddString("old_string", *v.OldString)
	}
	if v.EndInBoth != nil {
		enc.AddInt32("end_in_both", *v.EndInBoth)
	}
	return err
}

// GetBeginInBoth returns the value of BeginInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV1) GetBeginInBoth() (o int32) {
	if v.BeginInBoth != nil {
		return *v.BeginInBoth
	}

	return
}

// IsSetBeginInBoth returns true if BeginInBoth is not nil.
func (v *VersioningTestV1) IsSetBeginInBoth() bool {
	return v.BeginInBoth != nil
}

// GetOldString returns the value of OldString if it is set or its
// zero value if it is unset.
func (v *VersioningTestV1) GetOldString() (o string) {
	if v.OldString != nil {
		return *v.OldString
	}

	return
}

// IsSetOldString returns true if OldString is not nil.
func (v *VersioningTestV1) IsSetOldString() bool {
	return v.OldString != nil
}

// GetEndInBoth returns the value of EndInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV1) GetEndInBoth() (o int32) {
	if v.EndInBoth != nil {
		return *v.EndInBoth
	}

	return
}

// IsSetEndInBoth returns true if EndInBoth is not nil.
func (v *VersioningTestV1) IsSetEndInBoth() bool {
	return v.EndInBoth != nil
}

type VersioningTestV2 struct {
	BeginInBoth *int32             `json:"begin_in_both,omitempty"`
	Newint      *int32             `json:"newint,omitempty"`
	Newbyte     *int8              `json:"newbyte,omitempty"`
	Newshort    *int16             `json:"newshort,omitempty"`
	Newlong     *int64             `json:"newlong,omitempty"`
	Newdouble   *float64           `json:"newdouble,omitempty"`
	Newstruct   *Bonk              `json:"newstruct,omitempty"`
	Newlist     []int32            `json:"newlist,omitempty"`
	Newset      map[int32]struct{} `json:"newset,omitempty"`
	Newmap      map[int32]int32    `json:"newmap,omitempty"`
	Newstring   *string            `json:"newstring,omitempty"`
	EndInBoth   *int32             `json:"end_in_both,omitempty"`
}

type _Map_I32_I32_MapItemList map[int32]int32

func (m _Map_I32_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI32(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_I32_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_I32_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_I32_I32_MapItemList) Close() {}

// ToWire translates a VersioningTestV2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *VersioningTestV2) ToWire() (wire.Value, error) {
	var (
		fields [12]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BeginInBoth != nil {
		w, err = wire.NewValueI32(*(v.BeginInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Newint != nil {
		w, err = wire.NewValueI32(*(v.Newint)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Newbyte != nil {
		w, err = wire.NewValueI8(*(v.Newbyte)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Newshort != nil {
		w, err = wire.NewValueI16(*(v.Newshort)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Newlong != nil {
		w, err = wire.NewValueI64(*(v.Newlong)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Newdouble != nil {
		w, err = wire.NewValueDouble(*(v.Newdouble)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.Newstruct != nil {
		w, err = v.Newstruct.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.Newlist != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Newlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}
	if v.Newset != nil {
		w, err = wire.NewValueSet(_Set_I32_ValueList(v.Newset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.Newmap != nil {
		w, err = wire.NewValueMap(_Map_I32_I32_MapItemList(v.Newmap)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Newstring != nil {
		w, err = wire.NewValueString(*(v.Newstring)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	if v.EndInBoth != nil {
		w, err = wire.NewValueI32(*(v.EndInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_I32_I32_Read(m wire.MapItemList) (map[int32]int32, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[int32]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a VersioningTestV2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a VersioningTestV2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v VersioningTestV2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *VersioningTestV2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BeginInBoth = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Newint = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.Newbyte = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Newshort = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Newlong = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.Newdouble = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.Newstruct, err = _Bonk_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TList {
				v.Newlist, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TSet {
				v.Newset, err = _Set_I32_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 10:
			if field.Value.Type() == wire.TMap {
				v.Newmap, err = _Map_I32_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Newstring = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EndInBoth = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a VersioningTestV2
// struct.
func (v *VersioningTestV2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [12]string
	i := 0
	if v.BeginInBoth != nil {
		fields[i] = fmt.Sprintf("BeginInBoth: %v", *(v.BeginInBoth))
		i++
	}
	if v.Newint != nil {
		fields[i] = fmt.Sprintf("Newint: %v", *(v.Newint))
		i++
	}
	if v.Newbyte != nil {
		fields[i] = fmt.Sprintf("Newbyte: %v", *(v.Newbyte))
		i++
	}
	if v.Newshort != nil {
		fields[i] = fmt.Sprintf("Newshort: %v", *(v.Newshort))
		i++
	}
	if v.Newlong != nil {
		fields[i] = fmt.Sprintf("Newlong: %v", *(v.Newlong))
		i++
	}
	if v.Newdouble != nil {
		fields[i] = fmt.Sprintf("Newdouble: %v", *(v.Newdouble))
		i++
	}
	if v.Newstruct != nil {
		fields[i] = fmt.Sprintf("Newstruct: %v", v.Newstruct)
		i++
	}
	if v.Newlist != nil {
		fields[i] = fmt.Sprintf("Newlist: %v", v.Newlist)
		i++
	}
	if v.Newset != nil {
		fields[i] = fmt.Sprintf("Newset: %v", v.Newset)
		i++
	}
	if v.Newmap != nil {
		fields[i] = fmt.Sprintf("Newmap: %v", v.Newmap)
		i++
	}
	if v.Newstring != nil {
		fields[i] = fmt.Sprintf("Newstring: %v", *(v.Newstring))
		i++
	}
	if v.EndInBoth != nil {
		fields[i] = fmt.Sprintf("EndInBoth: %v", *(v.EndInBoth))
		i++
	}

	return fmt.Sprintf("VersioningTestV2{%v}", strings.Join(fields[:i], ", "))
}

func _Byte_EqualsPtr(lhs, rhs *int8) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I16_EqualsPtr(lhs, rhs *int16) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Map_I32_I32_Equals(lhs, rhs map[int32]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this VersioningTestV2 match the
// provided VersioningTestV2.
//
// This function performs a deep comparison.
func (v *VersioningTestV2) Equals(rhs *VersioningTestV2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.BeginInBoth, rhs.BeginInBoth) {
		return false
	}
	if !_I32_EqualsPtr(v.Newint, rhs.Newint) {
		return false
	}
	if !_Byte_EqualsPtr(v.Newbyte, rhs.Newbyte) {
		return false
	}
	if !_I16_EqualsPtr(v.Newshort, rhs.Newshort) {
		return false
	}
	if !_I64_EqualsPtr(v.Newlong, rhs.Newlong) {
		return false
	}
	if !_Double_EqualsPtr(v.Newdouble, rhs.Newdouble) {
		return false
	}
	if !((v.Newstruct == nil && rhs.Newstruct == nil) || (v.Newstruct != nil && rhs.Newstruct != nil && v.Newstruct.Equals(rhs.Newstruct))) {
		return false
	}
	if !((v.Newlist == nil && rhs.Newlist == nil) || (v.Newlist != nil && rhs.Newlist != nil && _List_I32_Equals(v.Newlist, rhs.Newlist))) {
		return false
	}
	if !((v.Newset == nil && rhs.Newset == nil) || (v.Newset != nil && rhs.Newset != nil && _Set_I32_Equals(v.Newset, rhs.Newset))) {
		return false
	}
	if !((v.Newmap == nil && rhs.Newmap == nil) || (v.Newmap != nil && rhs.Newmap != nil && _Map_I32_I32_Equals(v.Newmap, rhs.Newmap))) {
		return false
	}
	if !_String_EqualsPtr(v.Newstring, rhs.Newstring) {
		return false
	}
	if !_I32_EqualsPtr(v.EndInBoth, rhs.EndInBoth) {
		return false
	}

	return true
}

type _Map_I32_I32_Item_Zapper struct {
	Key   int32
	Value int32
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_I32_Item_Zapper.
func (v _Map_I32_I32_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	enc.AddInt32("value", v.Value)
	return err
}

type _Map_I32_I32_Zapper map[int32]int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_I32_Zapper.
func (m _Map_I32_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_I32_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of VersioningTestV2.
func (v *VersioningTestV2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BeginInBoth != nil {
		enc.AddInt32("begin_in_both", *v.BeginInBoth)
	}
	if v.Newint != nil {
		enc.AddInt32("newint", *v.Newint)
	}
	if v.Newbyte != nil {
		enc.AddInt8("newbyte", *v.Newbyte)
	}
	if v.Newshort != nil {
		enc.AddInt16("newshort", *v.Newshort)
	}
	if v.Newlong != nil {
		enc.AddInt64("newlong", *v.Newlong)
	}
	if v.Newdouble != nil {
		enc.AddFloat64("newdouble", *v.Newdouble)
	}
	if v.Newstruct != nil {
		err = multierr.Append(err, enc.AddObject("newstruct", v.Newstruct))
	}
	if v.Newlist != nil {
		err = multierr.Append(err, enc.AddArray("newlist", (_List_I32_Zapper)(v.Newlist)))
	}
	if v.Newset != nil {
		err = multierr.Append(err, enc.AddArray("newset", (_Set_I32_Zapper)(v.Newset)))
	}
	if v.Newmap != nil {
		err = multierr.Append(err, enc.AddArray("newmap", (_Map_I32_I32_Zapper)(v.Newmap)))
	}
	if v.Newstring != nil {
		enc.AddString("newstring", *v.Newstring)
	}
	if v.EndInBoth != nil {
		enc.AddInt32("end_in_both", *v.EndInBoth)
	}
	return err
}

// GetBeginInBoth returns the value of BeginInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetBeginInBoth() (o int32) {
	if v.BeginInBoth != nil {
		return *v.BeginInBoth
	}

	return
}

// IsSetBeginInBoth returns true if BeginInBoth is not nil.
func (v *VersioningTestV2) IsSetBeginInBoth() bool {
	return v.BeginInBoth != nil
}

// GetNewint returns the value of Newint if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewint() (o int32) {
	if v.Newint != nil {
		return *v.Newint
	}

	return
}

// IsSetNewint returns true if Newint is not nil.
func (v *VersioningTestV2) IsSetNewint() bool {
	return v.Newint != nil
}

// GetNewbyte returns the value of Newbyte if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewbyte() (o int8) {
	if v.Newbyte != nil {
		return *v.Newbyte
	}

	return
}

// IsSetNewbyte returns true if Newbyte is not nil.
func (v *VersioningTestV2) IsSetNewbyte() bool {
	return v.Newbyte != nil
}

// GetNewshort returns the value of Newshort if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewshort() (o int16) {
	if v.Newshort != nil {
		return *v.Newshort
	}

	return
}

// IsSetNewshort returns true if Newshort is not nil.
func (v *VersioningTestV2) IsSetNewshort() bool {
	return v.Newshort != nil
}

// GetNewlong returns the value of Newlong if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewlong() (o int64) {
	if v.Newlong != nil {
		return *v.Newlong
	}

	return
}

// IsSetNewlong returns true if Newlong is not nil.
func (v *VersioningTestV2) IsSetNewlong() bool {
	return v.Newlong != nil
}

// GetNewdouble returns the value of Newdouble if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewdouble() (o float64) {
	if v.Newdouble != nil {
		return *v.Newdouble
	}

	return
}

// IsSetNewdouble returns true if Newdouble is not nil.
func (v *VersioningTestV2) IsSetNewdouble() bool {
	return v.Newdouble != nil
}

// GetNewstruct returns the value of Newstruct if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewstruct() (o *Bonk) {
	if v.Newstruct != nil {
		return v.Newstruct
	}

	return
}

// IsSetNewstruct returns true if Newstruct is not nil.
func (v *VersioningTestV2) IsSetNewstruct() bool {
	return v.Newstruct != nil
}

// GetNewlist returns the value of Newlist if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewlist() (o []int32) {
	if v.Newlist != nil {
		return v.Newlist
	}

	return
}

// IsSetNewlist returns true if Newlist is not nil.
func (v *VersioningTestV2) IsSetNewlist() bool {
	return v.Newlist != nil
}

// GetNewset returns the value of Newset if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewset() (o map[int32]struct{}) {
	if v.Newset != nil {
		return v.Newset
	}

	return
}

// IsSetNewset returns true if Newset is not nil.
func (v *VersioningTestV2) IsSetNewset() bool {
	return v.Newset != nil
}

// GetNewmap returns the value of Newmap if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewmap() (o map[int32]int32) {
	if v.Newmap != nil {
		return v.Newmap
	}

	return
}

// IsSetNewmap returns true if Newmap is not nil.
func (v *VersioningTestV2) IsSetNewmap() bool {
	return v.Newmap != nil
}

// GetNewstring returns the value of Newstring if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewstring() (o string) {
	if v.Newstring != nil {
		return *v.Newstring
	}

	return
}

// IsSetNewstring returns true if Newstring is not nil.
func (v *VersioningTestV2) IsSetNewstring() bool {
	return v.Newstring != nil
}

// GetEndInBoth returns the value of EndInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetEndInBoth() (o int32) {
	if v.EndInBoth != nil {
		return *v.EndInBoth
	}

	return
}

// IsSetEndInBoth returns true if EndInBoth is not nil.
func (v *VersioningTestV2) IsSetEndInBoth() bool {
	return v.EndInBoth != nil
}

type Xception struct {
	ErrorCode *int32  `json:"errorCode,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// ToWire translates a Xception struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xception) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xception struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xception struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xception
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xception) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xception
// struct.
func (v *Xception) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}

	return fmt.Sprintf("Xception{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xception match the
// provided Xception.
//
// This function performs a deep comparison.
func (v *Xception) Equals(rhs *Xception) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xception.
func (v *Xception) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ErrorCode != nil {
		enc.AddInt32("errorCode", *v.ErrorCode)
	}
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	return err
}

// GetErrorCode returns the value of ErrorCode if it is set or its
// zero value if it is unset.
func (v *Xception) GetErrorCode() (o int32) {
	if v.ErrorCode != nil {
		return *v.ErrorCode
	}

	return
}

// IsSetErrorCode returns true if ErrorCode is not nil.
func (v *Xception) IsSetErrorCode() bool {
	return v.ErrorCode != nil
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *Xception) GetMessage() (o string) {
	if v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *Xception) IsSetMessage() bool {
	return v.Message != nil
}

func (v *Xception) Error() string {
	return v.String()
}

type Xception2 struct {
	ErrorCode   *int32  `json:"errorCode,omitempty"`
	StructThing *Xtruct `json:"struct_thing,omitempty"`
}

// ToWire translates a Xception2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xception2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StructThing != nil {
		w, err = v.StructThing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xception2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xception2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xception2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xception2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.StructThing, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xception2
// struct.
func (v *Xception2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	if v.StructThing != nil {
		fields[i] = fmt.Sprintf("StructThing: %v", v.StructThing)
		i++
	}

	return fmt.Sprintf("Xception2{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xception2 match the
// provided Xception2.
//
// This function performs a deep comparison.
func (v *Xception2) Equals(rhs *Xception2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}
	if !((v.StructThing == nil && rhs.StructThing == nil) || (v.StructThing != nil && rhs.StructThing != nil && v.StructThing.Equals(rhs.StructThing))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xception2.
func (v *Xception2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ErrorCode != nil {
		enc.AddInt32("errorCode", *v.ErrorCode)
	}
	if v.StructThing != nil {
		err = multierr.Append(err, enc.AddObject("struct_thing", v.StructThing))
	}
	return err
}

// GetErrorCode returns the value of ErrorCode if it is set or its
// zero value if it is unset.
func (v *Xception2) GetErrorCode() (o int32) {
	if v.ErrorCode != nil {
		return *v.ErrorCode
	}

	return
}

// IsSetErrorCode returns true if ErrorCode is not nil.
func (v *Xception2) IsSetErrorCode() bool {
	return v.ErrorCode != nil
}

// GetStructThing returns the value of StructThing if it is set or its
// zero value if it is unset.
func (v *Xception2) GetStructThing() (o *Xtruct) {
	if v.StructThing != nil {
		return v.StructThing
	}

	return
}

// IsSetStructThing returns true if StructThing is not nil.
func (v *Xception2) IsSetStructThing() bool {
	return v.StructThing != nil
}

func (v *Xception2) Error() string {
	return v.String()
}

type Xtruct struct {
	StringThing *string `json:"string_thing,omitempty"`
	ByteThing   *int8   `json:"byte_thing,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
	I64Thing    *int64  `json:"i64_thing,omitempty"`
}

// ToWire translates a Xtruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xtruct) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StringThing != nil {
		w, err = wire.NewValueString(*(v.StringThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ByteThing != nil {
		w, err = wire.NewValueI8(*(v.ByteThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.I64Thing != nil {
		w, err = wire.NewValueI64(*(v.I64Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xtruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xtruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xtruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xtruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringThing = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteThing = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.I64Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xtruct
// struct.
func (v *Xtruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.StringThing != nil {
		fields[i] = fmt.Sprintf("StringThing: %v", *(v.StringThing))
		i++
	}
	if v.ByteThing != nil {
		fields[i] = fmt.Sprintf("ByteThing: %v", *(v.ByteThing))
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}
	if v.I64Thing != nil {
		fields[i] = fmt.Sprintf("I64Thing: %v", *(v.I64Thing))
		i++
	}

	return fmt.Sprintf("Xtruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xtruct match the
// provided Xtruct.
//
// This function performs a deep comparison.
func (v *Xtruct) Equals(rhs *Xtruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.StringThing, rhs.StringThing) {
		return false
	}
	if !_Byte_EqualsPtr(v.ByteThing, rhs.ByteThing) {
		return false
	}
	if !_I32_EqualsPtr(v.I32Thing, rhs.I32Thing) {
		return false
	}
	if !_I64_EqualsPtr(v.I64Thing, rhs.I64Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xtruct.
func (v *Xtruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.StringThing != nil {
		enc.AddString("string_thing", *v.StringThing)
	}
	if v.ByteThing != nil {
		enc.AddInt8("byte_thing", *v.ByteThing)
	}
	if v.I32Thing != nil {
		enc.AddInt32("i32_thing", *v.I32Thing)
	}
	if v.I64Thing != nil {
		enc.AddInt64("i64_thing", *v.I64Thing)
	}
	return err
}

// GetStringThing returns the value of StringThing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetStringThing() (o string) {
	if v.StringThing != nil {
		return *v.StringThing
	}

	return
}

// IsSetStringThing returns true if StringThing is not nil.
func (v *Xtruct) IsSetStringThing() bool {
	return v.StringThing != nil
}

// GetByteThing returns the value of ByteThing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetByteThing() (o int8) {
	if v.ByteThing != nil {
		return *v.ByteThing
	}

	return
}

// IsSetByteThing returns true if ByteThing is not nil.
func (v *Xtruct) IsSetByteThing() bool {
	return v.ByteThing != nil
}

// GetI32Thing returns the value of I32Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetI32Thing() (o int32) {
	if v.I32Thing != nil {
		return *v.I32Thing
	}

	return
}

// IsSetI32Thing returns true if I32Thing is not nil.
func (v *Xtruct) IsSetI32Thing() bool {
	return v.I32Thing != nil
}

// GetI64Thing returns the value of I64Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetI64Thing() (o int64) {
	if v.I64Thing != nil {
		return *v.I64Thing
	}

	return
}

// IsSetI64Thing returns true if I64Thing is not nil.
func (v *Xtruct) IsSetI64Thing() bool {
	return v.I64Thing != nil
}

type Xtruct2 struct {
	ByteThing   *int8   `json:"byte_thing,omitempty"`
	StructThing *Xtruct `json:"struct_thing,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
}

// ToWire translates a Xtruct2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xtruct2) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ByteThing != nil {
		w, err = wire.NewValueI8(*(v.ByteThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StructThing != nil {
		w, err = v.StructThing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xtruct2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xtruct2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xtruct2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xtruct2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteThing = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.StructThing, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xtruct2
// struct.
func (v *Xtruct2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ByteThing != nil {
		fields[i] = fmt.Sprintf("ByteThing: %v", *(v.ByteThing))
		i++
	}
	if v.StructThing != nil {
		fields[i] = fmt.Sprintf("StructThing: %v", v.StructThing)
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}

	return fmt.Sprintf("Xtruct2{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xtruct2 match the
// provided Xtruct2.
//
// This function performs a deep comparison.
func (v *Xtruct2) Equals(rhs *Xtruct2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Byte_EqualsPtr(v.ByteThing, rhs.ByteThing) {
		return false
	}
	if !((v.StructThing == nil && rhs.StructThing == nil) || (v.StructThing != nil && rhs.StructThing != nil && v.StructThing.Equals(rhs.StructThing))) {
		return false
	}
	if !_I32_EqualsPtr(v.I32Thing, rhs.I32Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xtruct2.
func (v *Xtruct2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ByteThing != nil {
		enc.AddInt8("byte_thing", *v.ByteThing)
	}
	if v.StructThing != nil {
		err = multierr.Append(err, enc.AddObject("struct_thing", v.StructThing))
	}
	if v.I32Thing != nil {
		enc.AddInt32("i32_thing", *v.I32Thing)
	}
	return err
}

// GetByteThing returns the value of ByteThing if it is set or its
// zero value if it is unset.
func (v *Xtruct2) GetByteThing() (o int8) {
	if v.ByteThing != nil {
		return *v.ByteThing
	}

	return
}

// IsSetByteThing returns true if ByteThing is not nil.
func (v *Xtruct2) IsSetByteThing() bool {
	return v.ByteThing != nil
}

// GetStructThing returns the value of StructThing if it is set or its
// zero value if it is unset.
func (v *Xtruct2) GetStructThing() (o *Xtruct) {
	if v.StructThing != nil {
		return v.StructThing
	}

	return
}

// IsSetStructThing returns true if StructThing is not nil.
func (v *Xtruct2) IsSetStructThing() bool {
	return v.StructThing != nil
}

// GetI32Thing returns the value of I32Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct2) GetI32Thing() (o int32) {
	if v.I32Thing != nil {
		return *v.I32Thing
	}

	return
}

// IsSetI32Thing returns true if I32Thing is not nil.
func (v *Xtruct2) IsSetI32Thing() bool {
	return v.I32Thing != nil
}

type Xtruct3 struct {
	StringThing *string `json:"string_thing,omitempty"`
	Changed     *int32  `json:"changed,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
	I64Thing    *int64  `json:"i64_thing,omitempty"`
}

// ToWire translates a Xtruct3 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xtruct3) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StringThing != nil {
		w, err = wire.NewValueString(*(v.StringThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Changed != nil {
		w, err = wire.NewValueI32(*(v.Changed)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.I64Thing != nil {
		w, err = wire.NewValueI64(*(v.I64Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xtruct3 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xtruct3 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xtruct3
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xtruct3) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringThing = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Changed = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.I64Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xtruct3
// struct.
func (v *Xtruct3) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.StringThing != nil {
		fields[i] = fmt.Sprintf("StringThing: %v", *(v.StringThing))
		i++
	}
	if v.Changed != nil {
		fields[i] = fmt.Sprintf("Changed: %v", *(v.Changed))
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}
	if v.I64Thing != nil {
		fields[i] = fmt.Sprintf("I64Thing: %v", *(v.I64Thing))
		i++
	}

	return fmt.Sprintf("Xtruct3{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xtruct3 match the
// provided Xtruct3.
//
// This function performs a deep comparison.
func (v *Xtruct3) Equals(rhs *Xtruct3) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.StringThing, rhs.StringThing) {
		return false
	}
	if !_I32_EqualsPtr(v.Changed, rhs.Changed) {
		return false
	}
	if !_I32_EqualsPtr(v.I32Thing, rhs.I32Thing) {
		return false
	}
	if !_I64_EqualsPtr(v.I64Thing, rhs.I64Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xtruct3.
func (v *Xtruct3) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.StringThing != nil {
		enc.AddString("string_thing", *v.StringThing)
	}
	if v.Changed != nil {
		enc.AddInt32("changed", *v.Changed)
	}
	if v.I32Thing != nil {
		enc.AddInt32("i32_thing", *v.I32Thing)
	}
	if v.I64Thing != nil {
		enc.AddInt64("i64_thing", *v.I64Thing)
	}
	return err
}

// GetStringThing returns the value of StringThing if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetStringThing() (o string) {
	if v.StringThing != nil {
		return *v.StringThing
	}

	return
}

// IsSetStringThing returns true if StringThing is not nil.
func (v *Xtruct3) IsSetStringThing() bool {
	return v.StringThing != nil
}

// GetChanged returns the value of Changed if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetChanged() (o int32) {
	if v.Changed != nil {
		return *v.Changed
	}

	return
}

// IsSetChanged returns true if Changed is not nil.
func (v *Xtruct3) IsSetChanged() bool {
	return v.Changed != nil
}

// GetI32Thing returns the value of I32Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetI32Thing() (o int32) {
	if v.I32Thing != nil {
		return *v.I32Thing
	}

	return
}

// IsSetI32Thing returns true if I32Thing is not nil.
func (v *Xtruct3) IsSetI32Thing() bool {
	return v.I32Thing != nil
}

// GetI64Thing returns the value of I64Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetI64Thing() (o int64) {
	if v.I64Thing != nil {
		return *v.I64Thing
	}

	return
}

// IsSetI64Thing returns true if I64Thing is not nil.
func (v *Xtruct3) IsSetI64Thing() bool {
	return v.I64Thing != nil
}
