// Code generated by thriftrw v1.7.0. DO NOT EDIT.
// @generated

// Copyright (c) 2017 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package gauntlet

import (
	"bytes"
	"encoding/json"
	"errors"
	"fmt"
	"go.uber.org/thriftrw/ptr"
	"go.uber.org/thriftrw/wire"
	"math"
	"strconv"
	"strings"
)

type Bonk struct {
	Message *string `json:"message,omitempty"`
	Type    *int32  `json:"type,omitempty"`
}

// ToWire translates a Bonk struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bonk) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = wire.NewValueI32(*(v.Type)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bonk struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bonk struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bonk
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bonk) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Type = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Bonk
// struct.
func (v *Bonk) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", *(v.Type))
		i++
	}

	return fmt.Sprintf("Bonk{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Bonk match the
// provided Bonk.
//
// This function performs a deep comparison.
func (v *Bonk) Equals(rhs *Bonk) bool {
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_I32_EqualsPtr(v.Type, rhs.Type) {
		return false
	}

	return true
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *Bonk) GetMessage() (o string) {
	if v.Message != nil {
		return *v.Message
	}

	return
}

// GetType returns the value of Type if it is set or its
// zero value if it is unset.
func (v *Bonk) GetType() (o int32) {
	if v.Type != nil {
		return *v.Type
	}

	return
}

type BoolTest struct {
	B *bool   `json:"b,omitempty"`
	S *string `json:"s,omitempty"`
}

// ToWire translates a BoolTest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BoolTest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.B == nil {
		v.B = ptr.Bool(true)
	}
	{
		w, err = wire.NewValueBool(*(v.B)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.S == nil {
		v.S = ptr.String("true")
	}
	{
		w, err = wire.NewValueString(*(v.S)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a BoolTest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BoolTest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BoolTest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BoolTest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.B = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.S = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if v.B == nil {
		v.B = ptr.Bool(true)
	}

	if v.S == nil {
		v.S = ptr.String("true")
	}

	return nil
}

// String returns a readable string representation of a BoolTest
// struct.
func (v *BoolTest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.B != nil {
		fields[i] = fmt.Sprintf("B: %v", *(v.B))
		i++
	}
	if v.S != nil {
		fields[i] = fmt.Sprintf("S: %v", *(v.S))
		i++
	}

	return fmt.Sprintf("BoolTest{%v}", strings.Join(fields[:i], ", "))
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this BoolTest match the
// provided BoolTest.
//
// This function performs a deep comparison.
func (v *BoolTest) Equals(rhs *BoolTest) bool {
	if !_Bool_EqualsPtr(v.B, rhs.B) {
		return false
	}
	if !_String_EqualsPtr(v.S, rhs.S) {
		return false
	}

	return true
}

// GetB returns the value of B if it is set or its
// zero value if it is unset.
func (v *BoolTest) GetB() (o bool) {
	if v.B != nil {
		return *v.B
	}
	o = true
	return
}

// GetS returns the value of S if it is set or its
// zero value if it is unset.
func (v *BoolTest) GetS() (o string) {
	if v.S != nil {
		return *v.S
	}
	o = "true"
	return
}

type Bools struct {
	ImTrue  *bool `json:"im_true,omitempty"`
	ImFalse *bool `json:"im_false,omitempty"`
}

// ToWire translates a Bools struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bools) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ImTrue != nil {
		w, err = wire.NewValueBool(*(v.ImTrue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ImFalse != nil {
		w, err = wire.NewValueBool(*(v.ImFalse)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bools struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bools struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bools
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bools) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ImTrue = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ImFalse = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Bools
// struct.
func (v *Bools) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ImTrue != nil {
		fields[i] = fmt.Sprintf("ImTrue: %v", *(v.ImTrue))
		i++
	}
	if v.ImFalse != nil {
		fields[i] = fmt.Sprintf("ImFalse: %v", *(v.ImFalse))
		i++
	}

	return fmt.Sprintf("Bools{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bools match the
// provided Bools.
//
// This function performs a deep comparison.
func (v *Bools) Equals(rhs *Bools) bool {
	if !_Bool_EqualsPtr(v.ImTrue, rhs.ImTrue) {
		return false
	}
	if !_Bool_EqualsPtr(v.ImFalse, rhs.ImFalse) {
		return false
	}

	return true
}

// GetImTrue returns the value of ImTrue if it is set or its
// zero value if it is unset.
func (v *Bools) GetImTrue() (o bool) {
	if v.ImTrue != nil {
		return *v.ImTrue
	}

	return
}

// GetImFalse returns the value of ImFalse if it is set or its
// zero value if it is unset.
func (v *Bools) GetImFalse() (o bool) {
	if v.ImFalse != nil {
		return *v.ImFalse
	}

	return
}

type CrazyNesting struct {
	StringField *string     `json:"string_field,omitempty"`
	SetField    []*Insanity `json:"set_field"`
	ListField   [][]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	} `json:"list_field,required"`
	BinaryField []byte `json:"binary_field"`
}

type _Set_Insanity_ValueList []*Insanity

func (v _Set_Insanity_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Insanity_ValueList) Size() int {
	return len(v)
}

func (_Set_Insanity_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Insanity_ValueList) Close() {}

type _Set_I32_ValueList map[int32]struct{}

func (v _Set_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_I32_ValueList) Size() int {
	return len(v)
}

func (_Set_I32_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_Set_I32_ValueList) Close() {}

type _Map_Insanity_String_MapItemList []struct {
	Key   *Insanity
	Value string
}

func (m _Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TStruct
}

func (_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_Insanity_String_MapItemList) Close() {}

type _List_Map_Insanity_String_ValueList [][]struct {
	Key   *Insanity
	Value string
}

func (v _List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_Insanity_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_Insanity_String_ValueList) Close() {}

type _Set_List_Map_Insanity_String_ValueList [][][]struct {
	Key   *Insanity
	Value string
}

func (v _Set_List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := wire.NewValueList(_List_Map_Insanity_String_ValueList(x)), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_Set_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_Set_List_Map_Insanity_String_ValueList) Close() {}

type _Map_I32_Set_List_Map_Insanity_String_MapItemList map[int32][][][]struct {
	Key   *Insanity
	Value string
}

func (m _Map_I32_Set_List_Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueSet(_Set_List_Map_Insanity_String_ValueList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Set_List_Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Set_List_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Set_List_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TSet
}

func (_Map_I32_Set_List_Map_Insanity_String_MapItemList) Close() {}

type _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList []struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

func (m _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueSet(_Set_I32_ValueList(k)), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueMap(_Map_I32_Set_List_Map_Insanity_String_MapItemList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TSet
}

func (_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TMap
}

func (_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList) Close() {}

type _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

func (v _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList) Close() {}

// ToWire translates a CrazyNesting struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CrazyNesting) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StringField != nil {
		w, err = wire.NewValueString(*(v.StringField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.SetField != nil {
		w, err = wire.NewValueSet(_Set_Insanity_ValueList(v.SetField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.ListField == nil {
		return w, errors.New("field ListField of CrazyNesting is required")
	}
	w, err = wire.NewValueList(_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_ValueList(v.ListField)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.BinaryField != nil {
		w, err = wire.NewValueBinary(v.BinaryField), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Insanity_Read(w wire.Value) (*Insanity, error) {
	var v Insanity
	err := v.FromWire(w)
	return &v, err
}

func _Set_Insanity_Read(s wire.ValueList) ([]*Insanity, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Insanity, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Insanity_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Set_I32_Read(s wire.ValueList) (map[int32]struct{}, error) {
	if s.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[int32]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _Map_Insanity_String_Read(m wire.MapItemList) ([]struct {
	Key   *Insanity
	Value string
}, error) {
	if m.KeyType() != wire.TStruct {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]struct {
		Key   *Insanity
		Value string
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Insanity_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o = append(o, struct {
			Key   *Insanity
			Value string
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_Insanity_String_Read(l wire.ValueList) ([][]struct {
	Key   *Insanity
	Value string
}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([][]struct {
		Key   *Insanity
		Value string
	}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_Insanity_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Set_List_Map_Insanity_String_Read(s wire.ValueList) ([][][]struct {
	Key   *Insanity
	Value string
}, error) {
	if s.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][][]struct {
		Key   *Insanity
		Value string
	}, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _List_Map_Insanity_String_Read(x.GetList())
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Map_I32_Set_List_Map_Insanity_String_Read(m wire.MapItemList) (map[int32][][][]struct {
	Key   *Insanity
	Value string
}, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TSet {
		return nil, nil
	}

	o := make(map[int32][][][]struct {
		Key   *Insanity
		Value string
	}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Set_List_Map_Insanity_String_Read(x.Value.GetSet())
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(m wire.MapItemList) ([]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}, error) {
	if m.KeyType() != wire.TSet {
		return nil, nil
	}

	if m.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Set_I32_Read(x.Key.GetSet())
		if err != nil {
			return err
		}

		v, err := _Map_I32_Set_List_Map_Insanity_String_Read(x.Value.GetMap())
		if err != nil {
			return err
		}

		o = append(o, struct {
			Key   map[int32]struct{}
			Value map[int32][][][]struct {
				Key   *Insanity
				Value string
			}
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(l wire.ValueList) ([][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([][]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a CrazyNesting struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CrazyNesting struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CrazyNesting
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CrazyNesting) FromWire(w wire.Value) error {
	var err error

	list_fieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringField = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.SetField, err = _Set_Insanity_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.ListField, err = _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				list_fieldIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	if !list_fieldIsSet {
		return errors.New("field ListField of CrazyNesting is required")
	}

	return nil
}

// String returns a readable string representation of a CrazyNesting
// struct.
func (v *CrazyNesting) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.StringField != nil {
		fields[i] = fmt.Sprintf("StringField: %v", *(v.StringField))
		i++
	}
	if v.SetField != nil {
		fields[i] = fmt.Sprintf("SetField: %v", v.SetField)
		i++
	}
	fields[i] = fmt.Sprintf("ListField: %v", v.ListField)
	i++
	if v.BinaryField != nil {
		fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
		i++
	}

	return fmt.Sprintf("CrazyNesting{%v}", strings.Join(fields[:i], ", "))
}

func _Set_Insanity_Equals(lhs, rhs []*Insanity) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

func _Set_I32_Equals(lhs, rhs map[int32]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

func _Map_Insanity_String_Equals(lhs, rhs []struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !lk.Equals(rk) {
				continue
			}

			if !(lv == rv) {
				return false
			}
			ok = true
			break
		}

		if !ok {
			return false
		}
	}
	return true
}

func _List_Map_Insanity_String_Equals(lhs, rhs [][]struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Map_Insanity_String_Equals(lv, rv) {
			return false
		}
	}

	return true
}

func _Set_List_Map_Insanity_String_Equals(lhs, rhs [][][]struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if _List_Map_Insanity_String_Equals(x, y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

func _Map_I32_Set_List_Map_Insanity_String_Equals(lhs, rhs map[int32][][][]struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !_Set_List_Map_Insanity_String_Equals(lv, rv) {
			return false
		}
	}
	return true
}

func _Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Equals(lhs, rhs []struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !_Set_I32_Equals(lk, rk) {
				continue
			}

			if !_Map_I32_Set_List_Map_Insanity_String_Equals(lv, rv) {
				return false
			}
			ok = true
			break
		}

		if !ok {
			return false
		}
	}
	return true
}

func _List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Equals(lhs, rhs [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this CrazyNesting match the
// provided CrazyNesting.
//
// This function performs a deep comparison.
func (v *CrazyNesting) Equals(rhs *CrazyNesting) bool {
	if !_String_EqualsPtr(v.StringField, rhs.StringField) {
		return false
	}
	if !((v.SetField == nil && rhs.SetField == nil) || (v.SetField != nil && rhs.SetField != nil && _Set_Insanity_Equals(v.SetField, rhs.SetField))) {
		return false
	}
	if !_List_Map_Set_I32_Map_I32_Set_List_Map_Insanity_String_Equals(v.ListField, rhs.ListField) {
		return false
	}
	if !((v.BinaryField == nil && rhs.BinaryField == nil) || (v.BinaryField != nil && rhs.BinaryField != nil && bytes.Equal(v.BinaryField, rhs.BinaryField))) {
		return false
	}

	return true
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *CrazyNesting) GetStringField() (o string) {
	if v.StringField != nil {
		return *v.StringField
	}

	return
}

type EmptyStruct struct {
}

// ToWire translates a EmptyStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *EmptyStruct) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a EmptyStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a EmptyStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v EmptyStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *EmptyStruct) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a EmptyStruct
// struct.
func (v *EmptyStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("EmptyStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this EmptyStruct match the
// provided EmptyStruct.
//
// This function performs a deep comparison.
func (v *EmptyStruct) Equals(rhs *EmptyStruct) bool {

	return true
}

type GuessProtocolStruct struct {
	MapField map[string]string `json:"map_field"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a GuessProtocolStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GuessProtocolStruct) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.MapField != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.MapField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a GuessProtocolStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GuessProtocolStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GuessProtocolStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GuessProtocolStruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 7:
			if field.Value.Type() == wire.TMap {
				v.MapField, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GuessProtocolStruct
// struct.
func (v *GuessProtocolStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.MapField != nil {
		fields[i] = fmt.Sprintf("MapField: %v", v.MapField)
		i++
	}

	return fmt.Sprintf("GuessProtocolStruct{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this GuessProtocolStruct match the
// provided GuessProtocolStruct.
//
// This function performs a deep comparison.
func (v *GuessProtocolStruct) Equals(rhs *GuessProtocolStruct) bool {
	if !((v.MapField == nil && rhs.MapField == nil) || (v.MapField != nil && rhs.MapField != nil && _Map_String_String_Equals(v.MapField, rhs.MapField))) {
		return false
	}

	return true
}

type Insanity struct {
	UserMap map[Numberz]UserId `json:"userMap"`
	Xtructs []*Xtruct          `json:"xtructs"`
}

type _Map_Numberz_UserId_MapItemList map[Numberz]UserId

func (m _Map_Numberz_UserId_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Numberz_UserId_MapItemList) Size() int {
	return len(m)
}

func (_Map_Numberz_UserId_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_Numberz_UserId_MapItemList) ValueType() wire.Type {
	return wire.TI64
}

func (_Map_Numberz_UserId_MapItemList) Close() {}

type _List_Xtruct_ValueList []*Xtruct

func (v _List_Xtruct_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Xtruct_ValueList) Size() int {
	return len(v)
}

func (_List_Xtruct_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Xtruct_ValueList) Close() {}

// ToWire translates a Insanity struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Insanity) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.UserMap != nil {
		w, err = wire.NewValueMap(_Map_Numberz_UserId_MapItemList(v.UserMap)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Xtructs != nil {
		w, err = wire.NewValueList(_List_Xtruct_ValueList(v.Xtructs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Numberz_Read(w wire.Value) (Numberz, error) {
	var v Numberz
	err := v.FromWire(w)
	return v, err
}

func _UserId_Read(w wire.Value) (UserId, error) {
	var x UserId
	err := x.FromWire(w)
	return x, err
}

func _Map_Numberz_UserId_Read(m wire.MapItemList) (map[Numberz]UserId, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TI64 {
		return nil, nil
	}

	o := make(map[Numberz]UserId, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Numberz_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _UserId_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Xtruct_Read(w wire.Value) (*Xtruct, error) {
	var v Xtruct
	err := v.FromWire(w)
	return &v, err
}

func _List_Xtruct_Read(l wire.ValueList) ([]*Xtruct, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Xtruct, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Xtruct_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Insanity struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Insanity struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Insanity
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Insanity) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.UserMap, err = _Map_Numberz_UserId_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Xtructs, err = _List_Xtruct_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Insanity
// struct.
func (v *Insanity) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.UserMap != nil {
		fields[i] = fmt.Sprintf("UserMap: %v", v.UserMap)
		i++
	}
	if v.Xtructs != nil {
		fields[i] = fmt.Sprintf("Xtructs: %v", v.Xtructs)
		i++
	}

	return fmt.Sprintf("Insanity{%v}", strings.Join(fields[:i], ", "))
}

func _Map_Numberz_UserId_Equals(lhs, rhs map[Numberz]UserId) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func _List_Xtruct_Equals(lhs, rhs []*Xtruct) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Insanity match the
// provided Insanity.
//
// This function performs a deep comparison.
func (v *Insanity) Equals(rhs *Insanity) bool {
	if !((v.UserMap == nil && rhs.UserMap == nil) || (v.UserMap != nil && rhs.UserMap != nil && _Map_Numberz_UserId_Equals(v.UserMap, rhs.UserMap))) {
		return false
	}
	if !((v.Xtructs == nil && rhs.Xtructs == nil) || (v.Xtructs != nil && rhs.Xtructs != nil && _List_Xtruct_Equals(v.Xtructs, rhs.Xtructs))) {
		return false
	}

	return true
}

type LargeDeltas struct {
	B1         *Bools              `json:"b1,omitempty"`
	B10        *Bools              `json:"b10,omitempty"`
	B100       *Bools              `json:"b100,omitempty"`
	CheckTrue  *bool               `json:"check_true,omitempty"`
	B1000      *Bools              `json:"b1000,omitempty"`
	CheckFalse *bool               `json:"check_false,omitempty"`
	Vertwo2000 *VersioningTestV2   `json:"vertwo2000,omitempty"`
	ASet2500   map[string]struct{} `json:"a_set2500"`
	Vertwo3000 *VersioningTestV2   `json:"vertwo3000,omitempty"`
	BigNumbers []int32             `json:"big_numbers"`
}

type _Set_String_ValueList map[string]struct{}

func (v _Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_ValueList) Size() int {
	return len(v)
}

func (_Set_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_ValueList) Close() {}

type _List_I32_ValueList []int32

func (v _List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_I32_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_I32_ValueList) Close() {}

// ToWire translates a LargeDeltas struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *LargeDeltas) ToWire() (wire.Value, error) {
	var (
		fields [10]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.B1 != nil {
		w, err = v.B1.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.B10 != nil {
		w, err = v.B10.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.B100 != nil {
		w, err = v.B100.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 100, Value: w}
		i++
	}
	if v.CheckTrue != nil {
		w, err = wire.NewValueBool(*(v.CheckTrue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 500, Value: w}
		i++
	}
	if v.B1000 != nil {
		w, err = v.B1000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1000, Value: w}
		i++
	}
	if v.CheckFalse != nil {
		w, err = wire.NewValueBool(*(v.CheckFalse)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1500, Value: w}
		i++
	}
	if v.Vertwo2000 != nil {
		w, err = v.Vertwo2000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2000, Value: w}
		i++
	}
	if v.ASet2500 != nil {
		w, err = wire.NewValueSet(_Set_String_ValueList(v.ASet2500)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2500, Value: w}
		i++
	}
	if v.Vertwo3000 != nil {
		w, err = v.Vertwo3000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3000, Value: w}
		i++
	}
	if v.BigNumbers != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.BigNumbers)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4000, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Bools_Read(w wire.Value) (*Bools, error) {
	var v Bools
	err := v.FromWire(w)
	return &v, err
}

func _VersioningTestV2_Read(w wire.Value) (*VersioningTestV2, error) {
	var v VersioningTestV2
	err := v.FromWire(w)
	return &v, err
}

func _Set_String_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _List_I32_Read(l wire.ValueList) ([]int32, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a LargeDeltas struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a LargeDeltas struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v LargeDeltas
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *LargeDeltas) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.B1, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 10:
			if field.Value.Type() == wire.TStruct {
				v.B10, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 100:
			if field.Value.Type() == wire.TStruct {
				v.B100, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 500:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CheckTrue = &x
				if err != nil {
					return err
				}

			}
		case 1000:
			if field.Value.Type() == wire.TStruct {
				v.B1000, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1500:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CheckFalse = &x
				if err != nil {
					return err
				}

			}
		case 2000:
			if field.Value.Type() == wire.TStruct {
				v.Vertwo2000, err = _VersioningTestV2_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2500:
			if field.Value.Type() == wire.TSet {
				v.ASet2500, err = _Set_String_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 3000:
			if field.Value.Type() == wire.TStruct {
				v.Vertwo3000, err = _VersioningTestV2_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4000:
			if field.Value.Type() == wire.TList {
				v.BigNumbers, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a LargeDeltas
// struct.
func (v *LargeDeltas) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [10]string
	i := 0
	if v.B1 != nil {
		fields[i] = fmt.Sprintf("B1: %v", v.B1)
		i++
	}
	if v.B10 != nil {
		fields[i] = fmt.Sprintf("B10: %v", v.B10)
		i++
	}
	if v.B100 != nil {
		fields[i] = fmt.Sprintf("B100: %v", v.B100)
		i++
	}
	if v.CheckTrue != nil {
		fields[i] = fmt.Sprintf("CheckTrue: %v", *(v.CheckTrue))
		i++
	}
	if v.B1000 != nil {
		fields[i] = fmt.Sprintf("B1000: %v", v.B1000)
		i++
	}
	if v.CheckFalse != nil {
		fields[i] = fmt.Sprintf("CheckFalse: %v", *(v.CheckFalse))
		i++
	}
	if v.Vertwo2000 != nil {
		fields[i] = fmt.Sprintf("Vertwo2000: %v", v.Vertwo2000)
		i++
	}
	if v.ASet2500 != nil {
		fields[i] = fmt.Sprintf("ASet2500: %v", v.ASet2500)
		i++
	}
	if v.Vertwo3000 != nil {
		fields[i] = fmt.Sprintf("Vertwo3000: %v", v.Vertwo3000)
		i++
	}
	if v.BigNumbers != nil {
		fields[i] = fmt.Sprintf("BigNumbers: %v", v.BigNumbers)
		i++
	}

	return fmt.Sprintf("LargeDeltas{%v}", strings.Join(fields[:i], ", "))
}

func _Set_String_Equals(lhs, rhs map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

func _List_I32_Equals(lhs, rhs []int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this LargeDeltas match the
// provided LargeDeltas.
//
// This function performs a deep comparison.
func (v *LargeDeltas) Equals(rhs *LargeDeltas) bool {
	if !((v.B1 == nil && rhs.B1 == nil) || (v.B1 != nil && rhs.B1 != nil && v.B1.Equals(rhs.B1))) {
		return false
	}
	if !((v.B10 == nil && rhs.B10 == nil) || (v.B10 != nil && rhs.B10 != nil && v.B10.Equals(rhs.B10))) {
		return false
	}
	if !((v.B100 == nil && rhs.B100 == nil) || (v.B100 != nil && rhs.B100 != nil && v.B100.Equals(rhs.B100))) {
		return false
	}
	if !_Bool_EqualsPtr(v.CheckTrue, rhs.CheckTrue) {
		return false
	}
	if !((v.B1000 == nil && rhs.B1000 == nil) || (v.B1000 != nil && rhs.B1000 != nil && v.B1000.Equals(rhs.B1000))) {
		return false
	}
	if !_Bool_EqualsPtr(v.CheckFalse, rhs.CheckFalse) {
		return false
	}
	if !((v.Vertwo2000 == nil && rhs.Vertwo2000 == nil) || (v.Vertwo2000 != nil && rhs.Vertwo2000 != nil && v.Vertwo2000.Equals(rhs.Vertwo2000))) {
		return false
	}
	if !((v.ASet2500 == nil && rhs.ASet2500 == nil) || (v.ASet2500 != nil && rhs.ASet2500 != nil && _Set_String_Equals(v.ASet2500, rhs.ASet2500))) {
		return false
	}
	if !((v.Vertwo3000 == nil && rhs.Vertwo3000 == nil) || (v.Vertwo3000 != nil && rhs.Vertwo3000 != nil && v.Vertwo3000.Equals(rhs.Vertwo3000))) {
		return false
	}
	if !((v.BigNumbers == nil && rhs.BigNumbers == nil) || (v.BigNumbers != nil && rhs.BigNumbers != nil && _List_I32_Equals(v.BigNumbers, rhs.BigNumbers))) {
		return false
	}

	return true
}

// GetCheckTrue returns the value of CheckTrue if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetCheckTrue() (o bool) {
	if v.CheckTrue != nil {
		return *v.CheckTrue
	}

	return
}

// GetCheckFalse returns the value of CheckFalse if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetCheckFalse() (o bool) {
	if v.CheckFalse != nil {
		return *v.CheckFalse
	}

	return
}

type ListBonks struct {
	Bonk []*Bonk `json:"bonk"`
}

type _List_Bonk_ValueList []*Bonk

func (v _List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Bonk_ValueList) Close() {}

// ToWire translates a ListBonks struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListBonks) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Bonk != nil {
		w, err = wire.NewValueList(_List_Bonk_ValueList(v.Bonk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Bonk_Read(w wire.Value) (*Bonk, error) {
	var v Bonk
	err := v.FromWire(w)
	return &v, err
}

func _List_Bonk_Read(l wire.ValueList) ([]*Bonk, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Bonk_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ListBonks struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListBonks struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListBonks
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListBonks) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Bonk, err = _List_Bonk_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListBonks
// struct.
func (v *ListBonks) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Bonk != nil {
		fields[i] = fmt.Sprintf("Bonk: %v", v.Bonk)
		i++
	}

	return fmt.Sprintf("ListBonks{%v}", strings.Join(fields[:i], ", "))
}

func _List_Bonk_Equals(lhs, rhs []*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ListBonks match the
// provided ListBonks.
//
// This function performs a deep comparison.
func (v *ListBonks) Equals(rhs *ListBonks) bool {
	if !((v.Bonk == nil && rhs.Bonk == nil) || (v.Bonk != nil && rhs.Bonk != nil && _List_Bonk_Equals(v.Bonk, rhs.Bonk))) {
		return false
	}

	return true
}

type ListTypeVersioningV1 struct {
	Myints []int32 `json:"myints"`
	Hello  *string `json:"hello,omitempty"`
}

// ToWire translates a ListTypeVersioningV1 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListTypeVersioningV1) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Myints != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Myints)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Hello != nil {
		w, err = wire.NewValueString(*(v.Hello)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ListTypeVersioningV1 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListTypeVersioningV1 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListTypeVersioningV1
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListTypeVersioningV1) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Myints, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Hello = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListTypeVersioningV1
// struct.
func (v *ListTypeVersioningV1) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Myints != nil {
		fields[i] = fmt.Sprintf("Myints: %v", v.Myints)
		i++
	}
	if v.Hello != nil {
		fields[i] = fmt.Sprintf("Hello: %v", *(v.Hello))
		i++
	}

	return fmt.Sprintf("ListTypeVersioningV1{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ListTypeVersioningV1 match the
// provided ListTypeVersioningV1.
//
// This function performs a deep comparison.
func (v *ListTypeVersioningV1) Equals(rhs *ListTypeVersioningV1) bool {
	if !((v.Myints == nil && rhs.Myints == nil) || (v.Myints != nil && rhs.Myints != nil && _List_I32_Equals(v.Myints, rhs.Myints))) {
		return false
	}
	if !_String_EqualsPtr(v.Hello, rhs.Hello) {
		return false
	}

	return true
}

// GetHello returns the value of Hello if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV1) GetHello() (o string) {
	if v.Hello != nil {
		return *v.Hello
	}

	return
}

type ListTypeVersioningV2 struct {
	Strings []string `json:"strings"`
	Hello   *string  `json:"hello,omitempty"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

// ToWire translates a ListTypeVersioningV2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListTypeVersioningV2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Strings != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Strings)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Hello != nil {
		w, err = wire.NewValueString(*(v.Hello)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ListTypeVersioningV2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListTypeVersioningV2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListTypeVersioningV2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListTypeVersioningV2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Strings, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Hello = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListTypeVersioningV2
// struct.
func (v *ListTypeVersioningV2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Strings != nil {
		fields[i] = fmt.Sprintf("Strings: %v", v.Strings)
		i++
	}
	if v.Hello != nil {
		fields[i] = fmt.Sprintf("Hello: %v", *(v.Hello))
		i++
	}

	return fmt.Sprintf("ListTypeVersioningV2{%v}", strings.Join(fields[:i], ", "))
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ListTypeVersioningV2 match the
// provided ListTypeVersioningV2.
//
// This function performs a deep comparison.
func (v *ListTypeVersioningV2) Equals(rhs *ListTypeVersioningV2) bool {
	if !((v.Strings == nil && rhs.Strings == nil) || (v.Strings != nil && rhs.Strings != nil && _List_String_Equals(v.Strings, rhs.Strings))) {
		return false
	}
	if !_String_EqualsPtr(v.Hello, rhs.Hello) {
		return false
	}

	return true
}

// GetHello returns the value of Hello if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV2) GetHello() (o string) {
	if v.Hello != nil {
		return *v.Hello
	}

	return
}

type _Map_String_Bonk_MapItemList map[string]*Bonk

func (m _Map_String_Bonk_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Bonk_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Bonk_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Bonk_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_Bonk_MapItemList) Close() {}

func _Map_String_Bonk_Read(m wire.MapItemList) (map[string]*Bonk, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[string]*Bonk, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Bonk_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_String_Bonk_Equals(lhs, rhs map[string]*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

type MapType map[string]*Bonk

// ToWire translates MapType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v MapType) ToWire() (wire.Value, error) {
	x := (map[string]*Bonk)(v)
	return wire.NewValueMap(_Map_String_Bonk_MapItemList(x)), error(nil)
}

// String returns a readable string representation of MapType.
func (v MapType) String() string {
	x := (map[string]*Bonk)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes MapType from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *MapType) FromWire(w wire.Value) error {
	x, err := _Map_String_Bonk_Read(w.GetMap())
	*v = (MapType)(x)
	return err
}

// Equals returns true if this MapType is equal to the provided
// MapType.
func (lhs MapType) Equals(rhs MapType) bool {
	return _Map_String_Bonk_Equals(lhs, rhs)
}

type NestedListsBonk struct {
	Bonk [][][]*Bonk `json:"bonk"`
}

type _List_List_Bonk_ValueList [][]*Bonk

func (v _List_List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_Bonk_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_Bonk_ValueList) Close() {}

type _List_List_List_Bonk_ValueList [][][]*Bonk

func (v _List_List_List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_List_Bonk_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_List_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_List_Bonk_ValueList) Close() {}

// ToWire translates a NestedListsBonk struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedListsBonk) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Bonk != nil {
		w, err = wire.NewValueList(_List_List_List_Bonk_ValueList(v.Bonk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_Bonk_Read(l wire.ValueList) ([][]*Bonk, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_Bonk_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_List_List_Bonk_Read(l wire.ValueList) ([][][]*Bonk, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][][]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_List_Bonk_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedListsBonk struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedListsBonk struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedListsBonk
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedListsBonk) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Bonk, err = _List_List_List_Bonk_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedListsBonk
// struct.
func (v *NestedListsBonk) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Bonk != nil {
		fields[i] = fmt.Sprintf("Bonk: %v", v.Bonk)
		i++
	}

	return fmt.Sprintf("NestedListsBonk{%v}", strings.Join(fields[:i], ", "))
}

func _List_List_Bonk_Equals(lhs, rhs [][]*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_Bonk_Equals(lv, rv) {
			return false
		}
	}

	return true
}

func _List_List_List_Bonk_Equals(lhs, rhs [][][]*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_List_Bonk_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedListsBonk match the
// provided NestedListsBonk.
//
// This function performs a deep comparison.
func (v *NestedListsBonk) Equals(rhs *NestedListsBonk) bool {
	if !((v.Bonk == nil && rhs.Bonk == nil) || (v.Bonk != nil && rhs.Bonk != nil && _List_List_List_Bonk_Equals(v.Bonk, rhs.Bonk))) {
		return false
	}

	return true
}

type NestedListsI32x2 struct {
	Integerlist [][]int32 `json:"integerlist"`
}

type _List_List_I32_ValueList [][]int32

func (v _List_List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_List_I32_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_I32_ValueList) Close() {}

// ToWire translates a NestedListsI32x2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedListsI32x2) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Integerlist != nil {
		w, err = wire.NewValueList(_List_List_I32_ValueList(v.Integerlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_I32_Read(l wire.ValueList) ([][]int32, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_I32_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedListsI32x2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedListsI32x2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedListsI32x2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedListsI32x2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Integerlist, err = _List_List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedListsI32x2
// struct.
func (v *NestedListsI32x2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Integerlist != nil {
		fields[i] = fmt.Sprintf("Integerlist: %v", v.Integerlist)
		i++
	}

	return fmt.Sprintf("NestedListsI32x2{%v}", strings.Join(fields[:i], ", "))
}

func _List_List_I32_Equals(lhs, rhs [][]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_I32_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedListsI32x2 match the
// provided NestedListsI32x2.
//
// This function performs a deep comparison.
func (v *NestedListsI32x2) Equals(rhs *NestedListsI32x2) bool {
	if !((v.Integerlist == nil && rhs.Integerlist == nil) || (v.Integerlist != nil && rhs.Integerlist != nil && _List_List_I32_Equals(v.Integerlist, rhs.Integerlist))) {
		return false
	}

	return true
}

type NestedListsI32x3 struct {
	Integerlist [][][]int32 `json:"integerlist"`
}

type _List_List_List_I32_ValueList [][][]int32

func (v _List_List_List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_List_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_List_List_I32_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_List_I32_ValueList) Close() {}

// ToWire translates a NestedListsI32x3 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedListsI32x3) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Integerlist != nil {
		w, err = wire.NewValueList(_List_List_List_I32_ValueList(v.Integerlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_List_I32_Read(l wire.ValueList) ([][][]int32, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][][]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_List_I32_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedListsI32x3 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedListsI32x3 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedListsI32x3
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedListsI32x3) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Integerlist, err = _List_List_List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedListsI32x3
// struct.
func (v *NestedListsI32x3) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Integerlist != nil {
		fields[i] = fmt.Sprintf("Integerlist: %v", v.Integerlist)
		i++
	}

	return fmt.Sprintf("NestedListsI32x3{%v}", strings.Join(fields[:i], ", "))
}

func _List_List_List_I32_Equals(lhs, rhs [][][]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_List_I32_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedListsI32x3 match the
// provided NestedListsI32x3.
//
// This function performs a deep comparison.
func (v *NestedListsI32x3) Equals(rhs *NestedListsI32x3) bool {
	if !((v.Integerlist == nil && rhs.Integerlist == nil) || (v.Integerlist != nil && rhs.Integerlist != nil && _List_List_List_I32_Equals(v.Integerlist, rhs.Integerlist))) {
		return false
	}

	return true
}

type NestedMixedx2 struct {
	IntSetList       []map[int32]struct{}            `json:"int_set_list"`
	MapIntStrset     map[int32]map[string]struct{}   `json:"map_int_strset"`
	MapIntStrsetList []map[int32]map[string]struct{} `json:"map_int_strset_list"`
}

type _List_Set_I32_ValueList []map[int32]struct{}

func (v _List_Set_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueSet(_Set_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Set_I32_ValueList) Size() int {
	return len(v)
}

func (_List_Set_I32_ValueList) ValueType() wire.Type {
	return wire.TSet
}

func (_List_Set_I32_ValueList) Close() {}

type _Map_I32_Set_String_MapItemList map[int32]map[string]struct{}

func (m _Map_I32_Set_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueSet(_Set_String_ValueList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Set_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Set_String_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Set_String_MapItemList) ValueType() wire.Type {
	return wire.TSet
}

func (_Map_I32_Set_String_MapItemList) Close() {}

type _List_Map_I32_Set_String_ValueList []map[int32]map[string]struct{}

func (v _List_Map_I32_Set_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_I32_Set_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_I32_Set_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_I32_Set_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_I32_Set_String_ValueList) Close() {}

// ToWire translates a NestedMixedx2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedMixedx2) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.IntSetList != nil {
		w, err = wire.NewValueList(_List_Set_I32_ValueList(v.IntSetList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.MapIntStrset != nil {
		w, err = wire.NewValueMap(_Map_I32_Set_String_MapItemList(v.MapIntStrset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.MapIntStrsetList != nil {
		w, err = wire.NewValueList(_List_Map_I32_Set_String_ValueList(v.MapIntStrsetList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Set_I32_Read(l wire.ValueList) ([]map[int32]struct{}, error) {
	if l.ValueType() != wire.TSet {
		return nil, nil
	}

	o := make([]map[int32]struct{}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Set_I32_Read(x.GetSet())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Map_I32_Set_String_Read(m wire.MapItemList) (map[int32]map[string]struct{}, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TSet {
		return nil, nil
	}

	o := make(map[int32]map[string]struct{}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Set_String_Read(x.Value.GetSet())
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_I32_Set_String_Read(l wire.ValueList) ([]map[int32]map[string]struct{}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([]map[int32]map[string]struct{}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_I32_Set_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedMixedx2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedMixedx2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedMixedx2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedMixedx2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.IntSetList, err = _List_Set_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.MapIntStrset, err = _Map_I32_Set_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.MapIntStrsetList, err = _List_Map_I32_Set_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedMixedx2
// struct.
func (v *NestedMixedx2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.IntSetList != nil {
		fields[i] = fmt.Sprintf("IntSetList: %v", v.IntSetList)
		i++
	}
	if v.MapIntStrset != nil {
		fields[i] = fmt.Sprintf("MapIntStrset: %v", v.MapIntStrset)
		i++
	}
	if v.MapIntStrsetList != nil {
		fields[i] = fmt.Sprintf("MapIntStrsetList: %v", v.MapIntStrsetList)
		i++
	}

	return fmt.Sprintf("NestedMixedx2{%v}", strings.Join(fields[:i], ", "))
}

func _List_Set_I32_Equals(lhs, rhs []map[int32]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Set_I32_Equals(lv, rv) {
			return false
		}
	}

	return true
}

func _Map_I32_Set_String_Equals(lhs, rhs map[int32]map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !_Set_String_Equals(lv, rv) {
			return false
		}
	}
	return true
}

func _List_Map_I32_Set_String_Equals(lhs, rhs []map[int32]map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Map_I32_Set_String_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedMixedx2 match the
// provided NestedMixedx2.
//
// This function performs a deep comparison.
func (v *NestedMixedx2) Equals(rhs *NestedMixedx2) bool {
	if !((v.IntSetList == nil && rhs.IntSetList == nil) || (v.IntSetList != nil && rhs.IntSetList != nil && _List_Set_I32_Equals(v.IntSetList, rhs.IntSetList))) {
		return false
	}
	if !((v.MapIntStrset == nil && rhs.MapIntStrset == nil) || (v.MapIntStrset != nil && rhs.MapIntStrset != nil && _Map_I32_Set_String_Equals(v.MapIntStrset, rhs.MapIntStrset))) {
		return false
	}
	if !((v.MapIntStrsetList == nil && rhs.MapIntStrsetList == nil) || (v.MapIntStrsetList != nil && rhs.MapIntStrsetList != nil && _List_Map_I32_Set_String_Equals(v.MapIntStrsetList, rhs.MapIntStrsetList))) {
		return false
	}

	return true
}

// Docstring!
type Numberz int32

const (
	NumberzOne   Numberz = 1
	NumberzTwo   Numberz = 2
	NumberzThree Numberz = 3
	NumberzFive  Numberz = 5
	NumberzSix   Numberz = 6
	NumberzEight Numberz = 8
)

// Numberz_Values returns all recognized values of Numberz.
func Numberz_Values() []Numberz {
	return []Numberz{
		NumberzOne,
		NumberzTwo,
		NumberzThree,
		NumberzFive,
		NumberzSix,
		NumberzEight,
	}
}

// UnmarshalText tries to decode Numberz from a byte slice
// containing its name.
//
//   var v Numberz
//   err := v.UnmarshalText([]byte("ONE"))
func (v *Numberz) UnmarshalText(value []byte) error {
	switch string(value) {
	case "ONE":
		*v = NumberzOne
		return nil
	case "TWO":
		*v = NumberzTwo
		return nil
	case "THREE":
		*v = NumberzThree
		return nil
	case "FIVE":
		*v = NumberzFive
		return nil
	case "SIX":
		*v = NumberzSix
		return nil
	case "EIGHT":
		*v = NumberzEight
		return nil
	default:
		return fmt.Errorf("unknown enum value %q for %q", value, "Numberz")
	}
}

// ToWire translates Numberz into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v Numberz) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes Numberz from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return Numberz(0), err
//   }
//
//   var v Numberz
//   if err := v.FromWire(x); err != nil {
//     return Numberz(0), err
//   }
//   return v, nil
func (v *Numberz) FromWire(w wire.Value) error {
	*v = (Numberz)(w.GetI32())
	return nil
}

// String returns a readable string representation of Numberz.
func (v Numberz) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "ONE"
	case 2:
		return "TWO"
	case 3:
		return "THREE"
	case 5:
		return "FIVE"
	case 6:
		return "SIX"
	case 8:
		return "EIGHT"
	}
	return fmt.Sprintf("Numberz(%d)", w)
}

// Equals returns true if this Numberz value matches the provided
// value.
func (v Numberz) Equals(rhs Numberz) bool {
	return v == rhs
}

// MarshalJSON serializes Numberz into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v Numberz) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"ONE\""), nil
	case 2:
		return ([]byte)("\"TWO\""), nil
	case 3:
		return ([]byte)("\"THREE\""), nil
	case 5:
		return ([]byte)("\"FIVE\""), nil
	case 6:
		return ([]byte)("\"SIX\""), nil
	case 8:
		return ([]byte)("\"EIGHT\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode Numberz from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *Numberz) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Numberz")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Numberz")
		}
		*v = (Numberz)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Numberz")
	}
}

type OneField struct {
	Field *EmptyStruct `json:"field,omitempty"`
}

// ToWire translates a OneField struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *OneField) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Field != nil {
		w, err = v.Field.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EmptyStruct_Read(w wire.Value) (*EmptyStruct, error) {
	var v EmptyStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a OneField struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a OneField struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v OneField
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *OneField) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Field, err = _EmptyStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a OneField
// struct.
func (v *OneField) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Field != nil {
		fields[i] = fmt.Sprintf("Field: %v", v.Field)
		i++
	}

	return fmt.Sprintf("OneField{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this OneField match the
// provided OneField.
//
// This function performs a deep comparison.
func (v *OneField) Equals(rhs *OneField) bool {
	if !((v.Field == nil && rhs.Field == nil) || (v.Field != nil && rhs.Field != nil && v.Field.Equals(rhs.Field))) {
		return false
	}

	return true
}

type StructA struct {
	S string `json:"s,required"`
}

// ToWire translates a StructA struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StructA) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.S), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StructA struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StructA struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StructA
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StructA) FromWire(w wire.Value) error {
	var err error

	sIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.S, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				sIsSet = true
			}
		}
	}

	if !sIsSet {
		return errors.New("field S of StructA is required")
	}

	return nil
}

// String returns a readable string representation of a StructA
// struct.
func (v *StructA) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("S: %v", v.S)
	i++

	return fmt.Sprintf("StructA{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StructA match the
// provided StructA.
//
// This function performs a deep comparison.
func (v *StructA) Equals(rhs *StructA) bool {
	if !(v.S == rhs.S) {
		return false
	}

	return true
}

type StructB struct {
	Aa *StructA `json:"aa,omitempty"`
	Ab *StructA `json:"ab,required"`
}

// ToWire translates a StructB struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StructB) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Aa != nil {
		w, err = v.Aa.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Ab == nil {
		return w, errors.New("field Ab of StructB is required")
	}
	w, err = v.Ab.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _StructA_Read(w wire.Value) (*StructA, error) {
	var v StructA
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a StructB struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StructB struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StructB
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StructB) FromWire(w wire.Value) error {
	var err error

	abIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Aa, err = _StructA_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Ab, err = _StructA_Read(field.Value)
				if err != nil {
					return err
				}
				abIsSet = true
			}
		}
	}

	if !abIsSet {
		return errors.New("field Ab of StructB is required")
	}

	return nil
}

// String returns a readable string representation of a StructB
// struct.
func (v *StructB) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Aa != nil {
		fields[i] = fmt.Sprintf("Aa: %v", v.Aa)
		i++
	}
	fields[i] = fmt.Sprintf("Ab: %v", v.Ab)
	i++

	return fmt.Sprintf("StructB{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StructB match the
// provided StructB.
//
// This function performs a deep comparison.
func (v *StructB) Equals(rhs *StructB) bool {
	if !((v.Aa == nil && rhs.Aa == nil) || (v.Aa != nil && rhs.Aa != nil && v.Aa.Equals(rhs.Aa))) {
		return false
	}
	if !v.Ab.Equals(rhs.Ab) {
		return false
	}

	return true
}

type UserId int64

// ToWire translates UserId into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v UserId) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

// String returns a readable string representation of UserId.
func (v UserId) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes UserId from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *UserId) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (UserId)(x)
	return err
}

// Equals returns true if this UserId is equal to the provided
// UserId.
func (lhs UserId) Equals(rhs UserId) bool {
	return (lhs == rhs)
}

type VersioningTestV1 struct {
	BeginInBoth *int32  `json:"begin_in_both,omitempty"`
	OldString   *string `json:"old_string,omitempty"`
	EndInBoth   *int32  `json:"end_in_both,omitempty"`
}

// ToWire translates a VersioningTestV1 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *VersioningTestV1) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BeginInBoth != nil {
		w, err = wire.NewValueI32(*(v.BeginInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.OldString != nil {
		w, err = wire.NewValueString(*(v.OldString)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.EndInBoth != nil {
		w, err = wire.NewValueI32(*(v.EndInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a VersioningTestV1 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a VersioningTestV1 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v VersioningTestV1
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *VersioningTestV1) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BeginInBoth = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.OldString = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EndInBoth = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a VersioningTestV1
// struct.
func (v *VersioningTestV1) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.BeginInBoth != nil {
		fields[i] = fmt.Sprintf("BeginInBoth: %v", *(v.BeginInBoth))
		i++
	}
	if v.OldString != nil {
		fields[i] = fmt.Sprintf("OldString: %v", *(v.OldString))
		i++
	}
	if v.EndInBoth != nil {
		fields[i] = fmt.Sprintf("EndInBoth: %v", *(v.EndInBoth))
		i++
	}

	return fmt.Sprintf("VersioningTestV1{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this VersioningTestV1 match the
// provided VersioningTestV1.
//
// This function performs a deep comparison.
func (v *VersioningTestV1) Equals(rhs *VersioningTestV1) bool {
	if !_I32_EqualsPtr(v.BeginInBoth, rhs.BeginInBoth) {
		return false
	}
	if !_String_EqualsPtr(v.OldString, rhs.OldString) {
		return false
	}
	if !_I32_EqualsPtr(v.EndInBoth, rhs.EndInBoth) {
		return false
	}

	return true
}

// GetBeginInBoth returns the value of BeginInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV1) GetBeginInBoth() (o int32) {
	if v.BeginInBoth != nil {
		return *v.BeginInBoth
	}

	return
}

// GetOldString returns the value of OldString if it is set or its
// zero value if it is unset.
func (v *VersioningTestV1) GetOldString() (o string) {
	if v.OldString != nil {
		return *v.OldString
	}

	return
}

// GetEndInBoth returns the value of EndInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV1) GetEndInBoth() (o int32) {
	if v.EndInBoth != nil {
		return *v.EndInBoth
	}

	return
}

type VersioningTestV2 struct {
	BeginInBoth *int32             `json:"begin_in_both,omitempty"`
	Newint      *int32             `json:"newint,omitempty"`
	Newbyte     *int8              `json:"newbyte,omitempty"`
	Newshort    *int16             `json:"newshort,omitempty"`
	Newlong     *int64             `json:"newlong,omitempty"`
	Newdouble   *float64           `json:"newdouble,omitempty"`
	Newstruct   *Bonk              `json:"newstruct,omitempty"`
	Newlist     []int32            `json:"newlist"`
	Newset      map[int32]struct{} `json:"newset"`
	Newmap      map[int32]int32    `json:"newmap"`
	Newstring   *string            `json:"newstring,omitempty"`
	EndInBoth   *int32             `json:"end_in_both,omitempty"`
}

type _Map_I32_I32_MapItemList map[int32]int32

func (m _Map_I32_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI32(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_I32_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_I32_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_I32_I32_MapItemList) Close() {}

// ToWire translates a VersioningTestV2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *VersioningTestV2) ToWire() (wire.Value, error) {
	var (
		fields [12]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BeginInBoth != nil {
		w, err = wire.NewValueI32(*(v.BeginInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Newint != nil {
		w, err = wire.NewValueI32(*(v.Newint)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Newbyte != nil {
		w, err = wire.NewValueI8(*(v.Newbyte)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Newshort != nil {
		w, err = wire.NewValueI16(*(v.Newshort)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Newlong != nil {
		w, err = wire.NewValueI64(*(v.Newlong)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Newdouble != nil {
		w, err = wire.NewValueDouble(*(v.Newdouble)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.Newstruct != nil {
		w, err = v.Newstruct.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.Newlist != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Newlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}
	if v.Newset != nil {
		w, err = wire.NewValueSet(_Set_I32_ValueList(v.Newset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.Newmap != nil {
		w, err = wire.NewValueMap(_Map_I32_I32_MapItemList(v.Newmap)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Newstring != nil {
		w, err = wire.NewValueString(*(v.Newstring)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	if v.EndInBoth != nil {
		w, err = wire.NewValueI32(*(v.EndInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_I32_I32_Read(m wire.MapItemList) (map[int32]int32, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[int32]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a VersioningTestV2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a VersioningTestV2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v VersioningTestV2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *VersioningTestV2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BeginInBoth = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Newint = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.Newbyte = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Newshort = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Newlong = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.Newdouble = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.Newstruct, err = _Bonk_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TList {
				v.Newlist, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TSet {
				v.Newset, err = _Set_I32_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 10:
			if field.Value.Type() == wire.TMap {
				v.Newmap, err = _Map_I32_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Newstring = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EndInBoth = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a VersioningTestV2
// struct.
func (v *VersioningTestV2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [12]string
	i := 0
	if v.BeginInBoth != nil {
		fields[i] = fmt.Sprintf("BeginInBoth: %v", *(v.BeginInBoth))
		i++
	}
	if v.Newint != nil {
		fields[i] = fmt.Sprintf("Newint: %v", *(v.Newint))
		i++
	}
	if v.Newbyte != nil {
		fields[i] = fmt.Sprintf("Newbyte: %v", *(v.Newbyte))
		i++
	}
	if v.Newshort != nil {
		fields[i] = fmt.Sprintf("Newshort: %v", *(v.Newshort))
		i++
	}
	if v.Newlong != nil {
		fields[i] = fmt.Sprintf("Newlong: %v", *(v.Newlong))
		i++
	}
	if v.Newdouble != nil {
		fields[i] = fmt.Sprintf("Newdouble: %v", *(v.Newdouble))
		i++
	}
	if v.Newstruct != nil {
		fields[i] = fmt.Sprintf("Newstruct: %v", v.Newstruct)
		i++
	}
	if v.Newlist != nil {
		fields[i] = fmt.Sprintf("Newlist: %v", v.Newlist)
		i++
	}
	if v.Newset != nil {
		fields[i] = fmt.Sprintf("Newset: %v", v.Newset)
		i++
	}
	if v.Newmap != nil {
		fields[i] = fmt.Sprintf("Newmap: %v", v.Newmap)
		i++
	}
	if v.Newstring != nil {
		fields[i] = fmt.Sprintf("Newstring: %v", *(v.Newstring))
		i++
	}
	if v.EndInBoth != nil {
		fields[i] = fmt.Sprintf("EndInBoth: %v", *(v.EndInBoth))
		i++
	}

	return fmt.Sprintf("VersioningTestV2{%v}", strings.Join(fields[:i], ", "))
}

func _Byte_EqualsPtr(lhs, rhs *int8) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I16_EqualsPtr(lhs, rhs *int16) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Map_I32_I32_Equals(lhs, rhs map[int32]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this VersioningTestV2 match the
// provided VersioningTestV2.
//
// This function performs a deep comparison.
func (v *VersioningTestV2) Equals(rhs *VersioningTestV2) bool {
	if !_I32_EqualsPtr(v.BeginInBoth, rhs.BeginInBoth) {
		return false
	}
	if !_I32_EqualsPtr(v.Newint, rhs.Newint) {
		return false
	}
	if !_Byte_EqualsPtr(v.Newbyte, rhs.Newbyte) {
		return false
	}
	if !_I16_EqualsPtr(v.Newshort, rhs.Newshort) {
		return false
	}
	if !_I64_EqualsPtr(v.Newlong, rhs.Newlong) {
		return false
	}
	if !_Double_EqualsPtr(v.Newdouble, rhs.Newdouble) {
		return false
	}
	if !((v.Newstruct == nil && rhs.Newstruct == nil) || (v.Newstruct != nil && rhs.Newstruct != nil && v.Newstruct.Equals(rhs.Newstruct))) {
		return false
	}
	if !((v.Newlist == nil && rhs.Newlist == nil) || (v.Newlist != nil && rhs.Newlist != nil && _List_I32_Equals(v.Newlist, rhs.Newlist))) {
		return false
	}
	if !((v.Newset == nil && rhs.Newset == nil) || (v.Newset != nil && rhs.Newset != nil && _Set_I32_Equals(v.Newset, rhs.Newset))) {
		return false
	}
	if !((v.Newmap == nil && rhs.Newmap == nil) || (v.Newmap != nil && rhs.Newmap != nil && _Map_I32_I32_Equals(v.Newmap, rhs.Newmap))) {
		return false
	}
	if !_String_EqualsPtr(v.Newstring, rhs.Newstring) {
		return false
	}
	if !_I32_EqualsPtr(v.EndInBoth, rhs.EndInBoth) {
		return false
	}

	return true
}

// GetBeginInBoth returns the value of BeginInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetBeginInBoth() (o int32) {
	if v.BeginInBoth != nil {
		return *v.BeginInBoth
	}

	return
}

// GetNewint returns the value of Newint if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewint() (o int32) {
	if v.Newint != nil {
		return *v.Newint
	}

	return
}

// GetNewbyte returns the value of Newbyte if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewbyte() (o int8) {
	if v.Newbyte != nil {
		return *v.Newbyte
	}

	return
}

// GetNewshort returns the value of Newshort if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewshort() (o int16) {
	if v.Newshort != nil {
		return *v.Newshort
	}

	return
}

// GetNewlong returns the value of Newlong if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewlong() (o int64) {
	if v.Newlong != nil {
		return *v.Newlong
	}

	return
}

// GetNewdouble returns the value of Newdouble if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewdouble() (o float64) {
	if v.Newdouble != nil {
		return *v.Newdouble
	}

	return
}

// GetNewstring returns the value of Newstring if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewstring() (o string) {
	if v.Newstring != nil {
		return *v.Newstring
	}

	return
}

// GetEndInBoth returns the value of EndInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetEndInBoth() (o int32) {
	if v.EndInBoth != nil {
		return *v.EndInBoth
	}

	return
}

type Xception struct {
	ErrorCode *int32  `json:"errorCode,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// ToWire translates a Xception struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xception) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xception struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xception struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xception
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xception) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xception
// struct.
func (v *Xception) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}

	return fmt.Sprintf("Xception{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xception match the
// provided Xception.
//
// This function performs a deep comparison.
func (v *Xception) Equals(rhs *Xception) bool {
	if !_I32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}

	return true
}

// GetErrorCode returns the value of ErrorCode if it is set or its
// zero value if it is unset.
func (v *Xception) GetErrorCode() (o int32) {
	if v.ErrorCode != nil {
		return *v.ErrorCode
	}

	return
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *Xception) GetMessage() (o string) {
	if v.Message != nil {
		return *v.Message
	}

	return
}

func (v *Xception) Error() string {
	return v.String()
}

type Xception2 struct {
	ErrorCode   *int32  `json:"errorCode,omitempty"`
	StructThing *Xtruct `json:"struct_thing,omitempty"`
}

// ToWire translates a Xception2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xception2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StructThing != nil {
		w, err = v.StructThing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xception2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xception2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xception2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xception2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.StructThing, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xception2
// struct.
func (v *Xception2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	if v.StructThing != nil {
		fields[i] = fmt.Sprintf("StructThing: %v", v.StructThing)
		i++
	}

	return fmt.Sprintf("Xception2{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xception2 match the
// provided Xception2.
//
// This function performs a deep comparison.
func (v *Xception2) Equals(rhs *Xception2) bool {
	if !_I32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}
	if !((v.StructThing == nil && rhs.StructThing == nil) || (v.StructThing != nil && rhs.StructThing != nil && v.StructThing.Equals(rhs.StructThing))) {
		return false
	}

	return true
}

// GetErrorCode returns the value of ErrorCode if it is set or its
// zero value if it is unset.
func (v *Xception2) GetErrorCode() (o int32) {
	if v.ErrorCode != nil {
		return *v.ErrorCode
	}

	return
}

func (v *Xception2) Error() string {
	return v.String()
}

type Xtruct struct {
	StringThing *string `json:"string_thing,omitempty"`
	ByteThing   *int8   `json:"byte_thing,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
	I64Thing    *int64  `json:"i64_thing,omitempty"`
}

// ToWire translates a Xtruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xtruct) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StringThing != nil {
		w, err = wire.NewValueString(*(v.StringThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ByteThing != nil {
		w, err = wire.NewValueI8(*(v.ByteThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.I64Thing != nil {
		w, err = wire.NewValueI64(*(v.I64Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xtruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xtruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xtruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xtruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringThing = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteThing = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.I64Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xtruct
// struct.
func (v *Xtruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.StringThing != nil {
		fields[i] = fmt.Sprintf("StringThing: %v", *(v.StringThing))
		i++
	}
	if v.ByteThing != nil {
		fields[i] = fmt.Sprintf("ByteThing: %v", *(v.ByteThing))
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}
	if v.I64Thing != nil {
		fields[i] = fmt.Sprintf("I64Thing: %v", *(v.I64Thing))
		i++
	}

	return fmt.Sprintf("Xtruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xtruct match the
// provided Xtruct.
//
// This function performs a deep comparison.
func (v *Xtruct) Equals(rhs *Xtruct) bool {
	if !_String_EqualsPtr(v.StringThing, rhs.StringThing) {
		return false
	}
	if !_Byte_EqualsPtr(v.ByteThing, rhs.ByteThing) {
		return false
	}
	if !_I32_EqualsPtr(v.I32Thing, rhs.I32Thing) {
		return false
	}
	if !_I64_EqualsPtr(v.I64Thing, rhs.I64Thing) {
		return false
	}

	return true
}

// GetStringThing returns the value of StringThing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetStringThing() (o string) {
	if v.StringThing != nil {
		return *v.StringThing
	}

	return
}

// GetByteThing returns the value of ByteThing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetByteThing() (o int8) {
	if v.ByteThing != nil {
		return *v.ByteThing
	}

	return
}

// GetI32Thing returns the value of I32Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetI32Thing() (o int32) {
	if v.I32Thing != nil {
		return *v.I32Thing
	}

	return
}

// GetI64Thing returns the value of I64Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetI64Thing() (o int64) {
	if v.I64Thing != nil {
		return *v.I64Thing
	}

	return
}

type Xtruct2 struct {
	ByteThing   *int8   `json:"byte_thing,omitempty"`
	StructThing *Xtruct `json:"struct_thing,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
}

// ToWire translates a Xtruct2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xtruct2) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ByteThing != nil {
		w, err = wire.NewValueI8(*(v.ByteThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StructThing != nil {
		w, err = v.StructThing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xtruct2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xtruct2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xtruct2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xtruct2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteThing = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.StructThing, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xtruct2
// struct.
func (v *Xtruct2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ByteThing != nil {
		fields[i] = fmt.Sprintf("ByteThing: %v", *(v.ByteThing))
		i++
	}
	if v.StructThing != nil {
		fields[i] = fmt.Sprintf("StructThing: %v", v.StructThing)
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}

	return fmt.Sprintf("Xtruct2{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xtruct2 match the
// provided Xtruct2.
//
// This function performs a deep comparison.
func (v *Xtruct2) Equals(rhs *Xtruct2) bool {
	if !_Byte_EqualsPtr(v.ByteThing, rhs.ByteThing) {
		return false
	}
	if !((v.StructThing == nil && rhs.StructThing == nil) || (v.StructThing != nil && rhs.StructThing != nil && v.StructThing.Equals(rhs.StructThing))) {
		return false
	}
	if !_I32_EqualsPtr(v.I32Thing, rhs.I32Thing) {
		return false
	}

	return true
}

// GetByteThing returns the value of ByteThing if it is set or its
// zero value if it is unset.
func (v *Xtruct2) GetByteThing() (o int8) {
	if v.ByteThing != nil {
		return *v.ByteThing
	}

	return
}

// GetI32Thing returns the value of I32Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct2) GetI32Thing() (o int32) {
	if v.I32Thing != nil {
		return *v.I32Thing
	}

	return
}

type Xtruct3 struct {
	StringThing *string `json:"string_thing,omitempty"`
	Changed     *int32  `json:"changed,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
	I64Thing    *int64  `json:"i64_thing,omitempty"`
}

// ToWire translates a Xtruct3 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xtruct3) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StringThing != nil {
		w, err = wire.NewValueString(*(v.StringThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Changed != nil {
		w, err = wire.NewValueI32(*(v.Changed)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.I64Thing != nil {
		w, err = wire.NewValueI64(*(v.I64Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xtruct3 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xtruct3 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xtruct3
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xtruct3) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringThing = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Changed = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.I64Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xtruct3
// struct.
func (v *Xtruct3) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.StringThing != nil {
		fields[i] = fmt.Sprintf("StringThing: %v", *(v.StringThing))
		i++
	}
	if v.Changed != nil {
		fields[i] = fmt.Sprintf("Changed: %v", *(v.Changed))
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}
	if v.I64Thing != nil {
		fields[i] = fmt.Sprintf("I64Thing: %v", *(v.I64Thing))
		i++
	}

	return fmt.Sprintf("Xtruct3{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xtruct3 match the
// provided Xtruct3.
//
// This function performs a deep comparison.
func (v *Xtruct3) Equals(rhs *Xtruct3) bool {
	if !_String_EqualsPtr(v.StringThing, rhs.StringThing) {
		return false
	}
	if !_I32_EqualsPtr(v.Changed, rhs.Changed) {
		return false
	}
	if !_I32_EqualsPtr(v.I32Thing, rhs.I32Thing) {
		return false
	}
	if !_I64_EqualsPtr(v.I64Thing, rhs.I64Thing) {
		return false
	}

	return true
}

// GetStringThing returns the value of StringThing if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetStringThing() (o string) {
	if v.StringThing != nil {
		return *v.StringThing
	}

	return
}

// GetChanged returns the value of Changed if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetChanged() (o int32) {
	if v.Changed != nil {
		return *v.Changed
	}

	return
}

// GetI32Thing returns the value of I32Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetI32Thing() (o int32) {
	if v.I32Thing != nil {
		return *v.I32Thing
	}

	return
}

// GetI64Thing returns the value of I64Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetI64Thing() (o int64) {
	if v.I64Thing != nil {
		return *v.I64Thing
	}

	return
}
