// Code generated by thriftrw v1.25.0. DO NOT EDIT.
// @generated

// Copyright (c) 2021 Uber Technologies, Inc.
//
// Permission is hereby granted, free of charge, to any person obtaining a copy
// of this software and associated documentation files (the "Software"), to deal
// in the Software without restriction, including without limitation the rights
// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
// copies of the Software, and to permit persons to whom the Software is
// furnished to do so, subject to the following conditions:
//
// The above copyright notice and this permission notice shall be included in
// all copies or substantial portions of the Software.
//
// THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN
// THE SOFTWARE.

package gauntlet

import (
	bytes "bytes"
	base64 "encoding/base64"
	json "encoding/json"
	errors "errors"
	fmt "fmt"
	multierr "go.uber.org/multierr"
	ptr "go.uber.org/thriftrw/ptr"
	thriftreflect "go.uber.org/thriftrw/thriftreflect"
	wire "go.uber.org/thriftrw/wire"
	zapcore "go.uber.org/zap/zapcore"
	math "math"
	strconv "strconv"
	strings "strings"
)

const MyNumberz Numberz = NumberzOne

type Bonk struct {
	Message *string `json:"message,omitempty"`
	Type    *int32  `json:"type,omitempty"`
}

// ToWire translates a Bonk struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bonk) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Type != nil {
		w, err = wire.NewValueI32(*(v.Type)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bonk struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bonk struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bonk
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bonk) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Type = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Bonk
// struct.
func (v *Bonk) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}
	if v.Type != nil {
		fields[i] = fmt.Sprintf("Type: %v", *(v.Type))
		i++
	}

	return fmt.Sprintf("Bonk{%v}", strings.Join(fields[:i], ", "))
}

func _String_EqualsPtr(lhs, rhs *string) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I32_EqualsPtr(lhs, rhs *int32) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this Bonk match the
// provided Bonk.
//
// This function performs a deep comparison.
func (v *Bonk) Equals(rhs *Bonk) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}
	if !_I32_EqualsPtr(v.Type, rhs.Type) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bonk.
func (v *Bonk) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	if v.Type != nil {
		enc.AddInt32("type", *v.Type)
	}
	return err
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *Bonk) GetMessage() (o string) {
	if v != nil && v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *Bonk) IsSetMessage() bool {
	return v != nil && v.Message != nil
}

// GetType returns the value of Type if it is set or its
// zero value if it is unset.
func (v *Bonk) GetType() (o int32) {
	if v != nil && v.Type != nil {
		return *v.Type
	}

	return
}

// IsSetType returns true if Type is not nil.
func (v *Bonk) IsSetType() bool {
	return v != nil && v.Type != nil
}

type BoolTest struct {
	B *bool   `json:"b,omitempty"`
	S *string `json:"s,omitempty"`
}

// Default_BoolTest constructs a new BoolTest struct,
// pre-populating any fields with defined default values.
func Default_BoolTest() *BoolTest {
	var v BoolTest
	v.B = ptr.Bool(true)
	v.S = ptr.String("true")
	return &v
}

// ToWire translates a BoolTest struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *BoolTest) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	vB := v.B
	if vB == nil {
		vB = ptr.Bool(true)
	}
	{
		w, err = wire.NewValueBool(*(vB)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	vS := v.S
	if vS == nil {
		vS = ptr.String("true")
	}
	{
		w, err = wire.NewValueString(*(vS)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a BoolTest struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a BoolTest struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v BoolTest
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *BoolTest) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.B = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.S = &x
				if err != nil {
					return err
				}

			}
		}
	}

	if v.B == nil {
		v.B = ptr.Bool(true)
	}

	if v.S == nil {
		v.S = ptr.String("true")
	}

	return nil
}

// String returns a readable string representation of a BoolTest
// struct.
func (v *BoolTest) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.B != nil {
		fields[i] = fmt.Sprintf("B: %v", *(v.B))
		i++
	}
	if v.S != nil {
		fields[i] = fmt.Sprintf("S: %v", *(v.S))
		i++
	}

	return fmt.Sprintf("BoolTest{%v}", strings.Join(fields[:i], ", "))
}

func _Bool_EqualsPtr(lhs, rhs *bool) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this BoolTest match the
// provided BoolTest.
//
// This function performs a deep comparison.
func (v *BoolTest) Equals(rhs *BoolTest) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.B, rhs.B) {
		return false
	}
	if !_String_EqualsPtr(v.S, rhs.S) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of BoolTest.
func (v *BoolTest) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.B != nil {
		enc.AddBool("b", *v.B)
	}
	if v.S != nil {
		enc.AddString("s", *v.S)
	}
	return err
}

// GetB returns the value of B if it is set or its
// default value if it is unset.
func (v *BoolTest) GetB() (o bool) {
	if v != nil && v.B != nil {
		return *v.B
	}
	o = true
	return
}

// IsSetB returns true if B is not nil.
func (v *BoolTest) IsSetB() bool {
	return v != nil && v.B != nil
}

// GetS returns the value of S if it is set or its
// default value if it is unset.
func (v *BoolTest) GetS() (o string) {
	if v != nil && v.S != nil {
		return *v.S
	}
	o = "true"
	return
}

// IsSetS returns true if S is not nil.
func (v *BoolTest) IsSetS() bool {
	return v != nil && v.S != nil
}

type Bools struct {
	ImTrue  *bool `json:"im_true,omitempty"`
	ImFalse *bool `json:"im_false,omitempty"`
}

// ToWire translates a Bools struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Bools) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ImTrue != nil {
		w, err = wire.NewValueBool(*(v.ImTrue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ImFalse != nil {
		w, err = wire.NewValueBool(*(v.ImFalse)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Bools struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Bools struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Bools
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Bools) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ImTrue = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.ImFalse = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Bools
// struct.
func (v *Bools) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ImTrue != nil {
		fields[i] = fmt.Sprintf("ImTrue: %v", *(v.ImTrue))
		i++
	}
	if v.ImFalse != nil {
		fields[i] = fmt.Sprintf("ImFalse: %v", *(v.ImFalse))
		i++
	}

	return fmt.Sprintf("Bools{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Bools match the
// provided Bools.
//
// This function performs a deep comparison.
func (v *Bools) Equals(rhs *Bools) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Bool_EqualsPtr(v.ImTrue, rhs.ImTrue) {
		return false
	}
	if !_Bool_EqualsPtr(v.ImFalse, rhs.ImFalse) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Bools.
func (v *Bools) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ImTrue != nil {
		enc.AddBool("im_true", *v.ImTrue)
	}
	if v.ImFalse != nil {
		enc.AddBool("im_false", *v.ImFalse)
	}
	return err
}

// GetImTrue returns the value of ImTrue if it is set or its
// zero value if it is unset.
func (v *Bools) GetImTrue() (o bool) {
	if v != nil && v.ImTrue != nil {
		return *v.ImTrue
	}

	return
}

// IsSetImTrue returns true if ImTrue is not nil.
func (v *Bools) IsSetImTrue() bool {
	return v != nil && v.ImTrue != nil
}

// GetImFalse returns the value of ImFalse if it is set or its
// zero value if it is unset.
func (v *Bools) GetImFalse() (o bool) {
	if v != nil && v.ImFalse != nil {
		return *v.ImFalse
	}

	return
}

// IsSetImFalse returns true if ImFalse is not nil.
func (v *Bools) IsSetImFalse() bool {
	return v != nil && v.ImFalse != nil
}

type CrazyNesting struct {
	StringField *string     `json:"string_field,omitempty"`
	SetField    []*Insanity `json:"set_field,omitempty"`
	ListField   [][]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	} `json:"list_field,required"`
	BinaryField []byte `json:"binary_field,omitempty"`
}

type _Set_Insanity_sliceType_ValueList []*Insanity

func (v _Set_Insanity_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_Insanity_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_Insanity_sliceType_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Set_Insanity_sliceType_ValueList) Close() {}

type _Set_I32_mapType_ValueList map[int32]struct{}

func (v _Set_I32_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_I32_mapType_ValueList) Size() int {
	return len(v)
}

func (_Set_I32_mapType_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_Set_I32_mapType_ValueList) Close() {}

type _Map_Insanity_String_MapItemList []struct {
	Key   *Insanity
	Value string
}

func (m _Map_Insanity_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Insanity_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_Insanity_String_MapItemList) KeyType() wire.Type {
	return wire.TStruct
}

func (_Map_Insanity_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_Insanity_String_MapItemList) Close() {}

type _List_Map_Insanity_String_ValueList [][]struct {
	Key   *Insanity
	Value string
}

func (v _List_Map_Insanity_String_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_Insanity_String_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_Insanity_String_ValueList) Size() int {
	return len(v)
}

func (_List_Map_Insanity_String_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_Insanity_String_ValueList) Close() {}

type _Set_List_Map_Insanity_String_sliceType_ValueList [][][]struct {
	Key   *Insanity
	Value string
}

func (v _Set_List_Map_Insanity_String_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		if x == nil {
			return fmt.Errorf("invalid set item: value is nil")
		}
		w, err := wire.NewValueList(_List_Map_Insanity_String_ValueList(x)), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_List_Map_Insanity_String_sliceType_ValueList) Size() int {
	return len(v)
}

func (_Set_List_Map_Insanity_String_sliceType_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_Set_List_Map_Insanity_String_sliceType_ValueList) Close() {}

type _Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList map[int32][][][]struct {
	Key   *Insanity
	Value string
}

func (m _Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueSet(_Set_List_Map_Insanity_String_sliceType_ValueList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) ValueType() wire.Type {
	return wire.TSet
}

func (_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) Close() {}

type _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList []struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

func (m _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for _, i := range m {
		k := i.Key
		v := i.Value
		if k == nil {
			return fmt.Errorf("invalid map key: value is nil")
		}
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueSet(_Set_I32_mapType_ValueList(k)), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueMap(_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) Size() int {
	return len(m)
}

func (_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) KeyType() wire.Type {
	return wire.TSet
}

func (_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) ValueType() wire.Type {
	return wire.TMap
}

func (_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList) Close() {}

type _List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_ValueList [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

func (v _List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_ValueList) Size() int {
	return len(v)
}

func (_List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_ValueList) Close() {}

// ToWire translates a CrazyNesting struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *CrazyNesting) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StringField != nil {
		w, err = wire.NewValueString(*(v.StringField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.SetField != nil {
		w, err = wire.NewValueSet(_Set_Insanity_sliceType_ValueList(v.SetField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	w, err = wire.NewValueList(_List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_ValueList(v.ListField)), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 3, Value: w}
	i++
	if v.BinaryField != nil {
		w, err = wire.NewValueBinary(v.BinaryField), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Insanity_Read(w wire.Value) (*Insanity, error) {
	var v Insanity
	err := v.FromWire(w)
	return &v, err
}

func _Set_Insanity_sliceType_Read(s wire.ValueList) ([]*Insanity, error) {
	if s.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Insanity, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _Insanity_Read(x)
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Set_I32_mapType_Read(s wire.ValueList) (map[int32]struct{}, error) {
	if s.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[int32]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _Map_Insanity_String_Read(m wire.MapItemList) ([]struct {
	Key   *Insanity
	Value string
}, error) {
	if m.KeyType() != wire.TStruct {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]struct {
		Key   *Insanity
		Value string
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Insanity_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o = append(o, struct {
			Key   *Insanity
			Value string
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_Insanity_String_Read(l wire.ValueList) ([][]struct {
	Key   *Insanity
	Value string
}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([][]struct {
		Key   *Insanity
		Value string
	}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_Insanity_String_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Set_List_Map_Insanity_String_sliceType_Read(s wire.ValueList) ([][][]struct {
	Key   *Insanity
	Value string
}, error) {
	if s.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][][]struct {
		Key   *Insanity
		Value string
	}, 0, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := _List_Map_Insanity_String_Read(x.GetList())
		if err != nil {
			return err
		}

		o = append(o, i)
		return nil
	})
	s.Close()
	return o, err
}

func _Map_I32_Set_List_Map_Insanity_String_sliceType_Read(m wire.MapItemList) (map[int32][][][]struct {
	Key   *Insanity
	Value string
}, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TSet {
		return nil, nil
	}

	o := make(map[int32][][][]struct {
		Key   *Insanity
		Value string
	}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Set_List_Map_Insanity_String_sliceType_Read(x.Value.GetSet())
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Read(m wire.MapItemList) ([]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}, error) {
	if m.KeyType() != wire.TSet {
		return nil, nil
	}

	if m.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	}, 0, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Set_I32_mapType_Read(x.Key.GetSet())
		if err != nil {
			return err
		}

		v, err := _Map_I32_Set_List_Map_Insanity_String_sliceType_Read(x.Value.GetMap())
		if err != nil {
			return err
		}

		o = append(o, struct {
			Key   map[int32]struct{}
			Value map[int32][][][]struct {
				Key   *Insanity
				Value string
			}
		}{k, v})
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Read(l wire.ValueList) ([][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([][]struct {
		Key   map[int32]struct{}
		Value map[int32][][][]struct {
			Key   *Insanity
			Value string
		}
	}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a CrazyNesting struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a CrazyNesting struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v CrazyNesting
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *CrazyNesting) FromWire(w wire.Value) error {
	var err error

	list_fieldIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringField = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TSet {
				v.SetField, err = _Set_Insanity_sliceType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.ListField, err = _List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Read(field.Value.GetList())
				if err != nil {
					return err
				}
				list_fieldIsSet = true
			}
		case 4:
			if field.Value.Type() == wire.TBinary {
				v.BinaryField, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	if !list_fieldIsSet {
		return errors.New("field ListField of CrazyNesting is required")
	}

	return nil
}

// String returns a readable string representation of a CrazyNesting
// struct.
func (v *CrazyNesting) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.StringField != nil {
		fields[i] = fmt.Sprintf("StringField: %v", *(v.StringField))
		i++
	}
	if v.SetField != nil {
		fields[i] = fmt.Sprintf("SetField: %v", v.SetField)
		i++
	}
	fields[i] = fmt.Sprintf("ListField: %v", v.ListField)
	i++
	if v.BinaryField != nil {
		fields[i] = fmt.Sprintf("BinaryField: %v", v.BinaryField)
		i++
	}

	return fmt.Sprintf("CrazyNesting{%v}", strings.Join(fields[:i], ", "))
}

func _Set_Insanity_sliceType_Equals(lhs, rhs []*Insanity) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if x.Equals(y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

func _Set_I32_mapType_Equals(lhs, rhs map[int32]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

func _Map_Insanity_String_Equals(lhs, rhs []struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !lk.Equals(rk) {
				continue
			}

			if !(lv == rv) {
				return false
			}
			ok = true
			break
		}

		if !ok {
			return false
		}
	}
	return true
}

func _List_Map_Insanity_String_Equals(lhs, rhs [][]struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Map_Insanity_String_Equals(lv, rv) {
			return false
		}
	}

	return true
}

func _Set_List_Map_Insanity_String_sliceType_Equals(lhs, rhs [][][]struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, x := range lhs {
		ok := false
		for _, y := range rhs {
			if _List_Map_Insanity_String_Equals(x, y) {
				ok = true
				break
			}
		}
		if !ok {
			return false
		}
	}

	return true
}

func _Map_I32_Set_List_Map_Insanity_String_sliceType_Equals(lhs, rhs map[int32][][][]struct {
	Key   *Insanity
	Value string
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !_Set_List_Map_Insanity_String_sliceType_Equals(lv, rv) {
			return false
		}
	}
	return true
}

func _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Equals(lhs, rhs []struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for _, i := range lhs {
		lk := i.Key
		lv := i.Value
		ok := false
		for _, j := range rhs {
			rk := j.Key
			rv := j.Value
			if !_Set_I32_mapType_Equals(lk, rk) {
				continue
			}

			if !_Map_I32_Set_List_Map_Insanity_String_sliceType_Equals(lv, rv) {
				return false
			}
			ok = true
			break
		}

		if !ok {
			return false
		}
	}
	return true
}

func _List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Equals(lhs, rhs [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this CrazyNesting match the
// provided CrazyNesting.
//
// This function performs a deep comparison.
func (v *CrazyNesting) Equals(rhs *CrazyNesting) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.StringField, rhs.StringField) {
		return false
	}
	if !((v.SetField == nil && rhs.SetField == nil) || (v.SetField != nil && rhs.SetField != nil && _Set_Insanity_sliceType_Equals(v.SetField, rhs.SetField))) {
		return false
	}
	if !_List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Equals(v.ListField, rhs.ListField) {
		return false
	}
	if !((v.BinaryField == nil && rhs.BinaryField == nil) || (v.BinaryField != nil && rhs.BinaryField != nil && bytes.Equal(v.BinaryField, rhs.BinaryField))) {
		return false
	}

	return true
}

type _Set_Insanity_sliceType_Zapper []*Insanity

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_Insanity_sliceType_Zapper.
func (s _Set_Insanity_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

type _Set_I32_mapType_Zapper map[int32]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_I32_mapType_Zapper.
func (s _Set_I32_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		enc.AppendInt32(v)
	}
	return err
}

type _Map_Insanity_String_Item_Zapper struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Insanity_String_Item_Zapper.
func (v _Map_Insanity_String_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddObject("key", v.Key))
	enc.AddString("value", v.Value)
	return err
}

type _Map_Insanity_String_Zapper []struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Insanity_String_Zapper.
func (m _Map_Insanity_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, i := range m {
		k := i.Key
		v := i.Value
		err = multierr.Append(err, enc.AppendObject(_Map_Insanity_String_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _List_Map_Insanity_String_Zapper [][]struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Map_Insanity_String_Zapper.
func (l _List_Map_Insanity_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_Map_Insanity_String_Zapper)(v)))
	}
	return err
}

type _Set_List_Map_Insanity_String_sliceType_Zapper [][][]struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_List_Map_Insanity_String_sliceType_Zapper.
func (s _Set_List_Map_Insanity_String_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range s {
		err = multierr.Append(err, enc.AppendArray((_List_Map_Insanity_String_Zapper)(v)))
	}
	return err
}

type _Map_I32_Set_List_Map_Insanity_String_sliceType_Item_Zapper struct {
	Key   int32
	Value [][][]struct {
		Key   *Insanity
		Value string
	}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Set_List_Map_Insanity_String_sliceType_Item_Zapper.
func (v _Map_I32_Set_List_Map_Insanity_String_sliceType_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	err = multierr.Append(err, enc.AddArray("value", (_Set_List_Map_Insanity_String_sliceType_Zapper)(v.Value)))
	return err
}

type _Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper map[int32][][][]struct {
	Key   *Insanity
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper.
func (m _Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_Set_List_Map_Insanity_String_sliceType_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Item_Zapper struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Item_Zapper.
func (v _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddArray("key", (_Set_I32_mapType_Zapper)(v.Key)))
	err = multierr.Append(err, enc.AddArray("value", (_Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper)(v.Value)))
	return err
}

type _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper []struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper.
func (m _Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, i := range m {
		k := i.Key
		v := i.Value
		err = multierr.Append(err, enc.AppendObject(_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper.
func (l _List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of CrazyNesting.
func (v *CrazyNesting) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.StringField != nil {
		enc.AddString("string_field", *v.StringField)
	}
	if v.SetField != nil {
		err = multierr.Append(err, enc.AddArray("set_field", (_Set_Insanity_sliceType_Zapper)(v.SetField)))
	}
	err = multierr.Append(err, enc.AddArray("list_field", (_List_Map_Set_I32_mapType_Map_I32_Set_List_Map_Insanity_String_sliceType_Zapper)(v.ListField)))
	if v.BinaryField != nil {
		enc.AddString("binary_field", base64.StdEncoding.EncodeToString(v.BinaryField))
	}
	return err
}

// GetStringField returns the value of StringField if it is set or its
// zero value if it is unset.
func (v *CrazyNesting) GetStringField() (o string) {
	if v != nil && v.StringField != nil {
		return *v.StringField
	}

	return
}

// IsSetStringField returns true if StringField is not nil.
func (v *CrazyNesting) IsSetStringField() bool {
	return v != nil && v.StringField != nil
}

// GetSetField returns the value of SetField if it is set or its
// zero value if it is unset.
func (v *CrazyNesting) GetSetField() (o []*Insanity) {
	if v != nil && v.SetField != nil {
		return v.SetField
	}

	return
}

// IsSetSetField returns true if SetField is not nil.
func (v *CrazyNesting) IsSetSetField() bool {
	return v != nil && v.SetField != nil
}

// GetListField returns the value of ListField if it is set or its
// zero value if it is unset.
func (v *CrazyNesting) GetListField() (o [][]struct {
	Key   map[int32]struct{}
	Value map[int32][][][]struct {
		Key   *Insanity
		Value string
	}
}) {
	if v != nil {
		o = v.ListField
	}
	return
}

// IsSetListField returns true if ListField is not nil.
func (v *CrazyNesting) IsSetListField() bool {
	return v != nil && v.ListField != nil
}

// GetBinaryField returns the value of BinaryField if it is set or its
// zero value if it is unset.
func (v *CrazyNesting) GetBinaryField() (o []byte) {
	if v != nil && v.BinaryField != nil {
		return v.BinaryField
	}

	return
}

// IsSetBinaryField returns true if BinaryField is not nil.
func (v *CrazyNesting) IsSetBinaryField() bool {
	return v != nil && v.BinaryField != nil
}

type EmptyStruct struct {
}

// ToWire translates a EmptyStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *EmptyStruct) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a EmptyStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a EmptyStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v EmptyStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *EmptyStruct) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a EmptyStruct
// struct.
func (v *EmptyStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("EmptyStruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this EmptyStruct match the
// provided EmptyStruct.
//
// This function performs a deep comparison.
func (v *EmptyStruct) Equals(rhs *EmptyStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of EmptyStruct.
func (v *EmptyStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

type GuessProtocolStruct struct {
	MapField map[string]string `json:"map_field,omitempty"`
}

type _Map_String_String_MapItemList map[string]string

func (m _Map_String_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_String_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_String_String_MapItemList) Close() {}

// ToWire translates a GuessProtocolStruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *GuessProtocolStruct) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.MapField != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.MapField)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_String_String_Read(m wire.MapItemList) (map[string]string, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a GuessProtocolStruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a GuessProtocolStruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v GuessProtocolStruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *GuessProtocolStruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 7:
			if field.Value.Type() == wire.TMap {
				v.MapField, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a GuessProtocolStruct
// struct.
func (v *GuessProtocolStruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.MapField != nil {
		fields[i] = fmt.Sprintf("MapField: %v", v.MapField)
		i++
	}

	return fmt.Sprintf("GuessProtocolStruct{%v}", strings.Join(fields[:i], ", "))
}

func _Map_String_String_Equals(lhs, rhs map[string]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this GuessProtocolStruct match the
// provided GuessProtocolStruct.
//
// This function performs a deep comparison.
func (v *GuessProtocolStruct) Equals(rhs *GuessProtocolStruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.MapField == nil && rhs.MapField == nil) || (v.MapField != nil && rhs.MapField != nil && _Map_String_String_Equals(v.MapField, rhs.MapField))) {
		return false
	}

	return true
}

type _Map_String_String_Zapper map[string]string

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_String_Zapper.
func (m _Map_String_String_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		enc.AddString((string)(k), v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of GuessProtocolStruct.
func (v *GuessProtocolStruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.MapField != nil {
		err = multierr.Append(err, enc.AddObject("map_field", (_Map_String_String_Zapper)(v.MapField)))
	}
	return err
}

// GetMapField returns the value of MapField if it is set or its
// zero value if it is unset.
func (v *GuessProtocolStruct) GetMapField() (o map[string]string) {
	if v != nil && v.MapField != nil {
		return v.MapField
	}

	return
}

// IsSetMapField returns true if MapField is not nil.
func (v *GuessProtocolStruct) IsSetMapField() bool {
	return v != nil && v.MapField != nil
}

type Insanity struct {
	UserMap map[Numberz]UserId `json:"userMap,omitempty"`
	Xtructs []*Xtruct          `json:"xtructs,omitempty"`
}

type _Map_Numberz_UserId_MapItemList map[Numberz]UserId

func (m _Map_Numberz_UserId_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Numberz_UserId_MapItemList) Size() int {
	return len(m)
}

func (_Map_Numberz_UserId_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_Numberz_UserId_MapItemList) ValueType() wire.Type {
	return wire.TI64
}

func (_Map_Numberz_UserId_MapItemList) Close() {}

type _List_Xtruct_ValueList []*Xtruct

func (v _List_Xtruct_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Xtruct_ValueList) Size() int {
	return len(v)
}

func (_List_Xtruct_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Xtruct_ValueList) Close() {}

// ToWire translates a Insanity struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Insanity) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.UserMap != nil {
		w, err = wire.NewValueMap(_Map_Numberz_UserId_MapItemList(v.UserMap)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Xtructs != nil {
		w, err = wire.NewValueList(_List_Xtruct_ValueList(v.Xtructs)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Numberz_Read(w wire.Value) (Numberz, error) {
	var v Numberz
	err := v.FromWire(w)
	return v, err
}

func _UserId_Read(w wire.Value) (UserId, error) {
	var x UserId
	err := x.FromWire(w)
	return x, err
}

func _Map_Numberz_UserId_Read(m wire.MapItemList) (map[Numberz]UserId, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TI64 {
		return nil, nil
	}

	o := make(map[Numberz]UserId, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Numberz_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _UserId_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Xtruct_Read(w wire.Value) (*Xtruct, error) {
	var v Xtruct
	err := v.FromWire(w)
	return &v, err
}

func _List_Xtruct_Read(l wire.ValueList) ([]*Xtruct, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Xtruct, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Xtruct_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a Insanity struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Insanity struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Insanity
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Insanity) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.UserMap, err = _Map_Numberz_UserId_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TList {
				v.Xtructs, err = _List_Xtruct_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Insanity
// struct.
func (v *Insanity) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.UserMap != nil {
		fields[i] = fmt.Sprintf("UserMap: %v", v.UserMap)
		i++
	}
	if v.Xtructs != nil {
		fields[i] = fmt.Sprintf("Xtructs: %v", v.Xtructs)
		i++
	}

	return fmt.Sprintf("Insanity{%v}", strings.Join(fields[:i], ", "))
}

func _Map_Numberz_UserId_Equals(lhs, rhs map[Numberz]UserId) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func _List_Xtruct_Equals(lhs, rhs []*Xtruct) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this Insanity match the
// provided Insanity.
//
// This function performs a deep comparison.
func (v *Insanity) Equals(rhs *Insanity) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.UserMap == nil && rhs.UserMap == nil) || (v.UserMap != nil && rhs.UserMap != nil && _Map_Numberz_UserId_Equals(v.UserMap, rhs.UserMap))) {
		return false
	}
	if !((v.Xtructs == nil && rhs.Xtructs == nil) || (v.Xtructs != nil && rhs.Xtructs != nil && _List_Xtruct_Equals(v.Xtructs, rhs.Xtructs))) {
		return false
	}

	return true
}

type _Map_Numberz_UserId_Item_Zapper struct {
	Key   Numberz
	Value UserId
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Numberz_UserId_Item_Zapper.
func (v _Map_Numberz_UserId_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddObject("key", v.Key))
	enc.AddInt64("value", (int64)(v.Value))
	return err
}

type _Map_Numberz_UserId_Zapper map[Numberz]UserId

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Numberz_UserId_Zapper.
func (m _Map_Numberz_UserId_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_Numberz_UserId_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _List_Xtruct_Zapper []*Xtruct

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Xtruct_Zapper.
func (l _List_Xtruct_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Insanity.
func (v *Insanity) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.UserMap != nil {
		err = multierr.Append(err, enc.AddArray("userMap", (_Map_Numberz_UserId_Zapper)(v.UserMap)))
	}
	if v.Xtructs != nil {
		err = multierr.Append(err, enc.AddArray("xtructs", (_List_Xtruct_Zapper)(v.Xtructs)))
	}
	return err
}

// GetUserMap returns the value of UserMap if it is set or its
// zero value if it is unset.
func (v *Insanity) GetUserMap() (o map[Numberz]UserId) {
	if v != nil && v.UserMap != nil {
		return v.UserMap
	}

	return
}

// IsSetUserMap returns true if UserMap is not nil.
func (v *Insanity) IsSetUserMap() bool {
	return v != nil && v.UserMap != nil
}

// GetXtructs returns the value of Xtructs if it is set or its
// zero value if it is unset.
func (v *Insanity) GetXtructs() (o []*Xtruct) {
	if v != nil && v.Xtructs != nil {
		return v.Xtructs
	}

	return
}

// IsSetXtructs returns true if Xtructs is not nil.
func (v *Insanity) IsSetXtructs() bool {
	return v != nil && v.Xtructs != nil
}

type LargeDeltas struct {
	B1         *Bools              `json:"b1,omitempty"`
	B10        *Bools              `json:"b10,omitempty"`
	B100       *Bools              `json:"b100,omitempty"`
	CheckTrue  *bool               `json:"check_true,omitempty"`
	B1000      *Bools              `json:"b1000,omitempty"`
	CheckFalse *bool               `json:"check_false,omitempty"`
	Vertwo2000 *VersioningTestV2   `json:"vertwo2000,omitempty"`
	ASet2500   map[string]struct{} `json:"a_set2500,omitempty"`
	Vertwo3000 *VersioningTestV2   `json:"vertwo3000,omitempty"`
	BigNumbers []int32             `json:"big_numbers,omitempty"`
}

type _Set_String_mapType_ValueList map[string]struct{}

func (v _Set_String_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}

		if err := f(w); err != nil {
			return err
		}
	}
	return nil
}

func (v _Set_String_mapType_ValueList) Size() int {
	return len(v)
}

func (_Set_String_mapType_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Set_String_mapType_ValueList) Close() {}

type _List_I32_ValueList []int32

func (v _List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueI32(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_I32_ValueList) ValueType() wire.Type {
	return wire.TI32
}

func (_List_I32_ValueList) Close() {}

// ToWire translates a LargeDeltas struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *LargeDeltas) ToWire() (wire.Value, error) {
	var (
		fields [10]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.B1 != nil {
		w, err = v.B1.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.B10 != nil {
		w, err = v.B10.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.B100 != nil {
		w, err = v.B100.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 100, Value: w}
		i++
	}
	if v.CheckTrue != nil {
		w, err = wire.NewValueBool(*(v.CheckTrue)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 500, Value: w}
		i++
	}
	if v.B1000 != nil {
		w, err = v.B1000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1000, Value: w}
		i++
	}
	if v.CheckFalse != nil {
		w, err = wire.NewValueBool(*(v.CheckFalse)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1500, Value: w}
		i++
	}
	if v.Vertwo2000 != nil {
		w, err = v.Vertwo2000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2000, Value: w}
		i++
	}
	if v.ASet2500 != nil {
		w, err = wire.NewValueSet(_Set_String_mapType_ValueList(v.ASet2500)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2500, Value: w}
		i++
	}
	if v.Vertwo3000 != nil {
		w, err = v.Vertwo3000.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3000, Value: w}
		i++
	}
	if v.BigNumbers != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.BigNumbers)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4000, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Bools_Read(w wire.Value) (*Bools, error) {
	var v Bools
	err := v.FromWire(w)
	return &v, err
}

func _VersioningTestV2_Read(w wire.Value) (*VersioningTestV2, error) {
	var v VersioningTestV2
	err := v.FromWire(w)
	return &v, err
}

func _Set_String_mapType_Read(s wire.ValueList) (map[string]struct{}, error) {
	if s.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[string]struct{}, s.Size())
	err := s.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[i] = struct{}{}
		return nil
	})
	s.Close()
	return o, err
}

func _List_I32_Read(l wire.ValueList) ([]int32, error) {
	if l.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make([]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetI32(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a LargeDeltas struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a LargeDeltas struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v LargeDeltas
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *LargeDeltas) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.B1, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 10:
			if field.Value.Type() == wire.TStruct {
				v.B10, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 100:
			if field.Value.Type() == wire.TStruct {
				v.B100, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 500:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CheckTrue = &x
				if err != nil {
					return err
				}

			}
		case 1000:
			if field.Value.Type() == wire.TStruct {
				v.B1000, err = _Bools_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1500:
			if field.Value.Type() == wire.TBool {
				var x bool
				x, err = field.Value.GetBool(), error(nil)
				v.CheckFalse = &x
				if err != nil {
					return err
				}

			}
		case 2000:
			if field.Value.Type() == wire.TStruct {
				v.Vertwo2000, err = _VersioningTestV2_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2500:
			if field.Value.Type() == wire.TSet {
				v.ASet2500, err = _Set_String_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 3000:
			if field.Value.Type() == wire.TStruct {
				v.Vertwo3000, err = _VersioningTestV2_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 4000:
			if field.Value.Type() == wire.TList {
				v.BigNumbers, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a LargeDeltas
// struct.
func (v *LargeDeltas) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [10]string
	i := 0
	if v.B1 != nil {
		fields[i] = fmt.Sprintf("B1: %v", v.B1)
		i++
	}
	if v.B10 != nil {
		fields[i] = fmt.Sprintf("B10: %v", v.B10)
		i++
	}
	if v.B100 != nil {
		fields[i] = fmt.Sprintf("B100: %v", v.B100)
		i++
	}
	if v.CheckTrue != nil {
		fields[i] = fmt.Sprintf("CheckTrue: %v", *(v.CheckTrue))
		i++
	}
	if v.B1000 != nil {
		fields[i] = fmt.Sprintf("B1000: %v", v.B1000)
		i++
	}
	if v.CheckFalse != nil {
		fields[i] = fmt.Sprintf("CheckFalse: %v", *(v.CheckFalse))
		i++
	}
	if v.Vertwo2000 != nil {
		fields[i] = fmt.Sprintf("Vertwo2000: %v", v.Vertwo2000)
		i++
	}
	if v.ASet2500 != nil {
		fields[i] = fmt.Sprintf("ASet2500: %v", v.ASet2500)
		i++
	}
	if v.Vertwo3000 != nil {
		fields[i] = fmt.Sprintf("Vertwo3000: %v", v.Vertwo3000)
		i++
	}
	if v.BigNumbers != nil {
		fields[i] = fmt.Sprintf("BigNumbers: %v", v.BigNumbers)
		i++
	}

	return fmt.Sprintf("LargeDeltas{%v}", strings.Join(fields[:i], ", "))
}

func _Set_String_mapType_Equals(lhs, rhs map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for x := range rhs {
		if _, ok := lhs[x]; !ok {
			return false
		}
	}

	return true
}

func _List_I32_Equals(lhs, rhs []int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this LargeDeltas match the
// provided LargeDeltas.
//
// This function performs a deep comparison.
func (v *LargeDeltas) Equals(rhs *LargeDeltas) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.B1 == nil && rhs.B1 == nil) || (v.B1 != nil && rhs.B1 != nil && v.B1.Equals(rhs.B1))) {
		return false
	}
	if !((v.B10 == nil && rhs.B10 == nil) || (v.B10 != nil && rhs.B10 != nil && v.B10.Equals(rhs.B10))) {
		return false
	}
	if !((v.B100 == nil && rhs.B100 == nil) || (v.B100 != nil && rhs.B100 != nil && v.B100.Equals(rhs.B100))) {
		return false
	}
	if !_Bool_EqualsPtr(v.CheckTrue, rhs.CheckTrue) {
		return false
	}
	if !((v.B1000 == nil && rhs.B1000 == nil) || (v.B1000 != nil && rhs.B1000 != nil && v.B1000.Equals(rhs.B1000))) {
		return false
	}
	if !_Bool_EqualsPtr(v.CheckFalse, rhs.CheckFalse) {
		return false
	}
	if !((v.Vertwo2000 == nil && rhs.Vertwo2000 == nil) || (v.Vertwo2000 != nil && rhs.Vertwo2000 != nil && v.Vertwo2000.Equals(rhs.Vertwo2000))) {
		return false
	}
	if !((v.ASet2500 == nil && rhs.ASet2500 == nil) || (v.ASet2500 != nil && rhs.ASet2500 != nil && _Set_String_mapType_Equals(v.ASet2500, rhs.ASet2500))) {
		return false
	}
	if !((v.Vertwo3000 == nil && rhs.Vertwo3000 == nil) || (v.Vertwo3000 != nil && rhs.Vertwo3000 != nil && v.Vertwo3000.Equals(rhs.Vertwo3000))) {
		return false
	}
	if !((v.BigNumbers == nil && rhs.BigNumbers == nil) || (v.BigNumbers != nil && rhs.BigNumbers != nil && _List_I32_Equals(v.BigNumbers, rhs.BigNumbers))) {
		return false
	}

	return true
}

type _Set_String_mapType_Zapper map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Set_String_mapType_Zapper.
func (s _Set_String_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for v := range s {
		enc.AppendString(v)
	}
	return err
}

type _List_I32_Zapper []int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_I32_Zapper.
func (l _List_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendInt32(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of LargeDeltas.
func (v *LargeDeltas) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.B1 != nil {
		err = multierr.Append(err, enc.AddObject("b1", v.B1))
	}
	if v.B10 != nil {
		err = multierr.Append(err, enc.AddObject("b10", v.B10))
	}
	if v.B100 != nil {
		err = multierr.Append(err, enc.AddObject("b100", v.B100))
	}
	if v.CheckTrue != nil {
		enc.AddBool("check_true", *v.CheckTrue)
	}
	if v.B1000 != nil {
		err = multierr.Append(err, enc.AddObject("b1000", v.B1000))
	}
	if v.CheckFalse != nil {
		enc.AddBool("check_false", *v.CheckFalse)
	}
	if v.Vertwo2000 != nil {
		err = multierr.Append(err, enc.AddObject("vertwo2000", v.Vertwo2000))
	}
	if v.ASet2500 != nil {
		err = multierr.Append(err, enc.AddArray("a_set2500", (_Set_String_mapType_Zapper)(v.ASet2500)))
	}
	if v.Vertwo3000 != nil {
		err = multierr.Append(err, enc.AddObject("vertwo3000", v.Vertwo3000))
	}
	if v.BigNumbers != nil {
		err = multierr.Append(err, enc.AddArray("big_numbers", (_List_I32_Zapper)(v.BigNumbers)))
	}
	return err
}

// GetB1 returns the value of B1 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetB1() (o *Bools) {
	if v != nil && v.B1 != nil {
		return v.B1
	}

	return
}

// IsSetB1 returns true if B1 is not nil.
func (v *LargeDeltas) IsSetB1() bool {
	return v != nil && v.B1 != nil
}

// GetB10 returns the value of B10 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetB10() (o *Bools) {
	if v != nil && v.B10 != nil {
		return v.B10
	}

	return
}

// IsSetB10 returns true if B10 is not nil.
func (v *LargeDeltas) IsSetB10() bool {
	return v != nil && v.B10 != nil
}

// GetB100 returns the value of B100 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetB100() (o *Bools) {
	if v != nil && v.B100 != nil {
		return v.B100
	}

	return
}

// IsSetB100 returns true if B100 is not nil.
func (v *LargeDeltas) IsSetB100() bool {
	return v != nil && v.B100 != nil
}

// GetCheckTrue returns the value of CheckTrue if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetCheckTrue() (o bool) {
	if v != nil && v.CheckTrue != nil {
		return *v.CheckTrue
	}

	return
}

// IsSetCheckTrue returns true if CheckTrue is not nil.
func (v *LargeDeltas) IsSetCheckTrue() bool {
	return v != nil && v.CheckTrue != nil
}

// GetB1000 returns the value of B1000 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetB1000() (o *Bools) {
	if v != nil && v.B1000 != nil {
		return v.B1000
	}

	return
}

// IsSetB1000 returns true if B1000 is not nil.
func (v *LargeDeltas) IsSetB1000() bool {
	return v != nil && v.B1000 != nil
}

// GetCheckFalse returns the value of CheckFalse if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetCheckFalse() (o bool) {
	if v != nil && v.CheckFalse != nil {
		return *v.CheckFalse
	}

	return
}

// IsSetCheckFalse returns true if CheckFalse is not nil.
func (v *LargeDeltas) IsSetCheckFalse() bool {
	return v != nil && v.CheckFalse != nil
}

// GetVertwo2000 returns the value of Vertwo2000 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetVertwo2000() (o *VersioningTestV2) {
	if v != nil && v.Vertwo2000 != nil {
		return v.Vertwo2000
	}

	return
}

// IsSetVertwo2000 returns true if Vertwo2000 is not nil.
func (v *LargeDeltas) IsSetVertwo2000() bool {
	return v != nil && v.Vertwo2000 != nil
}

// GetASet2500 returns the value of ASet2500 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetASet2500() (o map[string]struct{}) {
	if v != nil && v.ASet2500 != nil {
		return v.ASet2500
	}

	return
}

// IsSetASet2500 returns true if ASet2500 is not nil.
func (v *LargeDeltas) IsSetASet2500() bool {
	return v != nil && v.ASet2500 != nil
}

// GetVertwo3000 returns the value of Vertwo3000 if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetVertwo3000() (o *VersioningTestV2) {
	if v != nil && v.Vertwo3000 != nil {
		return v.Vertwo3000
	}

	return
}

// IsSetVertwo3000 returns true if Vertwo3000 is not nil.
func (v *LargeDeltas) IsSetVertwo3000() bool {
	return v != nil && v.Vertwo3000 != nil
}

// GetBigNumbers returns the value of BigNumbers if it is set or its
// zero value if it is unset.
func (v *LargeDeltas) GetBigNumbers() (o []int32) {
	if v != nil && v.BigNumbers != nil {
		return v.BigNumbers
	}

	return
}

// IsSetBigNumbers returns true if BigNumbers is not nil.
func (v *LargeDeltas) IsSetBigNumbers() bool {
	return v != nil && v.BigNumbers != nil
}

type ListBonks struct {
	Bonk []*Bonk `json:"bonk,omitempty"`
}

type _List_Bonk_ValueList []*Bonk

func (v _List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := x.ToWire()
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TStruct
}

func (_List_Bonk_ValueList) Close() {}

// ToWire translates a ListBonks struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListBonks) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Bonk != nil {
		w, err = wire.NewValueList(_List_Bonk_ValueList(v.Bonk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Bonk_Read(w wire.Value) (*Bonk, error) {
	var v Bonk
	err := v.FromWire(w)
	return &v, err
}

func _List_Bonk_Read(l wire.ValueList) ([]*Bonk, error) {
	if l.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make([]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Bonk_Read(x)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ListBonks struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListBonks struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListBonks
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListBonks) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Bonk, err = _List_Bonk_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListBonks
// struct.
func (v *ListBonks) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Bonk != nil {
		fields[i] = fmt.Sprintf("Bonk: %v", v.Bonk)
		i++
	}

	return fmt.Sprintf("ListBonks{%v}", strings.Join(fields[:i], ", "))
}

func _List_Bonk_Equals(lhs, rhs []*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !lv.Equals(rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ListBonks match the
// provided ListBonks.
//
// This function performs a deep comparison.
func (v *ListBonks) Equals(rhs *ListBonks) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Bonk == nil && rhs.Bonk == nil) || (v.Bonk != nil && rhs.Bonk != nil && _List_Bonk_Equals(v.Bonk, rhs.Bonk))) {
		return false
	}

	return true
}

type _List_Bonk_Zapper []*Bonk

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Bonk_Zapper.
func (l _List_Bonk_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendObject(v))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListBonks.
func (v *ListBonks) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Bonk != nil {
		err = multierr.Append(err, enc.AddArray("bonk", (_List_Bonk_Zapper)(v.Bonk)))
	}
	return err
}

// GetBonk returns the value of Bonk if it is set or its
// zero value if it is unset.
func (v *ListBonks) GetBonk() (o []*Bonk) {
	if v != nil && v.Bonk != nil {
		return v.Bonk
	}

	return
}

// IsSetBonk returns true if Bonk is not nil.
func (v *ListBonks) IsSetBonk() bool {
	return v != nil && v.Bonk != nil
}

type ListTypeVersioningV1 struct {
	Myints []int32 `json:"myints,omitempty"`
	Hello  *string `json:"hello,omitempty"`
}

// ToWire translates a ListTypeVersioningV1 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListTypeVersioningV1) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Myints != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Myints)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Hello != nil {
		w, err = wire.NewValueString(*(v.Hello)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ListTypeVersioningV1 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListTypeVersioningV1 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListTypeVersioningV1
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListTypeVersioningV1) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Myints, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Hello = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListTypeVersioningV1
// struct.
func (v *ListTypeVersioningV1) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Myints != nil {
		fields[i] = fmt.Sprintf("Myints: %v", v.Myints)
		i++
	}
	if v.Hello != nil {
		fields[i] = fmt.Sprintf("Hello: %v", *(v.Hello))
		i++
	}

	return fmt.Sprintf("ListTypeVersioningV1{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ListTypeVersioningV1 match the
// provided ListTypeVersioningV1.
//
// This function performs a deep comparison.
func (v *ListTypeVersioningV1) Equals(rhs *ListTypeVersioningV1) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Myints == nil && rhs.Myints == nil) || (v.Myints != nil && rhs.Myints != nil && _List_I32_Equals(v.Myints, rhs.Myints))) {
		return false
	}
	if !_String_EqualsPtr(v.Hello, rhs.Hello) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListTypeVersioningV1.
func (v *ListTypeVersioningV1) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Myints != nil {
		err = multierr.Append(err, enc.AddArray("myints", (_List_I32_Zapper)(v.Myints)))
	}
	if v.Hello != nil {
		enc.AddString("hello", *v.Hello)
	}
	return err
}

// GetMyints returns the value of Myints if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV1) GetMyints() (o []int32) {
	if v != nil && v.Myints != nil {
		return v.Myints
	}

	return
}

// IsSetMyints returns true if Myints is not nil.
func (v *ListTypeVersioningV1) IsSetMyints() bool {
	return v != nil && v.Myints != nil
}

// GetHello returns the value of Hello if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV1) GetHello() (o string) {
	if v != nil && v.Hello != nil {
		return *v.Hello
	}

	return
}

// IsSetHello returns true if Hello is not nil.
func (v *ListTypeVersioningV1) IsSetHello() bool {
	return v != nil && v.Hello != nil
}

type ListTypeVersioningV2 struct {
	Strings []string `json:"strings,omitempty"`
	Hello   *string  `json:"hello,omitempty"`
}

type _List_String_ValueList []string

func (v _List_String_ValueList) ForEach(f func(wire.Value) error) error {
	for _, x := range v {
		w, err := wire.NewValueString(x), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_String_ValueList) Size() int {
	return len(v)
}

func (_List_String_ValueList) ValueType() wire.Type {
	return wire.TBinary
}

func (_List_String_ValueList) Close() {}

// ToWire translates a ListTypeVersioningV2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ListTypeVersioningV2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Strings != nil {
		w, err = wire.NewValueList(_List_String_ValueList(v.Strings)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Hello != nil {
		w, err = wire.NewValueString(*(v.Hello)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_String_Read(l wire.ValueList) ([]string, error) {
	if l.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make([]string, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := x.GetString(), error(nil)
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a ListTypeVersioningV2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ListTypeVersioningV2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ListTypeVersioningV2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ListTypeVersioningV2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Strings, err = _List_String_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Hello = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ListTypeVersioningV2
// struct.
func (v *ListTypeVersioningV2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Strings != nil {
		fields[i] = fmt.Sprintf("Strings: %v", v.Strings)
		i++
	}
	if v.Hello != nil {
		fields[i] = fmt.Sprintf("Hello: %v", *(v.Hello))
		i++
	}

	return fmt.Sprintf("ListTypeVersioningV2{%v}", strings.Join(fields[:i], ", "))
}

func _List_String_Equals(lhs, rhs []string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !(lv == rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this ListTypeVersioningV2 match the
// provided ListTypeVersioningV2.
//
// This function performs a deep comparison.
func (v *ListTypeVersioningV2) Equals(rhs *ListTypeVersioningV2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Strings == nil && rhs.Strings == nil) || (v.Strings != nil && rhs.Strings != nil && _List_String_Equals(v.Strings, rhs.Strings))) {
		return false
	}
	if !_String_EqualsPtr(v.Hello, rhs.Hello) {
		return false
	}

	return true
}

type _List_String_Zapper []string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_String_Zapper.
func (l _List_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		enc.AppendString(v)
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ListTypeVersioningV2.
func (v *ListTypeVersioningV2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Strings != nil {
		err = multierr.Append(err, enc.AddArray("strings", (_List_String_Zapper)(v.Strings)))
	}
	if v.Hello != nil {
		enc.AddString("hello", *v.Hello)
	}
	return err
}

// GetStrings returns the value of Strings if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV2) GetStrings() (o []string) {
	if v != nil && v.Strings != nil {
		return v.Strings
	}

	return
}

// IsSetStrings returns true if Strings is not nil.
func (v *ListTypeVersioningV2) IsSetStrings() bool {
	return v != nil && v.Strings != nil
}

// GetHello returns the value of Hello if it is set or its
// zero value if it is unset.
func (v *ListTypeVersioningV2) GetHello() (o string) {
	if v != nil && v.Hello != nil {
		return *v.Hello
	}

	return
}

// IsSetHello returns true if Hello is not nil.
func (v *ListTypeVersioningV2) IsSetHello() bool {
	return v != nil && v.Hello != nil
}

type _Map_String_Bonk_MapItemList map[string]*Bonk

func (m _Map_String_Bonk_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueString(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_String_Bonk_MapItemList) Size() int {
	return len(m)
}

func (_Map_String_Bonk_MapItemList) KeyType() wire.Type {
	return wire.TBinary
}

func (_Map_String_Bonk_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_String_Bonk_MapItemList) Close() {}

func _Map_String_Bonk_Read(m wire.MapItemList) (map[string]*Bonk, error) {
	if m.KeyType() != wire.TBinary {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[string]*Bonk, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetString(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Bonk_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_String_Bonk_Equals(lhs, rhs map[string]*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

type _Map_String_Bonk_Zapper map[string]*Bonk

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of _Map_String_Bonk_Zapper.
func (m _Map_String_Bonk_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AddObject((string)(k), v))
	}
	return err
}

type MapType map[string]*Bonk

// ToWire translates MapType into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v MapType) ToWire() (wire.Value, error) {
	x := (map[string]*Bonk)(v)
	return wire.NewValueMap(_Map_String_Bonk_MapItemList(x)), error(nil)
}

// String returns a readable string representation of MapType.
func (v MapType) String() string {
	x := (map[string]*Bonk)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes MapType from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *MapType) FromWire(w wire.Value) error {
	x, err := _Map_String_Bonk_Read(w.GetMap())
	*v = (MapType)(x)
	return err
}

// Equals returns true if this MapType is equal to the provided
// MapType.
func (lhs MapType) Equals(rhs MapType) bool {
	return _Map_String_Bonk_Equals((map[string]*Bonk)(lhs), (map[string]*Bonk)(rhs))
}

func (v MapType) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	return ((_Map_String_Bonk_Zapper)((map[string]*Bonk)(v))).MarshalLogObject(enc)
}

type NestedListsBonk struct {
	Bonk [][][]*Bonk `json:"bonk,omitempty"`
}

type _List_List_Bonk_ValueList [][]*Bonk

func (v _List_List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_Bonk_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_Bonk_ValueList) Close() {}

type _List_List_List_Bonk_ValueList [][][]*Bonk

func (v _List_List_List_Bonk_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_List_Bonk_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_List_Bonk_ValueList) Size() int {
	return len(v)
}

func (_List_List_List_Bonk_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_List_Bonk_ValueList) Close() {}

// ToWire translates a NestedListsBonk struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedListsBonk) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Bonk != nil {
		w, err = wire.NewValueList(_List_List_List_Bonk_ValueList(v.Bonk)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_Bonk_Read(l wire.ValueList) ([][]*Bonk, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_Bonk_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _List_List_List_Bonk_Read(l wire.ValueList) ([][][]*Bonk, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][][]*Bonk, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_List_Bonk_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedListsBonk struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedListsBonk struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedListsBonk
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedListsBonk) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Bonk, err = _List_List_List_Bonk_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedListsBonk
// struct.
func (v *NestedListsBonk) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Bonk != nil {
		fields[i] = fmt.Sprintf("Bonk: %v", v.Bonk)
		i++
	}

	return fmt.Sprintf("NestedListsBonk{%v}", strings.Join(fields[:i], ", "))
}

func _List_List_Bonk_Equals(lhs, rhs [][]*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_Bonk_Equals(lv, rv) {
			return false
		}
	}

	return true
}

func _List_List_List_Bonk_Equals(lhs, rhs [][][]*Bonk) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_List_Bonk_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedListsBonk match the
// provided NestedListsBonk.
//
// This function performs a deep comparison.
func (v *NestedListsBonk) Equals(rhs *NestedListsBonk) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Bonk == nil && rhs.Bonk == nil) || (v.Bonk != nil && rhs.Bonk != nil && _List_List_List_Bonk_Equals(v.Bonk, rhs.Bonk))) {
		return false
	}

	return true
}

type _List_List_Bonk_Zapper [][]*Bonk

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_List_Bonk_Zapper.
func (l _List_List_Bonk_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_List_Bonk_Zapper)(v)))
	}
	return err
}

type _List_List_List_Bonk_Zapper [][][]*Bonk

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_List_List_Bonk_Zapper.
func (l _List_List_List_Bonk_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_List_List_Bonk_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of NestedListsBonk.
func (v *NestedListsBonk) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Bonk != nil {
		err = multierr.Append(err, enc.AddArray("bonk", (_List_List_List_Bonk_Zapper)(v.Bonk)))
	}
	return err
}

// GetBonk returns the value of Bonk if it is set or its
// zero value if it is unset.
func (v *NestedListsBonk) GetBonk() (o [][][]*Bonk) {
	if v != nil && v.Bonk != nil {
		return v.Bonk
	}

	return
}

// IsSetBonk returns true if Bonk is not nil.
func (v *NestedListsBonk) IsSetBonk() bool {
	return v != nil && v.Bonk != nil
}

type NestedListsI32x2 struct {
	Integerlist [][]int32 `json:"integerlist,omitempty"`
}

type _List_List_I32_ValueList [][]int32

func (v _List_List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_List_I32_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_I32_ValueList) Close() {}

// ToWire translates a NestedListsI32x2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedListsI32x2) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Integerlist != nil {
		w, err = wire.NewValueList(_List_List_I32_ValueList(v.Integerlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_I32_Read(l wire.ValueList) ([][]int32, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_I32_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedListsI32x2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedListsI32x2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedListsI32x2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedListsI32x2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Integerlist, err = _List_List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedListsI32x2
// struct.
func (v *NestedListsI32x2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Integerlist != nil {
		fields[i] = fmt.Sprintf("Integerlist: %v", v.Integerlist)
		i++
	}

	return fmt.Sprintf("NestedListsI32x2{%v}", strings.Join(fields[:i], ", "))
}

func _List_List_I32_Equals(lhs, rhs [][]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_I32_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedListsI32x2 match the
// provided NestedListsI32x2.
//
// This function performs a deep comparison.
func (v *NestedListsI32x2) Equals(rhs *NestedListsI32x2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Integerlist == nil && rhs.Integerlist == nil) || (v.Integerlist != nil && rhs.Integerlist != nil && _List_List_I32_Equals(v.Integerlist, rhs.Integerlist))) {
		return false
	}

	return true
}

type _List_List_I32_Zapper [][]int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_List_I32_Zapper.
func (l _List_List_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_List_I32_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of NestedListsI32x2.
func (v *NestedListsI32x2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Integerlist != nil {
		err = multierr.Append(err, enc.AddArray("integerlist", (_List_List_I32_Zapper)(v.Integerlist)))
	}
	return err
}

// GetIntegerlist returns the value of Integerlist if it is set or its
// zero value if it is unset.
func (v *NestedListsI32x2) GetIntegerlist() (o [][]int32) {
	if v != nil && v.Integerlist != nil {
		return v.Integerlist
	}

	return
}

// IsSetIntegerlist returns true if Integerlist is not nil.
func (v *NestedListsI32x2) IsSetIntegerlist() bool {
	return v != nil && v.Integerlist != nil
}

type NestedListsI32x3 struct {
	Integerlist [][][]int32 `json:"integerlist,omitempty"`
}

type _List_List_List_I32_ValueList [][][]int32

func (v _List_List_List_I32_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueList(_List_List_I32_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_List_List_I32_ValueList) Size() int {
	return len(v)
}

func (_List_List_List_I32_ValueList) ValueType() wire.Type {
	return wire.TList
}

func (_List_List_List_I32_ValueList) Close() {}

// ToWire translates a NestedListsI32x3 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedListsI32x3) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Integerlist != nil {
		w, err = wire.NewValueList(_List_List_List_I32_ValueList(v.Integerlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_List_List_I32_Read(l wire.ValueList) ([][][]int32, error) {
	if l.ValueType() != wire.TList {
		return nil, nil
	}

	o := make([][][]int32, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _List_List_I32_Read(x.GetList())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedListsI32x3 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedListsI32x3 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedListsI32x3
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedListsI32x3) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Integerlist, err = _List_List_List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedListsI32x3
// struct.
func (v *NestedListsI32x3) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Integerlist != nil {
		fields[i] = fmt.Sprintf("Integerlist: %v", v.Integerlist)
		i++
	}

	return fmt.Sprintf("NestedListsI32x3{%v}", strings.Join(fields[:i], ", "))
}

func _List_List_List_I32_Equals(lhs, rhs [][][]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_List_List_I32_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedListsI32x3 match the
// provided NestedListsI32x3.
//
// This function performs a deep comparison.
func (v *NestedListsI32x3) Equals(rhs *NestedListsI32x3) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Integerlist == nil && rhs.Integerlist == nil) || (v.Integerlist != nil && rhs.Integerlist != nil && _List_List_List_I32_Equals(v.Integerlist, rhs.Integerlist))) {
		return false
	}

	return true
}

type _List_List_List_I32_Zapper [][][]int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_List_List_I32_Zapper.
func (l _List_List_List_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_List_List_I32_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of NestedListsI32x3.
func (v *NestedListsI32x3) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Integerlist != nil {
		err = multierr.Append(err, enc.AddArray("integerlist", (_List_List_List_I32_Zapper)(v.Integerlist)))
	}
	return err
}

// GetIntegerlist returns the value of Integerlist if it is set or its
// zero value if it is unset.
func (v *NestedListsI32x3) GetIntegerlist() (o [][][]int32) {
	if v != nil && v.Integerlist != nil {
		return v.Integerlist
	}

	return
}

// IsSetIntegerlist returns true if Integerlist is not nil.
func (v *NestedListsI32x3) IsSetIntegerlist() bool {
	return v != nil && v.Integerlist != nil
}

type NestedMixedx2 struct {
	IntSetList       []map[int32]struct{}            `json:"int_set_list,omitempty"`
	MapIntStrset     map[int32]map[string]struct{}   `json:"map_int_strset,omitempty"`
	MapIntStrsetList []map[int32]map[string]struct{} `json:"map_int_strset_list,omitempty"`
}

type _List_Set_I32_mapType_ValueList []map[int32]struct{}

func (v _List_Set_I32_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueSet(_Set_I32_mapType_ValueList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Set_I32_mapType_ValueList) Size() int {
	return len(v)
}

func (_List_Set_I32_mapType_ValueList) ValueType() wire.Type {
	return wire.TSet
}

func (_List_Set_I32_mapType_ValueList) Close() {}

type _Map_I32_Set_String_mapType_MapItemList map[int32]map[string]struct{}

func (m _Map_I32_Set_String_mapType_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueSet(_Set_String_mapType_ValueList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Set_String_mapType_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Set_String_mapType_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Set_String_mapType_MapItemList) ValueType() wire.Type {
	return wire.TSet
}

func (_Map_I32_Set_String_mapType_MapItemList) Close() {}

type _List_Map_I32_Set_String_mapType_ValueList []map[int32]map[string]struct{}

func (v _List_Map_I32_Set_String_mapType_ValueList) ForEach(f func(wire.Value) error) error {
	for i, x := range v {
		if x == nil {
			return fmt.Errorf("invalid [%v]: value is nil", i)
		}
		w, err := wire.NewValueMap(_Map_I32_Set_String_mapType_MapItemList(x)), error(nil)
		if err != nil {
			return err
		}
		err = f(w)
		if err != nil {
			return err
		}
	}
	return nil
}

func (v _List_Map_I32_Set_String_mapType_ValueList) Size() int {
	return len(v)
}

func (_List_Map_I32_Set_String_mapType_ValueList) ValueType() wire.Type {
	return wire.TMap
}

func (_List_Map_I32_Set_String_mapType_ValueList) Close() {}

// ToWire translates a NestedMixedx2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *NestedMixedx2) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.IntSetList != nil {
		w, err = wire.NewValueList(_List_Set_I32_mapType_ValueList(v.IntSetList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.MapIntStrset != nil {
		w, err = wire.NewValueMap(_Map_I32_Set_String_mapType_MapItemList(v.MapIntStrset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.MapIntStrsetList != nil {
		w, err = wire.NewValueList(_List_Map_I32_Set_String_mapType_ValueList(v.MapIntStrsetList)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _List_Set_I32_mapType_Read(l wire.ValueList) ([]map[int32]struct{}, error) {
	if l.ValueType() != wire.TSet {
		return nil, nil
	}

	o := make([]map[int32]struct{}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Set_I32_mapType_Read(x.GetSet())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

func _Map_I32_Set_String_mapType_Read(m wire.MapItemList) (map[int32]map[string]struct{}, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TSet {
		return nil, nil
	}

	o := make(map[int32]map[string]struct{}, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Set_String_mapType_Read(x.Value.GetSet())
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _List_Map_I32_Set_String_mapType_Read(l wire.ValueList) ([]map[int32]map[string]struct{}, error) {
	if l.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make([]map[int32]map[string]struct{}, 0, l.Size())
	err := l.ForEach(func(x wire.Value) error {
		i, err := _Map_I32_Set_String_mapType_Read(x.GetMap())
		if err != nil {
			return err
		}
		o = append(o, i)
		return nil
	})
	l.Close()
	return o, err
}

// FromWire deserializes a NestedMixedx2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a NestedMixedx2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v NestedMixedx2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *NestedMixedx2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.IntSetList, err = _List_Set_I32_mapType_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TMap {
				v.MapIntStrset, err = _Map_I32_Set_String_mapType_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TList {
				v.MapIntStrsetList, err = _List_Map_I32_Set_String_mapType_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a NestedMixedx2
// struct.
func (v *NestedMixedx2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.IntSetList != nil {
		fields[i] = fmt.Sprintf("IntSetList: %v", v.IntSetList)
		i++
	}
	if v.MapIntStrset != nil {
		fields[i] = fmt.Sprintf("MapIntStrset: %v", v.MapIntStrset)
		i++
	}
	if v.MapIntStrsetList != nil {
		fields[i] = fmt.Sprintf("MapIntStrsetList: %v", v.MapIntStrsetList)
		i++
	}

	return fmt.Sprintf("NestedMixedx2{%v}", strings.Join(fields[:i], ", "))
}

func _List_Set_I32_mapType_Equals(lhs, rhs []map[int32]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Set_I32_mapType_Equals(lv, rv) {
			return false
		}
	}

	return true
}

func _Map_I32_Set_String_mapType_Equals(lhs, rhs map[int32]map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !_Set_String_mapType_Equals(lv, rv) {
			return false
		}
	}
	return true
}

func _List_Map_I32_Set_String_mapType_Equals(lhs, rhs []map[int32]map[string]struct{}) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for i, lv := range lhs {
		rv := rhs[i]
		if !_Map_I32_Set_String_mapType_Equals(lv, rv) {
			return false
		}
	}

	return true
}

// Equals returns true if all the fields of this NestedMixedx2 match the
// provided NestedMixedx2.
//
// This function performs a deep comparison.
func (v *NestedMixedx2) Equals(rhs *NestedMixedx2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.IntSetList == nil && rhs.IntSetList == nil) || (v.IntSetList != nil && rhs.IntSetList != nil && _List_Set_I32_mapType_Equals(v.IntSetList, rhs.IntSetList))) {
		return false
	}
	if !((v.MapIntStrset == nil && rhs.MapIntStrset == nil) || (v.MapIntStrset != nil && rhs.MapIntStrset != nil && _Map_I32_Set_String_mapType_Equals(v.MapIntStrset, rhs.MapIntStrset))) {
		return false
	}
	if !((v.MapIntStrsetList == nil && rhs.MapIntStrsetList == nil) || (v.MapIntStrsetList != nil && rhs.MapIntStrsetList != nil && _List_Map_I32_Set_String_mapType_Equals(v.MapIntStrsetList, rhs.MapIntStrsetList))) {
		return false
	}

	return true
}

type _List_Set_I32_mapType_Zapper []map[int32]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Set_I32_mapType_Zapper.
func (l _List_Set_I32_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_Set_I32_mapType_Zapper)(v)))
	}
	return err
}

type _Map_I32_Set_String_mapType_Item_Zapper struct {
	Key   int32
	Value map[string]struct{}
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Set_String_mapType_Item_Zapper.
func (v _Map_I32_Set_String_mapType_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	err = multierr.Append(err, enc.AddArray("value", (_Set_String_mapType_Zapper)(v.Value)))
	return err
}

type _Map_I32_Set_String_mapType_Zapper map[int32]map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Set_String_mapType_Zapper.
func (m _Map_I32_Set_String_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_Set_String_mapType_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _List_Map_I32_Set_String_mapType_Zapper []map[int32]map[string]struct{}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _List_Map_I32_Set_String_mapType_Zapper.
func (l _List_Map_I32_Set_String_mapType_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for _, v := range l {
		err = multierr.Append(err, enc.AppendArray((_Map_I32_Set_String_mapType_Zapper)(v)))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of NestedMixedx2.
func (v *NestedMixedx2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.IntSetList != nil {
		err = multierr.Append(err, enc.AddArray("int_set_list", (_List_Set_I32_mapType_Zapper)(v.IntSetList)))
	}
	if v.MapIntStrset != nil {
		err = multierr.Append(err, enc.AddArray("map_int_strset", (_Map_I32_Set_String_mapType_Zapper)(v.MapIntStrset)))
	}
	if v.MapIntStrsetList != nil {
		err = multierr.Append(err, enc.AddArray("map_int_strset_list", (_List_Map_I32_Set_String_mapType_Zapper)(v.MapIntStrsetList)))
	}
	return err
}

// GetIntSetList returns the value of IntSetList if it is set or its
// zero value if it is unset.
func (v *NestedMixedx2) GetIntSetList() (o []map[int32]struct{}) {
	if v != nil && v.IntSetList != nil {
		return v.IntSetList
	}

	return
}

// IsSetIntSetList returns true if IntSetList is not nil.
func (v *NestedMixedx2) IsSetIntSetList() bool {
	return v != nil && v.IntSetList != nil
}

// GetMapIntStrset returns the value of MapIntStrset if it is set or its
// zero value if it is unset.
func (v *NestedMixedx2) GetMapIntStrset() (o map[int32]map[string]struct{}) {
	if v != nil && v.MapIntStrset != nil {
		return v.MapIntStrset
	}

	return
}

// IsSetMapIntStrset returns true if MapIntStrset is not nil.
func (v *NestedMixedx2) IsSetMapIntStrset() bool {
	return v != nil && v.MapIntStrset != nil
}

// GetMapIntStrsetList returns the value of MapIntStrsetList if it is set or its
// zero value if it is unset.
func (v *NestedMixedx2) GetMapIntStrsetList() (o []map[int32]map[string]struct{}) {
	if v != nil && v.MapIntStrsetList != nil {
		return v.MapIntStrsetList
	}

	return
}

// IsSetMapIntStrsetList returns true if MapIntStrsetList is not nil.
func (v *NestedMixedx2) IsSetMapIntStrsetList() bool {
	return v != nil && v.MapIntStrsetList != nil
}

// Docstring!
type Numberz int32

const (
	NumberzOne   Numberz = 1
	NumberzTwo   Numberz = 2
	NumberzThree Numberz = 3
	NumberzFive  Numberz = 5
	NumberzSix   Numberz = 6
	NumberzEight Numberz = 8
)

// Numberz_Values returns all recognized values of Numberz.
func Numberz_Values() []Numberz {
	return []Numberz{
		NumberzOne,
		NumberzTwo,
		NumberzThree,
		NumberzFive,
		NumberzSix,
		NumberzEight,
	}
}

// UnmarshalText tries to decode Numberz from a byte slice
// containing its name.
//
//   var v Numberz
//   err := v.UnmarshalText([]byte("ONE"))
func (v *Numberz) UnmarshalText(value []byte) error {
	switch s := string(value); s {
	case "ONE":
		*v = NumberzOne
		return nil
	case "TWO":
		*v = NumberzTwo
		return nil
	case "THREE":
		*v = NumberzThree
		return nil
	case "FIVE":
		*v = NumberzFive
		return nil
	case "SIX":
		*v = NumberzSix
		return nil
	case "EIGHT":
		*v = NumberzEight
		return nil
	default:
		val, err := strconv.ParseInt(s, 10, 32)
		if err != nil {
			return fmt.Errorf("unknown enum value %q for %q: %v", s, "Numberz", err)
		}
		*v = Numberz(val)
		return nil
	}
}

// MarshalText encodes Numberz to text.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements the TextMarshaler interface.
func (v Numberz) MarshalText() ([]byte, error) {
	switch int32(v) {
	case 1:
		return []byte("ONE"), nil
	case 2:
		return []byte("TWO"), nil
	case 3:
		return []byte("THREE"), nil
	case 5:
		return []byte("FIVE"), nil
	case 6:
		return []byte("SIX"), nil
	case 8:
		return []byte("EIGHT"), nil
	}
	return []byte(strconv.FormatInt(int64(v), 10)), nil
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Numberz.
// Enums are logged as objects, where the value is logged with key "value", and
// if this value's name is known, the name is logged with key "name".
func (v Numberz) MarshalLogObject(enc zapcore.ObjectEncoder) error {
	enc.AddInt32("value", int32(v))
	switch int32(v) {
	case 1:
		enc.AddString("name", "ONE")
	case 2:
		enc.AddString("name", "TWO")
	case 3:
		enc.AddString("name", "THREE")
	case 5:
		enc.AddString("name", "FIVE")
	case 6:
		enc.AddString("name", "SIX")
	case 8:
		enc.AddString("name", "EIGHT")
	}
	return nil
}

// Ptr returns a pointer to this enum value.
func (v Numberz) Ptr() *Numberz {
	return &v
}

// ToWire translates Numberz into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// Enums are represented as 32-bit integers over the wire.
func (v Numberz) ToWire() (wire.Value, error) {
	return wire.NewValueI32(int32(v)), nil
}

// FromWire deserializes Numberz from its Thrift-level
// representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TI32)
//   if err != nil {
//     return Numberz(0), err
//   }
//
//   var v Numberz
//   if err := v.FromWire(x); err != nil {
//     return Numberz(0), err
//   }
//   return v, nil
func (v *Numberz) FromWire(w wire.Value) error {
	*v = (Numberz)(w.GetI32())
	return nil
}

// String returns a readable string representation of Numberz.
func (v Numberz) String() string {
	w := int32(v)
	switch w {
	case 1:
		return "ONE"
	case 2:
		return "TWO"
	case 3:
		return "THREE"
	case 5:
		return "FIVE"
	case 6:
		return "SIX"
	case 8:
		return "EIGHT"
	}
	return fmt.Sprintf("Numberz(%d)", w)
}

// Equals returns true if this Numberz value matches the provided
// value.
func (v Numberz) Equals(rhs Numberz) bool {
	return v == rhs
}

// MarshalJSON serializes Numberz into JSON.
//
// If the enum value is recognized, its name is returned. Otherwise,
// its integer value is returned.
//
// This implements json.Marshaler.
func (v Numberz) MarshalJSON() ([]byte, error) {
	switch int32(v) {
	case 1:
		return ([]byte)("\"ONE\""), nil
	case 2:
		return ([]byte)("\"TWO\""), nil
	case 3:
		return ([]byte)("\"THREE\""), nil
	case 5:
		return ([]byte)("\"FIVE\""), nil
	case 6:
		return ([]byte)("\"SIX\""), nil
	case 8:
		return ([]byte)("\"EIGHT\""), nil
	}
	return ([]byte)(strconv.FormatInt(int64(v), 10)), nil
}

// UnmarshalJSON attempts to decode Numberz from its JSON
// representation.
//
// This implementation supports both, numeric and string inputs. If a
// string is provided, it must be a known enum name.
//
// This implements json.Unmarshaler.
func (v *Numberz) UnmarshalJSON(text []byte) error {
	d := json.NewDecoder(bytes.NewReader(text))
	d.UseNumber()
	t, err := d.Token()
	if err != nil {
		return err
	}

	switch w := t.(type) {
	case json.Number:
		x, err := w.Int64()
		if err != nil {
			return err
		}
		if x > math.MaxInt32 {
			return fmt.Errorf("enum overflow from JSON %q for %q", text, "Numberz")
		}
		if x < math.MinInt32 {
			return fmt.Errorf("enum underflow from JSON %q for %q", text, "Numberz")
		}
		*v = (Numberz)(x)
		return nil
	case string:
		return v.UnmarshalText([]byte(w))
	default:
		return fmt.Errorf("invalid JSON value %q (%T) to unmarshal into %q", t, t, "Numberz")
	}
}

type OneField struct {
	Field *EmptyStruct `json:"field,omitempty"`
}

// ToWire translates a OneField struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *OneField) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Field != nil {
		w, err = v.Field.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _EmptyStruct_Read(w wire.Value) (*EmptyStruct, error) {
	var v EmptyStruct
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a OneField struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a OneField struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v OneField
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *OneField) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Field, err = _EmptyStruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a OneField
// struct.
func (v *OneField) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Field != nil {
		fields[i] = fmt.Sprintf("Field: %v", v.Field)
		i++
	}

	return fmt.Sprintf("OneField{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this OneField match the
// provided OneField.
//
// This function performs a deep comparison.
func (v *OneField) Equals(rhs *OneField) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Field == nil && rhs.Field == nil) || (v.Field != nil && rhs.Field != nil && v.Field.Equals(rhs.Field))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of OneField.
func (v *OneField) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Field != nil {
		err = multierr.Append(err, enc.AddObject("field", v.Field))
	}
	return err
}

// GetField returns the value of Field if it is set or its
// zero value if it is unset.
func (v *OneField) GetField() (o *EmptyStruct) {
	if v != nil && v.Field != nil {
		return v.Field
	}

	return
}

// IsSetField returns true if Field is not nil.
func (v *OneField) IsSetField() bool {
	return v != nil && v.Field != nil
}

type StructA struct {
	S string `json:"s,required"`
}

// ToWire translates a StructA struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StructA) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	w, err = wire.NewValueString(v.S), error(nil)
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 1, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a StructA struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StructA struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StructA
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StructA) FromWire(w wire.Value) error {
	var err error

	sIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.S, err = field.Value.GetString(), error(nil)
				if err != nil {
					return err
				}
				sIsSet = true
			}
		}
	}

	if !sIsSet {
		return errors.New("field S of StructA is required")
	}

	return nil
}

// String returns a readable string representation of a StructA
// struct.
func (v *StructA) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	fields[i] = fmt.Sprintf("S: %v", v.S)
	i++

	return fmt.Sprintf("StructA{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StructA match the
// provided StructA.
//
// This function performs a deep comparison.
func (v *StructA) Equals(rhs *StructA) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !(v.S == rhs.S) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StructA.
func (v *StructA) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	enc.AddString("s", v.S)
	return err
}

// GetS returns the value of S if it is set or its
// zero value if it is unset.
func (v *StructA) GetS() (o string) {
	if v != nil {
		o = v.S
	}
	return
}

type StructB struct {
	Aa *StructA `json:"aa,omitempty"`
	Ab *StructA `json:"ab,required"`
}

// ToWire translates a StructB struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *StructB) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Aa != nil {
		w, err = v.Aa.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Ab == nil {
		return w, errors.New("field Ab of StructB is required")
	}
	w, err = v.Ab.ToWire()
	if err != nil {
		return w, err
	}
	fields[i] = wire.Field{ID: 2, Value: w}
	i++

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _StructA_Read(w wire.Value) (*StructA, error) {
	var v StructA
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a StructB struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a StructB struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v StructB
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *StructB) FromWire(w wire.Value) error {
	var err error

	abIsSet := false

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Aa, err = _StructA_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Ab, err = _StructA_Read(field.Value)
				if err != nil {
					return err
				}
				abIsSet = true
			}
		}
	}

	if !abIsSet {
		return errors.New("field Ab of StructB is required")
	}

	return nil
}

// String returns a readable string representation of a StructB
// struct.
func (v *StructB) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Aa != nil {
		fields[i] = fmt.Sprintf("Aa: %v", v.Aa)
		i++
	}
	fields[i] = fmt.Sprintf("Ab: %v", v.Ab)
	i++

	return fmt.Sprintf("StructB{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this StructB match the
// provided StructB.
//
// This function performs a deep comparison.
func (v *StructB) Equals(rhs *StructB) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Aa == nil && rhs.Aa == nil) || (v.Aa != nil && rhs.Aa != nil && v.Aa.Equals(rhs.Aa))) {
		return false
	}
	if !v.Ab.Equals(rhs.Ab) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of StructB.
func (v *StructB) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Aa != nil {
		err = multierr.Append(err, enc.AddObject("aa", v.Aa))
	}
	err = multierr.Append(err, enc.AddObject("ab", v.Ab))
	return err
}

// GetAa returns the value of Aa if it is set or its
// zero value if it is unset.
func (v *StructB) GetAa() (o *StructA) {
	if v != nil && v.Aa != nil {
		return v.Aa
	}

	return
}

// IsSetAa returns true if Aa is not nil.
func (v *StructB) IsSetAa() bool {
	return v != nil && v.Aa != nil
}

// GetAb returns the value of Ab if it is set or its
// zero value if it is unset.
func (v *StructB) GetAb() (o *StructA) {
	if v != nil {
		o = v.Ab
	}
	return
}

// IsSetAb returns true if Ab is not nil.
func (v *StructB) IsSetAb() bool {
	return v != nil && v.Ab != nil
}

type UserId int64

// UserIdPtr returns a pointer to a UserId
func (v UserId) Ptr() *UserId {
	return &v
}

// ToWire translates UserId into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
func (v UserId) ToWire() (wire.Value, error) {
	x := (int64)(v)
	return wire.NewValueI64(x), error(nil)
}

// String returns a readable string representation of UserId.
func (v UserId) String() string {
	x := (int64)(v)
	return fmt.Sprint(x)
}

// FromWire deserializes UserId from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
func (v *UserId) FromWire(w wire.Value) error {
	x, err := w.GetI64(), error(nil)
	*v = (UserId)(x)
	return err
}

// Equals returns true if this UserId is equal to the provided
// UserId.
func (lhs UserId) Equals(rhs UserId) bool {
	return ((int64)(lhs) == (int64)(rhs))
}

type VersioningTestV1 struct {
	BeginInBoth *int32  `json:"begin_in_both,omitempty"`
	OldString   *string `json:"old_string,omitempty"`
	EndInBoth   *int32  `json:"end_in_both,omitempty"`
}

// ToWire translates a VersioningTestV1 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *VersioningTestV1) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BeginInBoth != nil {
		w, err = wire.NewValueI32(*(v.BeginInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.OldString != nil {
		w, err = wire.NewValueString(*(v.OldString)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.EndInBoth != nil {
		w, err = wire.NewValueI32(*(v.EndInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a VersioningTestV1 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a VersioningTestV1 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v VersioningTestV1
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *VersioningTestV1) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BeginInBoth = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.OldString = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EndInBoth = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a VersioningTestV1
// struct.
func (v *VersioningTestV1) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.BeginInBoth != nil {
		fields[i] = fmt.Sprintf("BeginInBoth: %v", *(v.BeginInBoth))
		i++
	}
	if v.OldString != nil {
		fields[i] = fmt.Sprintf("OldString: %v", *(v.OldString))
		i++
	}
	if v.EndInBoth != nil {
		fields[i] = fmt.Sprintf("EndInBoth: %v", *(v.EndInBoth))
		i++
	}

	return fmt.Sprintf("VersioningTestV1{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this VersioningTestV1 match the
// provided VersioningTestV1.
//
// This function performs a deep comparison.
func (v *VersioningTestV1) Equals(rhs *VersioningTestV1) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.BeginInBoth, rhs.BeginInBoth) {
		return false
	}
	if !_String_EqualsPtr(v.OldString, rhs.OldString) {
		return false
	}
	if !_I32_EqualsPtr(v.EndInBoth, rhs.EndInBoth) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of VersioningTestV1.
func (v *VersioningTestV1) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BeginInBoth != nil {
		enc.AddInt32("begin_in_both", *v.BeginInBoth)
	}
	if v.OldString != nil {
		enc.AddString("old_string", *v.OldString)
	}
	if v.EndInBoth != nil {
		enc.AddInt32("end_in_both", *v.EndInBoth)
	}
	return err
}

// GetBeginInBoth returns the value of BeginInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV1) GetBeginInBoth() (o int32) {
	if v != nil && v.BeginInBoth != nil {
		return *v.BeginInBoth
	}

	return
}

// IsSetBeginInBoth returns true if BeginInBoth is not nil.
func (v *VersioningTestV1) IsSetBeginInBoth() bool {
	return v != nil && v.BeginInBoth != nil
}

// GetOldString returns the value of OldString if it is set or its
// zero value if it is unset.
func (v *VersioningTestV1) GetOldString() (o string) {
	if v != nil && v.OldString != nil {
		return *v.OldString
	}

	return
}

// IsSetOldString returns true if OldString is not nil.
func (v *VersioningTestV1) IsSetOldString() bool {
	return v != nil && v.OldString != nil
}

// GetEndInBoth returns the value of EndInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV1) GetEndInBoth() (o int32) {
	if v != nil && v.EndInBoth != nil {
		return *v.EndInBoth
	}

	return
}

// IsSetEndInBoth returns true if EndInBoth is not nil.
func (v *VersioningTestV1) IsSetEndInBoth() bool {
	return v != nil && v.EndInBoth != nil
}

type VersioningTestV2 struct {
	BeginInBoth *int32             `json:"begin_in_both,omitempty"`
	Newint      *int32             `json:"newint,omitempty"`
	Newbyte     *int8              `json:"newbyte,omitempty"`
	Newshort    *int16             `json:"newshort,omitempty"`
	Newlong     *int64             `json:"newlong,omitempty"`
	Newdouble   *float64           `json:"newdouble,omitempty"`
	Newstruct   *Bonk              `json:"newstruct,omitempty"`
	Newlist     []int32            `json:"newlist,omitempty"`
	Newset      map[int32]struct{} `json:"newset,omitempty"`
	Newmap      map[int32]int32    `json:"newmap,omitempty"`
	Newstring   *string            `json:"newstring,omitempty"`
	EndInBoth   *int32             `json:"end_in_both,omitempty"`
}

type _Map_I32_I32_MapItemList map[int32]int32

func (m _Map_I32_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueI32(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_I32_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_I32_MapItemList) ValueType() wire.Type {
	return wire.TI32
}

func (_Map_I32_I32_MapItemList) Close() {}

// ToWire translates a VersioningTestV2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *VersioningTestV2) ToWire() (wire.Value, error) {
	var (
		fields [12]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.BeginInBoth != nil {
		w, err = wire.NewValueI32(*(v.BeginInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Newint != nil {
		w, err = wire.NewValueI32(*(v.Newint)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Newbyte != nil {
		w, err = wire.NewValueI8(*(v.Newbyte)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Newshort != nil {
		w, err = wire.NewValueI16(*(v.Newshort)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Newlong != nil {
		w, err = wire.NewValueI64(*(v.Newlong)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Newdouble != nil {
		w, err = wire.NewValueDouble(*(v.Newdouble)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}
	if v.Newstruct != nil {
		w, err = v.Newstruct.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 7, Value: w}
		i++
	}
	if v.Newlist != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Newlist)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 8, Value: w}
		i++
	}
	if v.Newset != nil {
		w, err = wire.NewValueSet(_Set_I32_mapType_ValueList(v.Newset)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.Newmap != nil {
		w, err = wire.NewValueMap(_Map_I32_I32_MapItemList(v.Newmap)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 10, Value: w}
		i++
	}
	if v.Newstring != nil {
		w, err = wire.NewValueString(*(v.Newstring)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}
	if v.EndInBoth != nil {
		w, err = wire.NewValueI32(*(v.EndInBoth)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 12, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_I32_I32_Read(m wire.MapItemList) (map[int32]int32, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TI32 {
		return nil, nil
	}

	o := make(map[int32]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetI32(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a VersioningTestV2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a VersioningTestV2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v VersioningTestV2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *VersioningTestV2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.BeginInBoth = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Newint = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.Newbyte = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI16 {
				var x int16
				x, err = field.Value.GetI16(), error(nil)
				v.Newshort = &x
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Newlong = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.Newdouble = &x
				if err != nil {
					return err
				}

			}
		case 7:
			if field.Value.Type() == wire.TStruct {
				v.Newstruct, err = _Bonk_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 8:
			if field.Value.Type() == wire.TList {
				v.Newlist, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TSet {
				v.Newset, err = _Set_I32_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		case 10:
			if field.Value.Type() == wire.TMap {
				v.Newmap, err = _Map_I32_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Newstring = &x
				if err != nil {
					return err
				}

			}
		case 12:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.EndInBoth = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a VersioningTestV2
// struct.
func (v *VersioningTestV2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [12]string
	i := 0
	if v.BeginInBoth != nil {
		fields[i] = fmt.Sprintf("BeginInBoth: %v", *(v.BeginInBoth))
		i++
	}
	if v.Newint != nil {
		fields[i] = fmt.Sprintf("Newint: %v", *(v.Newint))
		i++
	}
	if v.Newbyte != nil {
		fields[i] = fmt.Sprintf("Newbyte: %v", *(v.Newbyte))
		i++
	}
	if v.Newshort != nil {
		fields[i] = fmt.Sprintf("Newshort: %v", *(v.Newshort))
		i++
	}
	if v.Newlong != nil {
		fields[i] = fmt.Sprintf("Newlong: %v", *(v.Newlong))
		i++
	}
	if v.Newdouble != nil {
		fields[i] = fmt.Sprintf("Newdouble: %v", *(v.Newdouble))
		i++
	}
	if v.Newstruct != nil {
		fields[i] = fmt.Sprintf("Newstruct: %v", v.Newstruct)
		i++
	}
	if v.Newlist != nil {
		fields[i] = fmt.Sprintf("Newlist: %v", v.Newlist)
		i++
	}
	if v.Newset != nil {
		fields[i] = fmt.Sprintf("Newset: %v", v.Newset)
		i++
	}
	if v.Newmap != nil {
		fields[i] = fmt.Sprintf("Newmap: %v", v.Newmap)
		i++
	}
	if v.Newstring != nil {
		fields[i] = fmt.Sprintf("Newstring: %v", *(v.Newstring))
		i++
	}
	if v.EndInBoth != nil {
		fields[i] = fmt.Sprintf("EndInBoth: %v", *(v.EndInBoth))
		i++
	}

	return fmt.Sprintf("VersioningTestV2{%v}", strings.Join(fields[:i], ", "))
}

func _Byte_EqualsPtr(lhs, rhs *int8) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I16_EqualsPtr(lhs, rhs *int16) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _I64_EqualsPtr(lhs, rhs *int64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Double_EqualsPtr(lhs, rhs *float64) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

func _Map_I32_I32_Equals(lhs, rhs map[int32]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this VersioningTestV2 match the
// provided VersioningTestV2.
//
// This function performs a deep comparison.
func (v *VersioningTestV2) Equals(rhs *VersioningTestV2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.BeginInBoth, rhs.BeginInBoth) {
		return false
	}
	if !_I32_EqualsPtr(v.Newint, rhs.Newint) {
		return false
	}
	if !_Byte_EqualsPtr(v.Newbyte, rhs.Newbyte) {
		return false
	}
	if !_I16_EqualsPtr(v.Newshort, rhs.Newshort) {
		return false
	}
	if !_I64_EqualsPtr(v.Newlong, rhs.Newlong) {
		return false
	}
	if !_Double_EqualsPtr(v.Newdouble, rhs.Newdouble) {
		return false
	}
	if !((v.Newstruct == nil && rhs.Newstruct == nil) || (v.Newstruct != nil && rhs.Newstruct != nil && v.Newstruct.Equals(rhs.Newstruct))) {
		return false
	}
	if !((v.Newlist == nil && rhs.Newlist == nil) || (v.Newlist != nil && rhs.Newlist != nil && _List_I32_Equals(v.Newlist, rhs.Newlist))) {
		return false
	}
	if !((v.Newset == nil && rhs.Newset == nil) || (v.Newset != nil && rhs.Newset != nil && _Set_I32_mapType_Equals(v.Newset, rhs.Newset))) {
		return false
	}
	if !((v.Newmap == nil && rhs.Newmap == nil) || (v.Newmap != nil && rhs.Newmap != nil && _Map_I32_I32_Equals(v.Newmap, rhs.Newmap))) {
		return false
	}
	if !_String_EqualsPtr(v.Newstring, rhs.Newstring) {
		return false
	}
	if !_I32_EqualsPtr(v.EndInBoth, rhs.EndInBoth) {
		return false
	}

	return true
}

type _Map_I32_I32_Item_Zapper struct {
	Key   int32
	Value int32
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_I32_Item_Zapper.
func (v _Map_I32_I32_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	enc.AddInt32("value", v.Value)
	return err
}

type _Map_I32_I32_Zapper map[int32]int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_I32_Zapper.
func (m _Map_I32_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_I32_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of VersioningTestV2.
func (v *VersioningTestV2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.BeginInBoth != nil {
		enc.AddInt32("begin_in_both", *v.BeginInBoth)
	}
	if v.Newint != nil {
		enc.AddInt32("newint", *v.Newint)
	}
	if v.Newbyte != nil {
		enc.AddInt8("newbyte", *v.Newbyte)
	}
	if v.Newshort != nil {
		enc.AddInt16("newshort", *v.Newshort)
	}
	if v.Newlong != nil {
		enc.AddInt64("newlong", *v.Newlong)
	}
	if v.Newdouble != nil {
		enc.AddFloat64("newdouble", *v.Newdouble)
	}
	if v.Newstruct != nil {
		err = multierr.Append(err, enc.AddObject("newstruct", v.Newstruct))
	}
	if v.Newlist != nil {
		err = multierr.Append(err, enc.AddArray("newlist", (_List_I32_Zapper)(v.Newlist)))
	}
	if v.Newset != nil {
		err = multierr.Append(err, enc.AddArray("newset", (_Set_I32_mapType_Zapper)(v.Newset)))
	}
	if v.Newmap != nil {
		err = multierr.Append(err, enc.AddArray("newmap", (_Map_I32_I32_Zapper)(v.Newmap)))
	}
	if v.Newstring != nil {
		enc.AddString("newstring", *v.Newstring)
	}
	if v.EndInBoth != nil {
		enc.AddInt32("end_in_both", *v.EndInBoth)
	}
	return err
}

// GetBeginInBoth returns the value of BeginInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetBeginInBoth() (o int32) {
	if v != nil && v.BeginInBoth != nil {
		return *v.BeginInBoth
	}

	return
}

// IsSetBeginInBoth returns true if BeginInBoth is not nil.
func (v *VersioningTestV2) IsSetBeginInBoth() bool {
	return v != nil && v.BeginInBoth != nil
}

// GetNewint returns the value of Newint if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewint() (o int32) {
	if v != nil && v.Newint != nil {
		return *v.Newint
	}

	return
}

// IsSetNewint returns true if Newint is not nil.
func (v *VersioningTestV2) IsSetNewint() bool {
	return v != nil && v.Newint != nil
}

// GetNewbyte returns the value of Newbyte if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewbyte() (o int8) {
	if v != nil && v.Newbyte != nil {
		return *v.Newbyte
	}

	return
}

// IsSetNewbyte returns true if Newbyte is not nil.
func (v *VersioningTestV2) IsSetNewbyte() bool {
	return v != nil && v.Newbyte != nil
}

// GetNewshort returns the value of Newshort if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewshort() (o int16) {
	if v != nil && v.Newshort != nil {
		return *v.Newshort
	}

	return
}

// IsSetNewshort returns true if Newshort is not nil.
func (v *VersioningTestV2) IsSetNewshort() bool {
	return v != nil && v.Newshort != nil
}

// GetNewlong returns the value of Newlong if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewlong() (o int64) {
	if v != nil && v.Newlong != nil {
		return *v.Newlong
	}

	return
}

// IsSetNewlong returns true if Newlong is not nil.
func (v *VersioningTestV2) IsSetNewlong() bool {
	return v != nil && v.Newlong != nil
}

// GetNewdouble returns the value of Newdouble if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewdouble() (o float64) {
	if v != nil && v.Newdouble != nil {
		return *v.Newdouble
	}

	return
}

// IsSetNewdouble returns true if Newdouble is not nil.
func (v *VersioningTestV2) IsSetNewdouble() bool {
	return v != nil && v.Newdouble != nil
}

// GetNewstruct returns the value of Newstruct if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewstruct() (o *Bonk) {
	if v != nil && v.Newstruct != nil {
		return v.Newstruct
	}

	return
}

// IsSetNewstruct returns true if Newstruct is not nil.
func (v *VersioningTestV2) IsSetNewstruct() bool {
	return v != nil && v.Newstruct != nil
}

// GetNewlist returns the value of Newlist if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewlist() (o []int32) {
	if v != nil && v.Newlist != nil {
		return v.Newlist
	}

	return
}

// IsSetNewlist returns true if Newlist is not nil.
func (v *VersioningTestV2) IsSetNewlist() bool {
	return v != nil && v.Newlist != nil
}

// GetNewset returns the value of Newset if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewset() (o map[int32]struct{}) {
	if v != nil && v.Newset != nil {
		return v.Newset
	}

	return
}

// IsSetNewset returns true if Newset is not nil.
func (v *VersioningTestV2) IsSetNewset() bool {
	return v != nil && v.Newset != nil
}

// GetNewmap returns the value of Newmap if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewmap() (o map[int32]int32) {
	if v != nil && v.Newmap != nil {
		return v.Newmap
	}

	return
}

// IsSetNewmap returns true if Newmap is not nil.
func (v *VersioningTestV2) IsSetNewmap() bool {
	return v != nil && v.Newmap != nil
}

// GetNewstring returns the value of Newstring if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetNewstring() (o string) {
	if v != nil && v.Newstring != nil {
		return *v.Newstring
	}

	return
}

// IsSetNewstring returns true if Newstring is not nil.
func (v *VersioningTestV2) IsSetNewstring() bool {
	return v != nil && v.Newstring != nil
}

// GetEndInBoth returns the value of EndInBoth if it is set or its
// zero value if it is unset.
func (v *VersioningTestV2) GetEndInBoth() (o int32) {
	if v != nil && v.EndInBoth != nil {
		return *v.EndInBoth
	}

	return
}

// IsSetEndInBoth returns true if EndInBoth is not nil.
func (v *VersioningTestV2) IsSetEndInBoth() bool {
	return v != nil && v.EndInBoth != nil
}

type Xception struct {
	ErrorCode *int32  `json:"errorCode,omitempty"`
	Message   *string `json:"message,omitempty"`
}

// ToWire translates a Xception struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xception) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Message != nil {
		w, err = wire.NewValueString(*(v.Message)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xception struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xception struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xception
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xception) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Message = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xception
// struct.
func (v *Xception) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	if v.Message != nil {
		fields[i] = fmt.Sprintf("Message: %v", *(v.Message))
		i++
	}

	return fmt.Sprintf("Xception{%v}", strings.Join(fields[:i], ", "))
}

// ErrorName is the name of this type as defined in the Thrift
// file.
func (*Xception) ErrorName() string {
	return "Xception"
}

// Equals returns true if all the fields of this Xception match the
// provided Xception.
//
// This function performs a deep comparison.
func (v *Xception) Equals(rhs *Xception) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}
	if !_String_EqualsPtr(v.Message, rhs.Message) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xception.
func (v *Xception) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ErrorCode != nil {
		enc.AddInt32("errorCode", *v.ErrorCode)
	}
	if v.Message != nil {
		enc.AddString("message", *v.Message)
	}
	return err
}

// GetErrorCode returns the value of ErrorCode if it is set or its
// zero value if it is unset.
func (v *Xception) GetErrorCode() (o int32) {
	if v != nil && v.ErrorCode != nil {
		return *v.ErrorCode
	}

	return
}

// IsSetErrorCode returns true if ErrorCode is not nil.
func (v *Xception) IsSetErrorCode() bool {
	return v != nil && v.ErrorCode != nil
}

// GetMessage returns the value of Message if it is set or its
// zero value if it is unset.
func (v *Xception) GetMessage() (o string) {
	if v != nil && v.Message != nil {
		return *v.Message
	}

	return
}

// IsSetMessage returns true if Message is not nil.
func (v *Xception) IsSetMessage() bool {
	return v != nil && v.Message != nil
}

func (v *Xception) Error() string {
	return v.String()
}

type Xception2 struct {
	ErrorCode   *int32  `json:"errorCode,omitempty"`
	StructThing *Xtruct `json:"struct_thing,omitempty"`
}

// ToWire translates a Xception2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xception2) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ErrorCode != nil {
		w, err = wire.NewValueI32(*(v.ErrorCode)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StructThing != nil {
		w, err = v.StructThing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xception2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xception2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xception2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xception2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.ErrorCode = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.StructThing, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xception2
// struct.
func (v *Xception2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.ErrorCode != nil {
		fields[i] = fmt.Sprintf("ErrorCode: %v", *(v.ErrorCode))
		i++
	}
	if v.StructThing != nil {
		fields[i] = fmt.Sprintf("StructThing: %v", v.StructThing)
		i++
	}

	return fmt.Sprintf("Xception2{%v}", strings.Join(fields[:i], ", "))
}

// ErrorName is the name of this type as defined in the Thrift
// file.
func (*Xception2) ErrorName() string {
	return "Xception2"
}

// Equals returns true if all the fields of this Xception2 match the
// provided Xception2.
//
// This function performs a deep comparison.
func (v *Xception2) Equals(rhs *Xception2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.ErrorCode, rhs.ErrorCode) {
		return false
	}
	if !((v.StructThing == nil && rhs.StructThing == nil) || (v.StructThing != nil && rhs.StructThing != nil && v.StructThing.Equals(rhs.StructThing))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xception2.
func (v *Xception2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ErrorCode != nil {
		enc.AddInt32("errorCode", *v.ErrorCode)
	}
	if v.StructThing != nil {
		err = multierr.Append(err, enc.AddObject("struct_thing", v.StructThing))
	}
	return err
}

// GetErrorCode returns the value of ErrorCode if it is set or its
// zero value if it is unset.
func (v *Xception2) GetErrorCode() (o int32) {
	if v != nil && v.ErrorCode != nil {
		return *v.ErrorCode
	}

	return
}

// IsSetErrorCode returns true if ErrorCode is not nil.
func (v *Xception2) IsSetErrorCode() bool {
	return v != nil && v.ErrorCode != nil
}

// GetStructThing returns the value of StructThing if it is set or its
// zero value if it is unset.
func (v *Xception2) GetStructThing() (o *Xtruct) {
	if v != nil && v.StructThing != nil {
		return v.StructThing
	}

	return
}

// IsSetStructThing returns true if StructThing is not nil.
func (v *Xception2) IsSetStructThing() bool {
	return v != nil && v.StructThing != nil
}

func (v *Xception2) Error() string {
	return v.String()
}

type Xtruct struct {
	StringThing *string `json:"string_thing,omitempty"`
	ByteThing   *int8   `json:"byte_thing,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
	I64Thing    *int64  `json:"i64_thing,omitempty"`
}

// ToWire translates a Xtruct struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xtruct) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StringThing != nil {
		w, err = wire.NewValueString(*(v.StringThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.ByteThing != nil {
		w, err = wire.NewValueI8(*(v.ByteThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.I64Thing != nil {
		w, err = wire.NewValueI64(*(v.I64Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xtruct struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xtruct struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xtruct
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xtruct) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringThing = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteThing = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.I64Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xtruct
// struct.
func (v *Xtruct) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.StringThing != nil {
		fields[i] = fmt.Sprintf("StringThing: %v", *(v.StringThing))
		i++
	}
	if v.ByteThing != nil {
		fields[i] = fmt.Sprintf("ByteThing: %v", *(v.ByteThing))
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}
	if v.I64Thing != nil {
		fields[i] = fmt.Sprintf("I64Thing: %v", *(v.I64Thing))
		i++
	}

	return fmt.Sprintf("Xtruct{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xtruct match the
// provided Xtruct.
//
// This function performs a deep comparison.
func (v *Xtruct) Equals(rhs *Xtruct) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.StringThing, rhs.StringThing) {
		return false
	}
	if !_Byte_EqualsPtr(v.ByteThing, rhs.ByteThing) {
		return false
	}
	if !_I32_EqualsPtr(v.I32Thing, rhs.I32Thing) {
		return false
	}
	if !_I64_EqualsPtr(v.I64Thing, rhs.I64Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xtruct.
func (v *Xtruct) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.StringThing != nil {
		enc.AddString("string_thing", *v.StringThing)
	}
	if v.ByteThing != nil {
		enc.AddInt8("byte_thing", *v.ByteThing)
	}
	if v.I32Thing != nil {
		enc.AddInt32("i32_thing", *v.I32Thing)
	}
	if v.I64Thing != nil {
		enc.AddInt64("i64_thing", *v.I64Thing)
	}
	return err
}

// GetStringThing returns the value of StringThing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetStringThing() (o string) {
	if v != nil && v.StringThing != nil {
		return *v.StringThing
	}

	return
}

// IsSetStringThing returns true if StringThing is not nil.
func (v *Xtruct) IsSetStringThing() bool {
	return v != nil && v.StringThing != nil
}

// GetByteThing returns the value of ByteThing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetByteThing() (o int8) {
	if v != nil && v.ByteThing != nil {
		return *v.ByteThing
	}

	return
}

// IsSetByteThing returns true if ByteThing is not nil.
func (v *Xtruct) IsSetByteThing() bool {
	return v != nil && v.ByteThing != nil
}

// GetI32Thing returns the value of I32Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetI32Thing() (o int32) {
	if v != nil && v.I32Thing != nil {
		return *v.I32Thing
	}

	return
}

// IsSetI32Thing returns true if I32Thing is not nil.
func (v *Xtruct) IsSetI32Thing() bool {
	return v != nil && v.I32Thing != nil
}

// GetI64Thing returns the value of I64Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct) GetI64Thing() (o int64) {
	if v != nil && v.I64Thing != nil {
		return *v.I64Thing
	}

	return
}

// IsSetI64Thing returns true if I64Thing is not nil.
func (v *Xtruct) IsSetI64Thing() bool {
	return v != nil && v.I64Thing != nil
}

type Xtruct2 struct {
	ByteThing   *int8   `json:"byte_thing,omitempty"`
	StructThing *Xtruct `json:"struct_thing,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
}

// ToWire translates a Xtruct2 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xtruct2) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.ByteThing != nil {
		w, err = wire.NewValueI8(*(v.ByteThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.StructThing != nil {
		w, err = v.StructThing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xtruct2 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xtruct2 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xtruct2
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xtruct2) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.ByteThing = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.StructThing, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xtruct2
// struct.
func (v *Xtruct2) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.ByteThing != nil {
		fields[i] = fmt.Sprintf("ByteThing: %v", *(v.ByteThing))
		i++
	}
	if v.StructThing != nil {
		fields[i] = fmt.Sprintf("StructThing: %v", v.StructThing)
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}

	return fmt.Sprintf("Xtruct2{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xtruct2 match the
// provided Xtruct2.
//
// This function performs a deep comparison.
func (v *Xtruct2) Equals(rhs *Xtruct2) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Byte_EqualsPtr(v.ByteThing, rhs.ByteThing) {
		return false
	}
	if !((v.StructThing == nil && rhs.StructThing == nil) || (v.StructThing != nil && rhs.StructThing != nil && v.StructThing.Equals(rhs.StructThing))) {
		return false
	}
	if !_I32_EqualsPtr(v.I32Thing, rhs.I32Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xtruct2.
func (v *Xtruct2) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.ByteThing != nil {
		enc.AddInt8("byte_thing", *v.ByteThing)
	}
	if v.StructThing != nil {
		err = multierr.Append(err, enc.AddObject("struct_thing", v.StructThing))
	}
	if v.I32Thing != nil {
		enc.AddInt32("i32_thing", *v.I32Thing)
	}
	return err
}

// GetByteThing returns the value of ByteThing if it is set or its
// zero value if it is unset.
func (v *Xtruct2) GetByteThing() (o int8) {
	if v != nil && v.ByteThing != nil {
		return *v.ByteThing
	}

	return
}

// IsSetByteThing returns true if ByteThing is not nil.
func (v *Xtruct2) IsSetByteThing() bool {
	return v != nil && v.ByteThing != nil
}

// GetStructThing returns the value of StructThing if it is set or its
// zero value if it is unset.
func (v *Xtruct2) GetStructThing() (o *Xtruct) {
	if v != nil && v.StructThing != nil {
		return v.StructThing
	}

	return
}

// IsSetStructThing returns true if StructThing is not nil.
func (v *Xtruct2) IsSetStructThing() bool {
	return v != nil && v.StructThing != nil
}

// GetI32Thing returns the value of I32Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct2) GetI32Thing() (o int32) {
	if v != nil && v.I32Thing != nil {
		return *v.I32Thing
	}

	return
}

// IsSetI32Thing returns true if I32Thing is not nil.
func (v *Xtruct2) IsSetI32Thing() bool {
	return v != nil && v.I32Thing != nil
}

type Xtruct3 struct {
	StringThing *string `json:"string_thing,omitempty"`
	Changed     *int32  `json:"changed,omitempty"`
	I32Thing    *int32  `json:"i32_thing,omitempty"`
	I64Thing    *int64  `json:"i64_thing,omitempty"`
}

// ToWire translates a Xtruct3 struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *Xtruct3) ToWire() (wire.Value, error) {
	var (
		fields [4]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.StringThing != nil {
		w, err = wire.NewValueString(*(v.StringThing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Changed != nil {
		w, err = wire.NewValueI32(*(v.Changed)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.I32Thing != nil {
		w, err = wire.NewValueI32(*(v.I32Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 9, Value: w}
		i++
	}
	if v.I64Thing != nil {
		w, err = wire.NewValueI64(*(v.I64Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 11, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a Xtruct3 struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a Xtruct3 struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v Xtruct3
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *Xtruct3) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.StringThing = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Changed = &x
				if err != nil {
					return err
				}

			}
		case 9:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.I32Thing = &x
				if err != nil {
					return err
				}

			}
		case 11:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.I64Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a Xtruct3
// struct.
func (v *Xtruct3) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [4]string
	i := 0
	if v.StringThing != nil {
		fields[i] = fmt.Sprintf("StringThing: %v", *(v.StringThing))
		i++
	}
	if v.Changed != nil {
		fields[i] = fmt.Sprintf("Changed: %v", *(v.Changed))
		i++
	}
	if v.I32Thing != nil {
		fields[i] = fmt.Sprintf("I32Thing: %v", *(v.I32Thing))
		i++
	}
	if v.I64Thing != nil {
		fields[i] = fmt.Sprintf("I64Thing: %v", *(v.I64Thing))
		i++
	}

	return fmt.Sprintf("Xtruct3{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this Xtruct3 match the
// provided Xtruct3.
//
// This function performs a deep comparison.
func (v *Xtruct3) Equals(rhs *Xtruct3) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.StringThing, rhs.StringThing) {
		return false
	}
	if !_I32_EqualsPtr(v.Changed, rhs.Changed) {
		return false
	}
	if !_I32_EqualsPtr(v.I32Thing, rhs.I32Thing) {
		return false
	}
	if !_I64_EqualsPtr(v.I64Thing, rhs.I64Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of Xtruct3.
func (v *Xtruct3) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.StringThing != nil {
		enc.AddString("string_thing", *v.StringThing)
	}
	if v.Changed != nil {
		enc.AddInt32("changed", *v.Changed)
	}
	if v.I32Thing != nil {
		enc.AddInt32("i32_thing", *v.I32Thing)
	}
	if v.I64Thing != nil {
		enc.AddInt64("i64_thing", *v.I64Thing)
	}
	return err
}

// GetStringThing returns the value of StringThing if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetStringThing() (o string) {
	if v != nil && v.StringThing != nil {
		return *v.StringThing
	}

	return
}

// IsSetStringThing returns true if StringThing is not nil.
func (v *Xtruct3) IsSetStringThing() bool {
	return v != nil && v.StringThing != nil
}

// GetChanged returns the value of Changed if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetChanged() (o int32) {
	if v != nil && v.Changed != nil {
		return *v.Changed
	}

	return
}

// IsSetChanged returns true if Changed is not nil.
func (v *Xtruct3) IsSetChanged() bool {
	return v != nil && v.Changed != nil
}

// GetI32Thing returns the value of I32Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetI32Thing() (o int32) {
	if v != nil && v.I32Thing != nil {
		return *v.I32Thing
	}

	return
}

// IsSetI32Thing returns true if I32Thing is not nil.
func (v *Xtruct3) IsSetI32Thing() bool {
	return v != nil && v.I32Thing != nil
}

// GetI64Thing returns the value of I64Thing if it is set or its
// zero value if it is unset.
func (v *Xtruct3) GetI64Thing() (o int64) {
	if v != nil && v.I64Thing != nil {
		return *v.I64Thing
	}

	return
}

// IsSetI64Thing returns true if I64Thing is not nil.
func (v *Xtruct3) IsSetI64Thing() bool {
	return v != nil && v.I64Thing != nil
}

// ThriftModule represents the IDL file used to generate this package.
var ThriftModule = &thriftreflect.ThriftModule{
	Name:     "gauntlet",
	Package:  "go.uber.org/yarpc/internal/crossdock/thrift/gauntlet",
	FilePath: "gauntlet.thrift",
	SHA1:     "f308242071d9c9c31fb8faa1e1a79eeefa46316d",
	Raw:      rawIDL,
}

const rawIDL = "/**\n * Thrift file used by Apache Thrift's test suite, DO NOT EDIT!\n * Lifted from: https://thrift.apache.org/docs/idl\n */\n\nnamespace c_glib TTest\nnamespace java thrift.test\nnamespace cpp thrift.test\nnamespace rb Thrift.Test\nnamespace perl ThriftTest\nnamespace csharp Thrift.Test\nnamespace js ThriftTest\nnamespace st ThriftTest\nnamespace py ThriftTest\nnamespace py.twisted ThriftTest\nnamespace go thrifttest\nnamespace php ThriftTest\nnamespace delphi Thrift.Test\nnamespace cocoa ThriftTest\nnamespace lua ThriftTest\n\n// Presence of namespaces and sub-namespaces for which there is\n// no generator should compile with warnings only\nnamespace noexist ThriftTest\nnamespace cpp.noexist ThriftTest\n\nnamespace * thrift.test\n\n/**\n * Docstring!\n */\nenum Numberz\n{\n  ONE = 1,\n  TWO,\n  THREE,\n  FIVE = 5,\n  SIX,\n  EIGHT = 8\n}\n\nconst Numberz myNumberz = Numberz.ONE;\n// the following is expected to fail:\n// const Numberz urNumberz = ONE;\n\ntypedef i64 UserId\n\nstruct Bonk\n{\n  1: optional string message,\n  2: optional i32 type\n}\n\ntypedef map<string,Bonk> MapType\n\nstruct Bools {\n  1: optional bool im_true,\n  2: optional bool im_false,\n}\n\nstruct Xtruct\n{\n  1:  optional string string_thing,\n  4:  optional byte   byte_thing,\n  9:  optional i32    i32_thing,\n  11: optional i64    i64_thing\n}\n\nstruct Xtruct2\n{\n  1: optional byte   byte_thing,\n  2: optional Xtruct struct_thing,\n  3: optional i32    i32_thing\n}\n\nstruct Xtruct3\n{\n  1:  optional string string_thing,\n  4:  optional i32    changed,\n  9:  optional i32    i32_thing,\n  11: optional i64    i64_thing\n}\n\n\nstruct Insanity\n{\n  1: optional map<Numberz, UserId> userMap,\n  2: optional list<Xtruct> xtructs\n}\n\nstruct CrazyNesting {\n  1: optional string string_field,\n  2: optional set<Insanity> set_field,\n  3: required list< map<set<i32>,map<i32,set<list<map<Insanity,string>>>>>> list_field,\n  4: optional binary binary_field\n}\n\nexception Xception {\n  1: optional i32 errorCode,\n  2: optional string message\n}\n\nexception Xception2 {\n  1: optional i32 errorCode,\n  2: optional Xtruct struct_thing\n}\n\nstruct EmptyStruct {}\n\nstruct OneField {\n  1: optional EmptyStruct field\n}\n\nservice ThriftTest\n{\n  /**\n   * Prints \"testVoid()\" and returns nothing.\n   */\n  void         testVoid(),\n\n  /**\n   * Prints 'testString(\"%s\")' with thing as '%s'\n   * @param string thing - the string to print\n   * @return string - returns the string 'thing'\n   */\n  string       testString(1: string thing),\n\n  /**\n   * Prints 'testByte(\"%d\")' with thing as '%d'\n   * @param byte thing - the byte to print\n   * @return byte - returns the byte 'thing'\n   */\n  byte         testByte(1: byte thing),\n\n  /**\n   * Prints 'testI32(\"%d\")' with thing as '%d'\n   * @param i32 thing - the i32 to print\n   * @return i32 - returns the i32 'thing'\n   */\n  i32          testI32(1: i32 thing),\n\n  /**\n   * Prints 'testI64(\"%d\")' with thing as '%d'\n   * @param i64 thing - the i64 to print\n   * @return i64 - returns the i64 'thing'\n   */\n  i64          testI64(1: i64 thing),\n\n  /**\n   * Prints 'testDouble(\"%f\")' with thing as '%f'\n   * @param double thing - the double to print\n   * @return double - returns the double 'thing'\n   */\n  double       testDouble(1: double thing),\n\n  /**\n   * Prints 'testBinary(\"%s\")' where '%s' is a hex-formatted string of thing's data\n   * @param binary  thing - the binary data to print\n   * @return binary  - returns the binary 'thing'\n   */\n  binary       testBinary(1: binary thing),\n\n  /**\n   * Prints 'testStruct(\"{%s}\")' where thing has been formatted into a string of comma separated values\n   * @param Xtruct thing - the Xtruct to print\n   * @return Xtruct - returns the Xtruct 'thing'\n   */\n  Xtruct       testStruct(1: Xtruct thing),\n\n  /**\n   * Prints 'testNest(\"{%s}\")' where thing has been formatted into a string of the nested struct\n   * @param Xtruct2 thing - the Xtruct2 to print\n   * @return Xtruct2 - returns the Xtruct2 'thing'\n   */\n  Xtruct2      testNest(1: Xtruct2 thing),\n\n  /**\n   * Prints 'testMap(\"{%s\")' where thing has been formatted into a string of  'key => value' pairs\n   *  separated by commas and new lines\n   * @param map<i32,i32> thing - the map<i32,i32> to print\n   * @return map<i32,i32> - returns the map<i32,i32> 'thing'\n   */\n  map<i32,i32> testMap(1: map<i32,i32> thing),\n\n  /**\n   * Prints 'testStringMap(\"{%s}\")' where thing has been formatted into a string of  'key => value' pairs\n   *  separated by commas and new lines\n   * @param map<string,string> thing - the map<string,string> to print\n   * @return map<string,string> - returns the map<string,string> 'thing'\n   */\n  map<string,string> testStringMap(1: map<string,string> thing),\n\n  /**\n   * Prints 'testSet(\"{%s}\")' where thing has been formatted into a string of  values\n   *  separated by commas and new lines\n   * @param set<i32> thing - the set<i32> to print\n   * @return set<i32> - returns the set<i32> 'thing'\n   */\n  set<i32>     testSet(1: set<i32> thing),\n\n  /**\n   * Prints 'testList(\"{%s}\")' where thing has been formatted into a string of  values\n   *  separated by commas and new lines\n   * @param list<i32> thing - the list<i32> to print\n   * @return list<i32> - returns the list<i32> 'thing'\n   */\n  list<i32>    testList(1: list<i32> thing),\n\n  /**\n   * Prints 'testEnum(\"%d\")' where thing has been formatted into it's numeric value\n   * @param Numberz thing - the Numberz to print\n   * @return Numberz - returns the Numberz 'thing'\n   */\n  Numberz      testEnum(1: Numberz thing),\n\n  /**\n   * Prints 'testTypedef(\"%d\")' with thing as '%d'\n   * @param UserId thing - the UserId to print\n   * @return UserId - returns the UserId 'thing'\n   */\n  UserId       testTypedef(1: UserId thing),\n\n  /**\n   * Prints 'testMapMap(\"%d\")' with hello as '%d'\n   * @param i32 hello - the i32 to print\n   * @return map<i32,map<i32,i32>> - returns a dictionary with these values:\n   *   {-4 => {-4 => -4, -3 => -3, -2 => -2, -1 => -1, }, 4 => {1 => 1, 2 => 2, 3 => 3, 4 => 4, }, }\n   */\n  map<i32,map<i32,i32>> testMapMap(1: i32 hello),\n\n  /**\n   * So you think you've got this all worked, out eh?\n   *\n   * Creates a the returned map with these values and prints it out:\n   *   { 1 => { 2 => argument,\n   *            3 => argument,\n   *          },\n   *     2 => { 6 => <empty Insanity struct>, },\n   *   }\n   * @return map<UserId, map<Numberz,Insanity>> - a map with the above values\n   */\n  map<UserId, map<Numberz,Insanity>> testInsanity(1: Insanity argument),\n\n  /**\n   * Prints 'testMulti()'\n   * @param byte arg0 -\n   * @param i32 arg1 -\n   * @param i64 arg2 -\n   * @param map<i16, string> arg3 -\n   * @param Numberz arg4 -\n   * @param UserId arg5 -\n   * @return Xtruct - returns an Xtruct with string_thing = \"Hello2, byte_thing = arg0, i32_thing = arg1\n   *    and i64_thing = arg2\n   */\n  Xtruct testMulti(1: byte arg0, 2: i32 arg1, 3: i64 arg2, 4: map<i16, string> arg3, 5: Numberz arg4, 6: UserId arg5),\n\n  /**\n   * Print 'testException(%s)' with arg as '%s'\n   * @param string arg - a string indication what type of exception to throw\n   * if arg == \"Xception\" throw Xception with errorCode = 1001 and message = arg\n   * elsen if arg == \"TException\" throw TException\n   * else do not throw anything\n   */\n  void testException(1: string arg) throws(1: Xception err1),\n\n  /**\n   * Print 'testMultiException(%s, %s)' with arg0 as '%s' and arg1 as '%s'\n   * @param string arg - a string indication what type of exception to throw\n   * if arg0 == \"Xception\" throw Xception with errorCode = 1001 and message = \"This is an Xception\"\n   * elsen if arg0 == \"Xception2\" throw Xception2 with errorCode = 2002 and message = \"This is an Xception2\"\n   * else do not throw anything\n   * @return Xtruct - an Xtruct with string_thing = arg1\n   */\n  Xtruct testMultiException(1: string arg0, 2: string arg1) throws(1: Xception err1, 2: Xception2 err2)\n\n  /**\n   * Print 'testOneway(%d): Sleeping...' with secondsToSleep as '%d'\n   * sleep 'secondsToSleep'\n   * Print 'testOneway(%d): done sleeping!' with secondsToSleep as '%d'\n   * @param i32 secondsToSleep - the number of seconds to sleep\n   */\n  oneway void testOneway(1:i32 secondsToSleep)\n}\n\nservice SecondService\n{\n  void blahBlah()\n  /**\n   * Prints 'testString(\"%s\")' with thing as '%s'\n   * @param string thing - the string to print\n   * @return string - returns the string 'thing'\n   */\n  string       secondtestString(1: string thing),\n}\n\nstruct VersioningTestV1 {\n       1: optional i32 begin_in_both,\n       3: optional string old_string,\n       12: optional i32 end_in_both\n}\n\nstruct VersioningTestV2 {\n       1: optional i32 begin_in_both,\n\n       2: optional i32 newint,\n       3: optional byte newbyte,\n       4: optional i16 newshort,\n       5: optional i64 newlong,\n       6: optional double newdouble\n       7: optional Bonk newstruct,\n       8: optional list<i32> newlist,\n       9: optional set<i32> newset,\n       10: optional map<i32, i32> newmap,\n       11: optional string newstring,\n       12: optional i32 end_in_both\n}\n\nstruct ListTypeVersioningV1 {\n       1: optional list<i32> myints;\n       2: optional string hello;\n}\n\nstruct ListTypeVersioningV2 {\n       1: optional list<string> strings;\n       2: optional string hello;\n}\n\nstruct GuessProtocolStruct {\n  7: optional map<string,string> map_field,\n}\n\nstruct LargeDeltas {\n  1: optional Bools b1,\n  10: optional Bools b10,\n  100: optional Bools b100,\n  500: optional bool check_true,\n  1000: optional Bools b1000,\n  1500: optional bool check_false,\n  2000: optional VersioningTestV2 vertwo2000,\n  2500: optional set<string> a_set2500,\n  3000: optional VersioningTestV2 vertwo3000,\n  4000: optional list<i32> big_numbers\n}\n\nstruct NestedListsI32x2 {\n  1: optional list<list<i32>> integerlist\n}\nstruct NestedListsI32x3 {\n  1: optional list<list<list<i32>>> integerlist\n}\nstruct NestedMixedx2 {\n  1: optional list<set<i32>> int_set_list\n  2: optional map<i32,set<string>> map_int_strset\n  3: optional list<map<i32,set<string>>> map_int_strset_list\n}\nstruct ListBonks {\n  1: optional list<Bonk> bonk\n}\nstruct NestedListsBonk {\n  1: optional list<list<list<Bonk>>> bonk\n}\n\nstruct BoolTest {\n  1: optional bool b = true;\n  2: optional string s = \"true\";\n}\n\nstruct StructA {\n  1: required string s;\n}\n\nstruct StructB {\n  1: optional StructA aa;\n  2: required StructA ab;\n}\n"

// SecondService_BlahBlah_Args represents the arguments for the SecondService.blahBlah function.
//
// The arguments for blahBlah are sent and received over the wire as this struct.
type SecondService_BlahBlah_Args struct {
}

// ToWire translates a SecondService_BlahBlah_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *SecondService_BlahBlah_Args) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SecondService_BlahBlah_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SecondService_BlahBlah_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v SecondService_BlahBlah_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *SecondService_BlahBlah_Args) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a SecondService_BlahBlah_Args
// struct.
func (v *SecondService_BlahBlah_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("SecondService_BlahBlah_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SecondService_BlahBlah_Args match the
// provided SecondService_BlahBlah_Args.
//
// This function performs a deep comparison.
func (v *SecondService_BlahBlah_Args) Equals(rhs *SecondService_BlahBlah_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SecondService_BlahBlah_Args.
func (v *SecondService_BlahBlah_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "blahBlah" for this struct.
func (v *SecondService_BlahBlah_Args) MethodName() string {
	return "blahBlah"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *SecondService_BlahBlah_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// SecondService_BlahBlah_Helper provides functions that aid in handling the
// parameters and return values of the SecondService.blahBlah
// function.
var SecondService_BlahBlah_Helper = struct {
	// Args accepts the parameters of blahBlah in-order and returns
	// the arguments struct for the function.
	Args func() *SecondService_BlahBlah_Args

	// IsException returns true if the given error can be thrown
	// by blahBlah.
	//
	// An error can be thrown by blahBlah only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for blahBlah
	// given the error returned by it. The provided error may
	// be nil if blahBlah did not fail.
	//
	// This allows mapping errors returned by blahBlah into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// blahBlah
	//
	//   err := blahBlah(args)
	//   result, err := SecondService_BlahBlah_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from blahBlah: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*SecondService_BlahBlah_Result, error)

	// UnwrapResponse takes the result struct for blahBlah
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if blahBlah threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := SecondService_BlahBlah_Helper.UnwrapResponse(result)
	UnwrapResponse func(*SecondService_BlahBlah_Result) error
}{}

func init() {
	SecondService_BlahBlah_Helper.Args = func() *SecondService_BlahBlah_Args {
		return &SecondService_BlahBlah_Args{}
	}

	SecondService_BlahBlah_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	SecondService_BlahBlah_Helper.WrapResponse = func(err error) (*SecondService_BlahBlah_Result, error) {
		if err == nil {
			return &SecondService_BlahBlah_Result{}, nil
		}

		return nil, err
	}
	SecondService_BlahBlah_Helper.UnwrapResponse = func(result *SecondService_BlahBlah_Result) (err error) {
		return
	}

}

// SecondService_BlahBlah_Result represents the result of a SecondService.blahBlah function call.
//
// The result of a blahBlah execution is sent and received over the wire as this struct.
type SecondService_BlahBlah_Result struct {
}

// ToWire translates a SecondService_BlahBlah_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *SecondService_BlahBlah_Result) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SecondService_BlahBlah_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SecondService_BlahBlah_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v SecondService_BlahBlah_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *SecondService_BlahBlah_Result) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a SecondService_BlahBlah_Result
// struct.
func (v *SecondService_BlahBlah_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("SecondService_BlahBlah_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SecondService_BlahBlah_Result match the
// provided SecondService_BlahBlah_Result.
//
// This function performs a deep comparison.
func (v *SecondService_BlahBlah_Result) Equals(rhs *SecondService_BlahBlah_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SecondService_BlahBlah_Result.
func (v *SecondService_BlahBlah_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "blahBlah" for this struct.
func (v *SecondService_BlahBlah_Result) MethodName() string {
	return "blahBlah"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *SecondService_BlahBlah_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// SecondService_SecondtestString_Args represents the arguments for the SecondService.secondtestString function.
//
// The arguments for secondtestString are sent and received over the wire as this struct.
type SecondService_SecondtestString_Args struct {
	Thing *string `json:"thing,omitempty"`
}

// ToWire translates a SecondService_SecondtestString_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *SecondService_SecondtestString_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueString(*(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SecondService_SecondtestString_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SecondService_SecondtestString_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v SecondService_SecondtestString_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *SecondService_SecondtestString_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a SecondService_SecondtestString_Args
// struct.
func (v *SecondService_SecondtestString_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", *(v.Thing))
		i++
	}

	return fmt.Sprintf("SecondService_SecondtestString_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SecondService_SecondtestString_Args match the
// provided SecondService_SecondtestString_Args.
//
// This function performs a deep comparison.
func (v *SecondService_SecondtestString_Args) Equals(rhs *SecondService_SecondtestString_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Thing, rhs.Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SecondService_SecondtestString_Args.
func (v *SecondService_SecondtestString_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		enc.AddString("thing", *v.Thing)
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *SecondService_SecondtestString_Args) GetThing() (o string) {
	if v != nil && v.Thing != nil {
		return *v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *SecondService_SecondtestString_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "secondtestString" for this struct.
func (v *SecondService_SecondtestString_Args) MethodName() string {
	return "secondtestString"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *SecondService_SecondtestString_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// SecondService_SecondtestString_Helper provides functions that aid in handling the
// parameters and return values of the SecondService.secondtestString
// function.
var SecondService_SecondtestString_Helper = struct {
	// Args accepts the parameters of secondtestString in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *string,
	) *SecondService_SecondtestString_Args

	// IsException returns true if the given error can be thrown
	// by secondtestString.
	//
	// An error can be thrown by secondtestString only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for secondtestString
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// secondtestString into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by secondtestString
	//
	//   value, err := secondtestString(args)
	//   result, err := SecondService_SecondtestString_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from secondtestString: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(string, error) (*SecondService_SecondtestString_Result, error)

	// UnwrapResponse takes the result struct for secondtestString
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if secondtestString threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := SecondService_SecondtestString_Helper.UnwrapResponse(result)
	UnwrapResponse func(*SecondService_SecondtestString_Result) (string, error)
}{}

func init() {
	SecondService_SecondtestString_Helper.Args = func(
		thing *string,
	) *SecondService_SecondtestString_Args {
		return &SecondService_SecondtestString_Args{
			Thing: thing,
		}
	}

	SecondService_SecondtestString_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	SecondService_SecondtestString_Helper.WrapResponse = func(success string, err error) (*SecondService_SecondtestString_Result, error) {
		if err == nil {
			return &SecondService_SecondtestString_Result{Success: &success}, nil
		}

		return nil, err
	}
	SecondService_SecondtestString_Helper.UnwrapResponse = func(result *SecondService_SecondtestString_Result) (success string, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// SecondService_SecondtestString_Result represents the result of a SecondService.secondtestString function call.
//
// The result of a secondtestString execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type SecondService_SecondtestString_Result struct {
	// Value returned by secondtestString after a successful execution.
	Success *string `json:"success,omitempty"`
}

// ToWire translates a SecondService_SecondtestString_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *SecondService_SecondtestString_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueString(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("SecondService_SecondtestString_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a SecondService_SecondtestString_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a SecondService_SecondtestString_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v SecondService_SecondtestString_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *SecondService_SecondtestString_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("SecondService_SecondtestString_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a SecondService_SecondtestString_Result
// struct.
func (v *SecondService_SecondtestString_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("SecondService_SecondtestString_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this SecondService_SecondtestString_Result match the
// provided SecondService_SecondtestString_Result.
//
// This function performs a deep comparison.
func (v *SecondService_SecondtestString_Result) Equals(rhs *SecondService_SecondtestString_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of SecondService_SecondtestString_Result.
func (v *SecondService_SecondtestString_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *SecondService_SecondtestString_Result) GetSuccess() (o string) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *SecondService_SecondtestString_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "secondtestString" for this struct.
func (v *SecondService_SecondtestString_Result) MethodName() string {
	return "secondtestString"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *SecondService_SecondtestString_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestBinary_Args represents the arguments for the ThriftTest.testBinary function.
//
// The arguments for testBinary are sent and received over the wire as this struct.
type ThriftTest_TestBinary_Args struct {
	Thing []byte `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestBinary_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestBinary_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueBinary(v.Thing), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestBinary_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestBinary_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestBinary_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestBinary_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				v.Thing, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestBinary_Args
// struct.
func (v *ThriftTest_TestBinary_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", v.Thing)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestBinary_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestBinary_Args match the
// provided ThriftTest_TestBinary_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestBinary_Args) Equals(rhs *ThriftTest_TestBinary_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Thing == nil && rhs.Thing == nil) || (v.Thing != nil && rhs.Thing != nil && bytes.Equal(v.Thing, rhs.Thing))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestBinary_Args.
func (v *ThriftTest_TestBinary_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		enc.AddString("thing", base64.StdEncoding.EncodeToString(v.Thing))
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestBinary_Args) GetThing() (o []byte) {
	if v != nil && v.Thing != nil {
		return v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestBinary_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testBinary" for this struct.
func (v *ThriftTest_TestBinary_Args) MethodName() string {
	return "testBinary"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestBinary_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestBinary_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testBinary
// function.
var ThriftTest_TestBinary_Helper = struct {
	// Args accepts the parameters of testBinary in-order and returns
	// the arguments struct for the function.
	Args func(
		thing []byte,
	) *ThriftTest_TestBinary_Args

	// IsException returns true if the given error can be thrown
	// by testBinary.
	//
	// An error can be thrown by testBinary only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testBinary
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testBinary into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testBinary
	//
	//   value, err := testBinary(args)
	//   result, err := ThriftTest_TestBinary_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testBinary: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func([]byte, error) (*ThriftTest_TestBinary_Result, error)

	// UnwrapResponse takes the result struct for testBinary
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testBinary threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestBinary_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestBinary_Result) ([]byte, error)
}{}

func init() {
	ThriftTest_TestBinary_Helper.Args = func(
		thing []byte,
	) *ThriftTest_TestBinary_Args {
		return &ThriftTest_TestBinary_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestBinary_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestBinary_Helper.WrapResponse = func(success []byte, err error) (*ThriftTest_TestBinary_Result, error) {
		if err == nil {
			return &ThriftTest_TestBinary_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestBinary_Helper.UnwrapResponse = func(result *ThriftTest_TestBinary_Result) (success []byte, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestBinary_Result represents the result of a ThriftTest.testBinary function call.
//
// The result of a testBinary execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestBinary_Result struct {
	// Value returned by testBinary after a successful execution.
	Success []byte `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestBinary_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestBinary_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueBinary(v.Success), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestBinary_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestBinary_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestBinary_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestBinary_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestBinary_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				v.Success, err = field.Value.GetBinary(), error(nil)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestBinary_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestBinary_Result
// struct.
func (v *ThriftTest_TestBinary_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestBinary_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestBinary_Result match the
// provided ThriftTest_TestBinary_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestBinary_Result) Equals(rhs *ThriftTest_TestBinary_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && bytes.Equal(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestBinary_Result.
func (v *ThriftTest_TestBinary_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", base64.StdEncoding.EncodeToString(v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestBinary_Result) GetSuccess() (o []byte) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestBinary_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testBinary" for this struct.
func (v *ThriftTest_TestBinary_Result) MethodName() string {
	return "testBinary"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestBinary_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestByte_Args represents the arguments for the ThriftTest.testByte function.
//
// The arguments for testByte are sent and received over the wire as this struct.
type ThriftTest_TestByte_Args struct {
	Thing *int8 `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestByte_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestByte_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueI8(*(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestByte_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestByte_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestByte_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestByte_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestByte_Args
// struct.
func (v *ThriftTest_TestByte_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", *(v.Thing))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestByte_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestByte_Args match the
// provided ThriftTest_TestByte_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestByte_Args) Equals(rhs *ThriftTest_TestByte_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Byte_EqualsPtr(v.Thing, rhs.Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestByte_Args.
func (v *ThriftTest_TestByte_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		enc.AddInt8("thing", *v.Thing)
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestByte_Args) GetThing() (o int8) {
	if v != nil && v.Thing != nil {
		return *v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestByte_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testByte" for this struct.
func (v *ThriftTest_TestByte_Args) MethodName() string {
	return "testByte"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestByte_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestByte_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testByte
// function.
var ThriftTest_TestByte_Helper = struct {
	// Args accepts the parameters of testByte in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *int8,
	) *ThriftTest_TestByte_Args

	// IsException returns true if the given error can be thrown
	// by testByte.
	//
	// An error can be thrown by testByte only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testByte
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testByte into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testByte
	//
	//   value, err := testByte(args)
	//   result, err := ThriftTest_TestByte_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testByte: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(int8, error) (*ThriftTest_TestByte_Result, error)

	// UnwrapResponse takes the result struct for testByte
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testByte threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestByte_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestByte_Result) (int8, error)
}{}

func init() {
	ThriftTest_TestByte_Helper.Args = func(
		thing *int8,
	) *ThriftTest_TestByte_Args {
		return &ThriftTest_TestByte_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestByte_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestByte_Helper.WrapResponse = func(success int8, err error) (*ThriftTest_TestByte_Result, error) {
		if err == nil {
			return &ThriftTest_TestByte_Result{Success: &success}, nil
		}

		return nil, err
	}
	ThriftTest_TestByte_Helper.UnwrapResponse = func(result *ThriftTest_TestByte_Result) (success int8, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestByte_Result represents the result of a ThriftTest.testByte function call.
//
// The result of a testByte execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestByte_Result struct {
	// Value returned by testByte after a successful execution.
	Success *int8 `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestByte_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestByte_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueI8(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestByte_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestByte_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestByte_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestByte_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestByte_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestByte_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestByte_Result
// struct.
func (v *ThriftTest_TestByte_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestByte_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestByte_Result match the
// provided ThriftTest_TestByte_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestByte_Result) Equals(rhs *ThriftTest_TestByte_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Byte_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestByte_Result.
func (v *ThriftTest_TestByte_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddInt8("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestByte_Result) GetSuccess() (o int8) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestByte_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testByte" for this struct.
func (v *ThriftTest_TestByte_Result) MethodName() string {
	return "testByte"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestByte_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestDouble_Args represents the arguments for the ThriftTest.testDouble function.
//
// The arguments for testDouble are sent and received over the wire as this struct.
type ThriftTest_TestDouble_Args struct {
	Thing *float64 `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestDouble_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestDouble_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueDouble(*(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestDouble_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestDouble_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestDouble_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestDouble_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestDouble_Args
// struct.
func (v *ThriftTest_TestDouble_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", *(v.Thing))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestDouble_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestDouble_Args match the
// provided ThriftTest_TestDouble_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestDouble_Args) Equals(rhs *ThriftTest_TestDouble_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Double_EqualsPtr(v.Thing, rhs.Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestDouble_Args.
func (v *ThriftTest_TestDouble_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		enc.AddFloat64("thing", *v.Thing)
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestDouble_Args) GetThing() (o float64) {
	if v != nil && v.Thing != nil {
		return *v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestDouble_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testDouble" for this struct.
func (v *ThriftTest_TestDouble_Args) MethodName() string {
	return "testDouble"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestDouble_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestDouble_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testDouble
// function.
var ThriftTest_TestDouble_Helper = struct {
	// Args accepts the parameters of testDouble in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *float64,
	) *ThriftTest_TestDouble_Args

	// IsException returns true if the given error can be thrown
	// by testDouble.
	//
	// An error can be thrown by testDouble only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testDouble
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testDouble into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testDouble
	//
	//   value, err := testDouble(args)
	//   result, err := ThriftTest_TestDouble_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testDouble: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(float64, error) (*ThriftTest_TestDouble_Result, error)

	// UnwrapResponse takes the result struct for testDouble
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testDouble threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestDouble_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestDouble_Result) (float64, error)
}{}

func init() {
	ThriftTest_TestDouble_Helper.Args = func(
		thing *float64,
	) *ThriftTest_TestDouble_Args {
		return &ThriftTest_TestDouble_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestDouble_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestDouble_Helper.WrapResponse = func(success float64, err error) (*ThriftTest_TestDouble_Result, error) {
		if err == nil {
			return &ThriftTest_TestDouble_Result{Success: &success}, nil
		}

		return nil, err
	}
	ThriftTest_TestDouble_Helper.UnwrapResponse = func(result *ThriftTest_TestDouble_Result) (success float64, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestDouble_Result represents the result of a ThriftTest.testDouble function call.
//
// The result of a testDouble execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestDouble_Result struct {
	// Value returned by testDouble after a successful execution.
	Success *float64 `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestDouble_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestDouble_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueDouble(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestDouble_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestDouble_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestDouble_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestDouble_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestDouble_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TDouble {
				var x float64
				x, err = field.Value.GetDouble(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestDouble_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestDouble_Result
// struct.
func (v *ThriftTest_TestDouble_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestDouble_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestDouble_Result match the
// provided ThriftTest_TestDouble_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestDouble_Result) Equals(rhs *ThriftTest_TestDouble_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Double_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestDouble_Result.
func (v *ThriftTest_TestDouble_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddFloat64("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestDouble_Result) GetSuccess() (o float64) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestDouble_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testDouble" for this struct.
func (v *ThriftTest_TestDouble_Result) MethodName() string {
	return "testDouble"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestDouble_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestEnum_Args represents the arguments for the ThriftTest.testEnum function.
//
// The arguments for testEnum are sent and received over the wire as this struct.
type ThriftTest_TestEnum_Args struct {
	Thing *Numberz `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestEnum_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestEnum_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = v.Thing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestEnum_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestEnum_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestEnum_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestEnum_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x Numberz
				x, err = _Numberz_Read(field.Value)
				v.Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestEnum_Args
// struct.
func (v *ThriftTest_TestEnum_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", *(v.Thing))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestEnum_Args{%v}", strings.Join(fields[:i], ", "))
}

func _Numberz_EqualsPtr(lhs, rhs *Numberz) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return x.Equals(y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this ThriftTest_TestEnum_Args match the
// provided ThriftTest_TestEnum_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestEnum_Args) Equals(rhs *ThriftTest_TestEnum_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Numberz_EqualsPtr(v.Thing, rhs.Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestEnum_Args.
func (v *ThriftTest_TestEnum_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		err = multierr.Append(err, enc.AddObject("thing", *v.Thing))
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestEnum_Args) GetThing() (o Numberz) {
	if v != nil && v.Thing != nil {
		return *v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestEnum_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testEnum" for this struct.
func (v *ThriftTest_TestEnum_Args) MethodName() string {
	return "testEnum"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestEnum_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestEnum_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testEnum
// function.
var ThriftTest_TestEnum_Helper = struct {
	// Args accepts the parameters of testEnum in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *Numberz,
	) *ThriftTest_TestEnum_Args

	// IsException returns true if the given error can be thrown
	// by testEnum.
	//
	// An error can be thrown by testEnum only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testEnum
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testEnum into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testEnum
	//
	//   value, err := testEnum(args)
	//   result, err := ThriftTest_TestEnum_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testEnum: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(Numberz, error) (*ThriftTest_TestEnum_Result, error)

	// UnwrapResponse takes the result struct for testEnum
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testEnum threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestEnum_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestEnum_Result) (Numberz, error)
}{}

func init() {
	ThriftTest_TestEnum_Helper.Args = func(
		thing *Numberz,
	) *ThriftTest_TestEnum_Args {
		return &ThriftTest_TestEnum_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestEnum_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestEnum_Helper.WrapResponse = func(success Numberz, err error) (*ThriftTest_TestEnum_Result, error) {
		if err == nil {
			return &ThriftTest_TestEnum_Result{Success: &success}, nil
		}

		return nil, err
	}
	ThriftTest_TestEnum_Helper.UnwrapResponse = func(result *ThriftTest_TestEnum_Result) (success Numberz, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestEnum_Result represents the result of a ThriftTest.testEnum function call.
//
// The result of a testEnum execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestEnum_Result struct {
	// Value returned by testEnum after a successful execution.
	Success *Numberz `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestEnum_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestEnum_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestEnum_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestEnum_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestEnum_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestEnum_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestEnum_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI32 {
				var x Numberz
				x, err = _Numberz_Read(field.Value)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestEnum_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestEnum_Result
// struct.
func (v *ThriftTest_TestEnum_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestEnum_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestEnum_Result match the
// provided ThriftTest_TestEnum_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestEnum_Result) Equals(rhs *ThriftTest_TestEnum_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Numberz_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestEnum_Result.
func (v *ThriftTest_TestEnum_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", *v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestEnum_Result) GetSuccess() (o Numberz) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestEnum_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testEnum" for this struct.
func (v *ThriftTest_TestEnum_Result) MethodName() string {
	return "testEnum"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestEnum_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestException_Args represents the arguments for the ThriftTest.testException function.
//
// The arguments for testException are sent and received over the wire as this struct.
type ThriftTest_TestException_Args struct {
	Arg *string `json:"arg,omitempty"`
}

// ToWire translates a ThriftTest_TestException_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestException_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg != nil {
		w, err = wire.NewValueString(*(v.Arg)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestException_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestException_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestException_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestException_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Arg = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestException_Args
// struct.
func (v *ThriftTest_TestException_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Arg != nil {
		fields[i] = fmt.Sprintf("Arg: %v", *(v.Arg))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestException_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestException_Args match the
// provided ThriftTest_TestException_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestException_Args) Equals(rhs *ThriftTest_TestException_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Arg, rhs.Arg) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestException_Args.
func (v *ThriftTest_TestException_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Arg != nil {
		enc.AddString("arg", *v.Arg)
	}
	return err
}

// GetArg returns the value of Arg if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestException_Args) GetArg() (o string) {
	if v != nil && v.Arg != nil {
		return *v.Arg
	}

	return
}

// IsSetArg returns true if Arg is not nil.
func (v *ThriftTest_TestException_Args) IsSetArg() bool {
	return v != nil && v.Arg != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testException" for this struct.
func (v *ThriftTest_TestException_Args) MethodName() string {
	return "testException"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestException_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestException_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testException
// function.
var ThriftTest_TestException_Helper = struct {
	// Args accepts the parameters of testException in-order and returns
	// the arguments struct for the function.
	Args func(
		arg *string,
	) *ThriftTest_TestException_Args

	// IsException returns true if the given error can be thrown
	// by testException.
	//
	// An error can be thrown by testException only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testException
	// given the error returned by it. The provided error may
	// be nil if testException did not fail.
	//
	// This allows mapping errors returned by testException into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// testException
	//
	//   err := testException(args)
	//   result, err := ThriftTest_TestException_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testException: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*ThriftTest_TestException_Result, error)

	// UnwrapResponse takes the result struct for testException
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if testException threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := ThriftTest_TestException_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestException_Result) error
}{}

func init() {
	ThriftTest_TestException_Helper.Args = func(
		arg *string,
	) *ThriftTest_TestException_Args {
		return &ThriftTest_TestException_Args{
			Arg: arg,
		}
	}

	ThriftTest_TestException_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *Xception:
			return true
		default:
			return false
		}
	}

	ThriftTest_TestException_Helper.WrapResponse = func(err error) (*ThriftTest_TestException_Result, error) {
		if err == nil {
			return &ThriftTest_TestException_Result{}, nil
		}

		switch e := err.(type) {
		case *Xception:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for ThriftTest_TestException_Result.Err1")
			}
			return &ThriftTest_TestException_Result{Err1: e}, nil
		}

		return nil, err
	}
	ThriftTest_TestException_Helper.UnwrapResponse = func(result *ThriftTest_TestException_Result) (err error) {
		if result.Err1 != nil {
			err = result.Err1
			return
		}
		return
	}

}

// ThriftTest_TestException_Result represents the result of a ThriftTest.testException function call.
//
// The result of a testException execution is sent and received over the wire as this struct.
type ThriftTest_TestException_Result struct {
	Err1 *Xception `json:"err1,omitempty"`
}

// ToWire translates a ThriftTest_TestException_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestException_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Err1 != nil {
		w, err = v.Err1.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	if i > 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestException_Result should have at most one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Xception_Read(w wire.Value) (*Xception, error) {
	var v Xception
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a ThriftTest_TestException_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestException_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestException_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestException_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Err1, err = _Xception_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Err1 != nil {
		count++
	}
	if count > 1 {
		return fmt.Errorf("ThriftTest_TestException_Result should have at most one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestException_Result
// struct.
func (v *ThriftTest_TestException_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Err1 != nil {
		fields[i] = fmt.Sprintf("Err1: %v", v.Err1)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestException_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestException_Result match the
// provided ThriftTest_TestException_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestException_Result) Equals(rhs *ThriftTest_TestException_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Err1 == nil && rhs.Err1 == nil) || (v.Err1 != nil && rhs.Err1 != nil && v.Err1.Equals(rhs.Err1))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestException_Result.
func (v *ThriftTest_TestException_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Err1 != nil {
		err = multierr.Append(err, enc.AddObject("err1", v.Err1))
	}
	return err
}

// GetErr1 returns the value of Err1 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestException_Result) GetErr1() (o *Xception) {
	if v != nil && v.Err1 != nil {
		return v.Err1
	}

	return
}

// IsSetErr1 returns true if Err1 is not nil.
func (v *ThriftTest_TestException_Result) IsSetErr1() bool {
	return v != nil && v.Err1 != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testException" for this struct.
func (v *ThriftTest_TestException_Result) MethodName() string {
	return "testException"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestException_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestI32_Args represents the arguments for the ThriftTest.testI32 function.
//
// The arguments for testI32 are sent and received over the wire as this struct.
type ThriftTest_TestI32_Args struct {
	Thing *int32 `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestI32_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestI32_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueI32(*(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestI32_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestI32_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestI32_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestI32_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestI32_Args
// struct.
func (v *ThriftTest_TestI32_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", *(v.Thing))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestI32_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestI32_Args match the
// provided ThriftTest_TestI32_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestI32_Args) Equals(rhs *ThriftTest_TestI32_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Thing, rhs.Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestI32_Args.
func (v *ThriftTest_TestI32_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		enc.AddInt32("thing", *v.Thing)
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestI32_Args) GetThing() (o int32) {
	if v != nil && v.Thing != nil {
		return *v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestI32_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testI32" for this struct.
func (v *ThriftTest_TestI32_Args) MethodName() string {
	return "testI32"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestI32_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestI32_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testI32
// function.
var ThriftTest_TestI32_Helper = struct {
	// Args accepts the parameters of testI32 in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *int32,
	) *ThriftTest_TestI32_Args

	// IsException returns true if the given error can be thrown
	// by testI32.
	//
	// An error can be thrown by testI32 only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testI32
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testI32 into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testI32
	//
	//   value, err := testI32(args)
	//   result, err := ThriftTest_TestI32_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testI32: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(int32, error) (*ThriftTest_TestI32_Result, error)

	// UnwrapResponse takes the result struct for testI32
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testI32 threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestI32_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestI32_Result) (int32, error)
}{}

func init() {
	ThriftTest_TestI32_Helper.Args = func(
		thing *int32,
	) *ThriftTest_TestI32_Args {
		return &ThriftTest_TestI32_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestI32_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestI32_Helper.WrapResponse = func(success int32, err error) (*ThriftTest_TestI32_Result, error) {
		if err == nil {
			return &ThriftTest_TestI32_Result{Success: &success}, nil
		}

		return nil, err
	}
	ThriftTest_TestI32_Helper.UnwrapResponse = func(result *ThriftTest_TestI32_Result) (success int32, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestI32_Result represents the result of a ThriftTest.testI32 function call.
//
// The result of a testI32 execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestI32_Result struct {
	// Value returned by testI32 after a successful execution.
	Success *int32 `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestI32_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestI32_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueI32(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestI32_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestI32_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestI32_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestI32_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestI32_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestI32_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestI32_Result
// struct.
func (v *ThriftTest_TestI32_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestI32_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestI32_Result match the
// provided ThriftTest_TestI32_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestI32_Result) Equals(rhs *ThriftTest_TestI32_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestI32_Result.
func (v *ThriftTest_TestI32_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddInt32("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestI32_Result) GetSuccess() (o int32) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestI32_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testI32" for this struct.
func (v *ThriftTest_TestI32_Result) MethodName() string {
	return "testI32"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestI32_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestI64_Args represents the arguments for the ThriftTest.testI64 function.
//
// The arguments for testI64 are sent and received over the wire as this struct.
type ThriftTest_TestI64_Args struct {
	Thing *int64 `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestI64_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestI64_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueI64(*(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestI64_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestI64_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestI64_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestI64_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestI64_Args
// struct.
func (v *ThriftTest_TestI64_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", *(v.Thing))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestI64_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestI64_Args match the
// provided ThriftTest_TestI64_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestI64_Args) Equals(rhs *ThriftTest_TestI64_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Thing, rhs.Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestI64_Args.
func (v *ThriftTest_TestI64_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		enc.AddInt64("thing", *v.Thing)
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestI64_Args) GetThing() (o int64) {
	if v != nil && v.Thing != nil {
		return *v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestI64_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testI64" for this struct.
func (v *ThriftTest_TestI64_Args) MethodName() string {
	return "testI64"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestI64_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestI64_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testI64
// function.
var ThriftTest_TestI64_Helper = struct {
	// Args accepts the parameters of testI64 in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *int64,
	) *ThriftTest_TestI64_Args

	// IsException returns true if the given error can be thrown
	// by testI64.
	//
	// An error can be thrown by testI64 only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testI64
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testI64 into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testI64
	//
	//   value, err := testI64(args)
	//   result, err := ThriftTest_TestI64_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testI64: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(int64, error) (*ThriftTest_TestI64_Result, error)

	// UnwrapResponse takes the result struct for testI64
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testI64 threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestI64_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestI64_Result) (int64, error)
}{}

func init() {
	ThriftTest_TestI64_Helper.Args = func(
		thing *int64,
	) *ThriftTest_TestI64_Args {
		return &ThriftTest_TestI64_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestI64_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestI64_Helper.WrapResponse = func(success int64, err error) (*ThriftTest_TestI64_Result, error) {
		if err == nil {
			return &ThriftTest_TestI64_Result{Success: &success}, nil
		}

		return nil, err
	}
	ThriftTest_TestI64_Helper.UnwrapResponse = func(result *ThriftTest_TestI64_Result) (success int64, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestI64_Result represents the result of a ThriftTest.testI64 function call.
//
// The result of a testI64 execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestI64_Result struct {
	// Value returned by testI64 after a successful execution.
	Success *int64 `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestI64_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestI64_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueI64(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestI64_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestI64_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestI64_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestI64_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestI64_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestI64_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestI64_Result
// struct.
func (v *ThriftTest_TestI64_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestI64_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestI64_Result match the
// provided ThriftTest_TestI64_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestI64_Result) Equals(rhs *ThriftTest_TestI64_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I64_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestI64_Result.
func (v *ThriftTest_TestI64_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddInt64("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestI64_Result) GetSuccess() (o int64) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestI64_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testI64" for this struct.
func (v *ThriftTest_TestI64_Result) MethodName() string {
	return "testI64"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestI64_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestInsanity_Args represents the arguments for the ThriftTest.testInsanity function.
//
// The arguments for testInsanity are sent and received over the wire as this struct.
type ThriftTest_TestInsanity_Args struct {
	Argument *Insanity `json:"argument,omitempty"`
}

// ToWire translates a ThriftTest_TestInsanity_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestInsanity_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Argument != nil {
		w, err = v.Argument.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestInsanity_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestInsanity_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestInsanity_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestInsanity_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Argument, err = _Insanity_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestInsanity_Args
// struct.
func (v *ThriftTest_TestInsanity_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Argument != nil {
		fields[i] = fmt.Sprintf("Argument: %v", v.Argument)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestInsanity_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestInsanity_Args match the
// provided ThriftTest_TestInsanity_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestInsanity_Args) Equals(rhs *ThriftTest_TestInsanity_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Argument == nil && rhs.Argument == nil) || (v.Argument != nil && rhs.Argument != nil && v.Argument.Equals(rhs.Argument))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestInsanity_Args.
func (v *ThriftTest_TestInsanity_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Argument != nil {
		err = multierr.Append(err, enc.AddObject("argument", v.Argument))
	}
	return err
}

// GetArgument returns the value of Argument if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestInsanity_Args) GetArgument() (o *Insanity) {
	if v != nil && v.Argument != nil {
		return v.Argument
	}

	return
}

// IsSetArgument returns true if Argument is not nil.
func (v *ThriftTest_TestInsanity_Args) IsSetArgument() bool {
	return v != nil && v.Argument != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testInsanity" for this struct.
func (v *ThriftTest_TestInsanity_Args) MethodName() string {
	return "testInsanity"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestInsanity_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestInsanity_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testInsanity
// function.
var ThriftTest_TestInsanity_Helper = struct {
	// Args accepts the parameters of testInsanity in-order and returns
	// the arguments struct for the function.
	Args func(
		argument *Insanity,
	) *ThriftTest_TestInsanity_Args

	// IsException returns true if the given error can be thrown
	// by testInsanity.
	//
	// An error can be thrown by testInsanity only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testInsanity
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testInsanity into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testInsanity
	//
	//   value, err := testInsanity(args)
	//   result, err := ThriftTest_TestInsanity_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testInsanity: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(map[UserId]map[Numberz]*Insanity, error) (*ThriftTest_TestInsanity_Result, error)

	// UnwrapResponse takes the result struct for testInsanity
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testInsanity threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestInsanity_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestInsanity_Result) (map[UserId]map[Numberz]*Insanity, error)
}{}

func init() {
	ThriftTest_TestInsanity_Helper.Args = func(
		argument *Insanity,
	) *ThriftTest_TestInsanity_Args {
		return &ThriftTest_TestInsanity_Args{
			Argument: argument,
		}
	}

	ThriftTest_TestInsanity_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestInsanity_Helper.WrapResponse = func(success map[UserId]map[Numberz]*Insanity, err error) (*ThriftTest_TestInsanity_Result, error) {
		if err == nil {
			return &ThriftTest_TestInsanity_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestInsanity_Helper.UnwrapResponse = func(result *ThriftTest_TestInsanity_Result) (success map[UserId]map[Numberz]*Insanity, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestInsanity_Result represents the result of a ThriftTest.testInsanity function call.
//
// The result of a testInsanity execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestInsanity_Result struct {
	// Value returned by testInsanity after a successful execution.
	Success map[UserId]map[Numberz]*Insanity `json:"success,omitempty"`
}

type _Map_Numberz_Insanity_MapItemList map[Numberz]*Insanity

func (m _Map_Numberz_Insanity_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := v.ToWire()
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_Numberz_Insanity_MapItemList) Size() int {
	return len(m)
}

func (_Map_Numberz_Insanity_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_Numberz_Insanity_MapItemList) ValueType() wire.Type {
	return wire.TStruct
}

func (_Map_Numberz_Insanity_MapItemList) Close() {}

type _Map_UserId_Map_Numberz_Insanity_MapItemList map[UserId]map[Numberz]*Insanity

func (m _Map_UserId_Map_Numberz_Insanity_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := k.ToWire()
		if err != nil {
			return err
		}

		vw, err := wire.NewValueMap(_Map_Numberz_Insanity_MapItemList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_UserId_Map_Numberz_Insanity_MapItemList) Size() int {
	return len(m)
}

func (_Map_UserId_Map_Numberz_Insanity_MapItemList) KeyType() wire.Type {
	return wire.TI64
}

func (_Map_UserId_Map_Numberz_Insanity_MapItemList) ValueType() wire.Type {
	return wire.TMap
}

func (_Map_UserId_Map_Numberz_Insanity_MapItemList) Close() {}

// ToWire translates a ThriftTest_TestInsanity_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestInsanity_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueMap(_Map_UserId_Map_Numberz_Insanity_MapItemList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestInsanity_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_Numberz_Insanity_Read(m wire.MapItemList) (map[Numberz]*Insanity, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TStruct {
		return nil, nil
	}

	o := make(map[Numberz]*Insanity, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _Numberz_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _Insanity_Read(x.Value)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

func _Map_UserId_Map_Numberz_Insanity_Read(m wire.MapItemList) (map[UserId]map[Numberz]*Insanity, error) {
	if m.KeyType() != wire.TI64 {
		return nil, nil
	}

	if m.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make(map[UserId]map[Numberz]*Insanity, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := _UserId_Read(x.Key)
		if err != nil {
			return err
		}

		v, err := _Map_Numberz_Insanity_Read(x.Value.GetMap())
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a ThriftTest_TestInsanity_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestInsanity_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestInsanity_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestInsanity_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TMap {
				v.Success, err = _Map_UserId_Map_Numberz_Insanity_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestInsanity_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestInsanity_Result
// struct.
func (v *ThriftTest_TestInsanity_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestInsanity_Result{%v}", strings.Join(fields[:i], ", "))
}

func _Map_Numberz_Insanity_Equals(lhs, rhs map[Numberz]*Insanity) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !lv.Equals(rv) {
			return false
		}
	}
	return true
}

func _Map_UserId_Map_Numberz_Insanity_Equals(lhs, rhs map[UserId]map[Numberz]*Insanity) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !_Map_Numberz_Insanity_Equals(lv, rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this ThriftTest_TestInsanity_Result match the
// provided ThriftTest_TestInsanity_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestInsanity_Result) Equals(rhs *ThriftTest_TestInsanity_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Map_UserId_Map_Numberz_Insanity_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

type _Map_Numberz_Insanity_Item_Zapper struct {
	Key   Numberz
	Value *Insanity
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Numberz_Insanity_Item_Zapper.
func (v _Map_Numberz_Insanity_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	err = multierr.Append(err, enc.AddObject("key", v.Key))
	err = multierr.Append(err, enc.AddObject("value", v.Value))
	return err
}

type _Map_Numberz_Insanity_Zapper map[Numberz]*Insanity

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_Numberz_Insanity_Zapper.
func (m _Map_Numberz_Insanity_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_Numberz_Insanity_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

type _Map_UserId_Map_Numberz_Insanity_Item_Zapper struct {
	Key   UserId
	Value map[Numberz]*Insanity
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_UserId_Map_Numberz_Insanity_Item_Zapper.
func (v _Map_UserId_Map_Numberz_Insanity_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt64("key", (int64)(v.Key))
	err = multierr.Append(err, enc.AddArray("value", (_Map_Numberz_Insanity_Zapper)(v.Value)))
	return err
}

type _Map_UserId_Map_Numberz_Insanity_Zapper map[UserId]map[Numberz]*Insanity

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_UserId_Map_Numberz_Insanity_Zapper.
func (m _Map_UserId_Map_Numberz_Insanity_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_UserId_Map_Numberz_Insanity_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestInsanity_Result.
func (v *ThriftTest_TestInsanity_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_Map_UserId_Map_Numberz_Insanity_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestInsanity_Result) GetSuccess() (o map[UserId]map[Numberz]*Insanity) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestInsanity_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testInsanity" for this struct.
func (v *ThriftTest_TestInsanity_Result) MethodName() string {
	return "testInsanity"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestInsanity_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestList_Args represents the arguments for the ThriftTest.testList function.
//
// The arguments for testList are sent and received over the wire as this struct.
type ThriftTest_TestList_Args struct {
	Thing []int32 `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestList_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestList_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestList_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestList_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestList_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestList_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TList {
				v.Thing, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestList_Args
// struct.
func (v *ThriftTest_TestList_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", v.Thing)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestList_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestList_Args match the
// provided ThriftTest_TestList_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestList_Args) Equals(rhs *ThriftTest_TestList_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Thing == nil && rhs.Thing == nil) || (v.Thing != nil && rhs.Thing != nil && _List_I32_Equals(v.Thing, rhs.Thing))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestList_Args.
func (v *ThriftTest_TestList_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		err = multierr.Append(err, enc.AddArray("thing", (_List_I32_Zapper)(v.Thing)))
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestList_Args) GetThing() (o []int32) {
	if v != nil && v.Thing != nil {
		return v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestList_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testList" for this struct.
func (v *ThriftTest_TestList_Args) MethodName() string {
	return "testList"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestList_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestList_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testList
// function.
var ThriftTest_TestList_Helper = struct {
	// Args accepts the parameters of testList in-order and returns
	// the arguments struct for the function.
	Args func(
		thing []int32,
	) *ThriftTest_TestList_Args

	// IsException returns true if the given error can be thrown
	// by testList.
	//
	// An error can be thrown by testList only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testList
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testList into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testList
	//
	//   value, err := testList(args)
	//   result, err := ThriftTest_TestList_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testList: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func([]int32, error) (*ThriftTest_TestList_Result, error)

	// UnwrapResponse takes the result struct for testList
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testList threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestList_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestList_Result) ([]int32, error)
}{}

func init() {
	ThriftTest_TestList_Helper.Args = func(
		thing []int32,
	) *ThriftTest_TestList_Args {
		return &ThriftTest_TestList_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestList_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestList_Helper.WrapResponse = func(success []int32, err error) (*ThriftTest_TestList_Result, error) {
		if err == nil {
			return &ThriftTest_TestList_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestList_Helper.UnwrapResponse = func(result *ThriftTest_TestList_Result) (success []int32, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestList_Result represents the result of a ThriftTest.testList function call.
//
// The result of a testList execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestList_Result struct {
	// Value returned by testList after a successful execution.
	Success []int32 `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestList_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestList_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueList(_List_I32_ValueList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestList_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestList_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestList_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestList_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestList_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TList {
				v.Success, err = _List_I32_Read(field.Value.GetList())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestList_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestList_Result
// struct.
func (v *ThriftTest_TestList_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestList_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestList_Result match the
// provided ThriftTest_TestList_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestList_Result) Equals(rhs *ThriftTest_TestList_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _List_I32_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestList_Result.
func (v *ThriftTest_TestList_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_List_I32_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestList_Result) GetSuccess() (o []int32) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestList_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testList" for this struct.
func (v *ThriftTest_TestList_Result) MethodName() string {
	return "testList"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestList_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestMap_Args represents the arguments for the ThriftTest.testMap function.
//
// The arguments for testMap are sent and received over the wire as this struct.
type ThriftTest_TestMap_Args struct {
	Thing map[int32]int32 `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestMap_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestMap_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueMap(_Map_I32_I32_MapItemList(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestMap_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestMap_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestMap_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestMap_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Thing, err = _Map_I32_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestMap_Args
// struct.
func (v *ThriftTest_TestMap_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", v.Thing)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestMap_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestMap_Args match the
// provided ThriftTest_TestMap_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestMap_Args) Equals(rhs *ThriftTest_TestMap_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Thing == nil && rhs.Thing == nil) || (v.Thing != nil && rhs.Thing != nil && _Map_I32_I32_Equals(v.Thing, rhs.Thing))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestMap_Args.
func (v *ThriftTest_TestMap_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		err = multierr.Append(err, enc.AddArray("thing", (_Map_I32_I32_Zapper)(v.Thing)))
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMap_Args) GetThing() (o map[int32]int32) {
	if v != nil && v.Thing != nil {
		return v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestMap_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testMap" for this struct.
func (v *ThriftTest_TestMap_Args) MethodName() string {
	return "testMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestMap_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestMap_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testMap
// function.
var ThriftTest_TestMap_Helper = struct {
	// Args accepts the parameters of testMap in-order and returns
	// the arguments struct for the function.
	Args func(
		thing map[int32]int32,
	) *ThriftTest_TestMap_Args

	// IsException returns true if the given error can be thrown
	// by testMap.
	//
	// An error can be thrown by testMap only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testMap
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testMap into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testMap
	//
	//   value, err := testMap(args)
	//   result, err := ThriftTest_TestMap_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testMap: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(map[int32]int32, error) (*ThriftTest_TestMap_Result, error)

	// UnwrapResponse takes the result struct for testMap
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testMap threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestMap_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestMap_Result) (map[int32]int32, error)
}{}

func init() {
	ThriftTest_TestMap_Helper.Args = func(
		thing map[int32]int32,
	) *ThriftTest_TestMap_Args {
		return &ThriftTest_TestMap_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestMap_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestMap_Helper.WrapResponse = func(success map[int32]int32, err error) (*ThriftTest_TestMap_Result, error) {
		if err == nil {
			return &ThriftTest_TestMap_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestMap_Helper.UnwrapResponse = func(result *ThriftTest_TestMap_Result) (success map[int32]int32, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestMap_Result represents the result of a ThriftTest.testMap function call.
//
// The result of a testMap execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestMap_Result struct {
	// Value returned by testMap after a successful execution.
	Success map[int32]int32 `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestMap_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestMap_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueMap(_Map_I32_I32_MapItemList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestMap_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestMap_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestMap_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestMap_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestMap_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TMap {
				v.Success, err = _Map_I32_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestMap_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestMap_Result
// struct.
func (v *ThriftTest_TestMap_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestMap_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestMap_Result match the
// provided ThriftTest_TestMap_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestMap_Result) Equals(rhs *ThriftTest_TestMap_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Map_I32_I32_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestMap_Result.
func (v *ThriftTest_TestMap_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_Map_I32_I32_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMap_Result) GetSuccess() (o map[int32]int32) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestMap_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testMap" for this struct.
func (v *ThriftTest_TestMap_Result) MethodName() string {
	return "testMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestMap_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestMapMap_Args represents the arguments for the ThriftTest.testMapMap function.
//
// The arguments for testMapMap are sent and received over the wire as this struct.
type ThriftTest_TestMapMap_Args struct {
	Hello *int32 `json:"hello,omitempty"`
}

// ToWire translates a ThriftTest_TestMapMap_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestMapMap_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Hello != nil {
		w, err = wire.NewValueI32(*(v.Hello)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestMapMap_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestMapMap_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestMapMap_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestMapMap_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Hello = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestMapMap_Args
// struct.
func (v *ThriftTest_TestMapMap_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Hello != nil {
		fields[i] = fmt.Sprintf("Hello: %v", *(v.Hello))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestMapMap_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestMapMap_Args match the
// provided ThriftTest_TestMapMap_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestMapMap_Args) Equals(rhs *ThriftTest_TestMapMap_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.Hello, rhs.Hello) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestMapMap_Args.
func (v *ThriftTest_TestMapMap_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Hello != nil {
		enc.AddInt32("hello", *v.Hello)
	}
	return err
}

// GetHello returns the value of Hello if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMapMap_Args) GetHello() (o int32) {
	if v != nil && v.Hello != nil {
		return *v.Hello
	}

	return
}

// IsSetHello returns true if Hello is not nil.
func (v *ThriftTest_TestMapMap_Args) IsSetHello() bool {
	return v != nil && v.Hello != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testMapMap" for this struct.
func (v *ThriftTest_TestMapMap_Args) MethodName() string {
	return "testMapMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestMapMap_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestMapMap_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testMapMap
// function.
var ThriftTest_TestMapMap_Helper = struct {
	// Args accepts the parameters of testMapMap in-order and returns
	// the arguments struct for the function.
	Args func(
		hello *int32,
	) *ThriftTest_TestMapMap_Args

	// IsException returns true if the given error can be thrown
	// by testMapMap.
	//
	// An error can be thrown by testMapMap only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testMapMap
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testMapMap into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testMapMap
	//
	//   value, err := testMapMap(args)
	//   result, err := ThriftTest_TestMapMap_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testMapMap: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(map[int32]map[int32]int32, error) (*ThriftTest_TestMapMap_Result, error)

	// UnwrapResponse takes the result struct for testMapMap
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testMapMap threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestMapMap_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestMapMap_Result) (map[int32]map[int32]int32, error)
}{}

func init() {
	ThriftTest_TestMapMap_Helper.Args = func(
		hello *int32,
	) *ThriftTest_TestMapMap_Args {
		return &ThriftTest_TestMapMap_Args{
			Hello: hello,
		}
	}

	ThriftTest_TestMapMap_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestMapMap_Helper.WrapResponse = func(success map[int32]map[int32]int32, err error) (*ThriftTest_TestMapMap_Result, error) {
		if err == nil {
			return &ThriftTest_TestMapMap_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestMapMap_Helper.UnwrapResponse = func(result *ThriftTest_TestMapMap_Result) (success map[int32]map[int32]int32, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestMapMap_Result represents the result of a ThriftTest.testMapMap function call.
//
// The result of a testMapMap execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestMapMap_Result struct {
	// Value returned by testMapMap after a successful execution.
	Success map[int32]map[int32]int32 `json:"success,omitempty"`
}

type _Map_I32_Map_I32_I32_MapItemList map[int32]map[int32]int32

func (m _Map_I32_Map_I32_I32_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		if v == nil {
			return fmt.Errorf("invalid [%v]: value is nil", k)
		}
		kw, err := wire.NewValueI32(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueMap(_Map_I32_I32_MapItemList(v)), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I32_Map_I32_I32_MapItemList) Size() int {
	return len(m)
}

func (_Map_I32_Map_I32_I32_MapItemList) KeyType() wire.Type {
	return wire.TI32
}

func (_Map_I32_Map_I32_I32_MapItemList) ValueType() wire.Type {
	return wire.TMap
}

func (_Map_I32_Map_I32_I32_MapItemList) Close() {}

// ToWire translates a ThriftTest_TestMapMap_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestMapMap_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueMap(_Map_I32_Map_I32_I32_MapItemList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestMapMap_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_I32_Map_I32_I32_Read(m wire.MapItemList) (map[int32]map[int32]int32, error) {
	if m.KeyType() != wire.TI32 {
		return nil, nil
	}

	if m.ValueType() != wire.TMap {
		return nil, nil
	}

	o := make(map[int32]map[int32]int32, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI32(), error(nil)
		if err != nil {
			return err
		}

		v, err := _Map_I32_I32_Read(x.Value.GetMap())
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a ThriftTest_TestMapMap_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestMapMap_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestMapMap_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestMapMap_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TMap {
				v.Success, err = _Map_I32_Map_I32_I32_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestMapMap_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestMapMap_Result
// struct.
func (v *ThriftTest_TestMapMap_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestMapMap_Result{%v}", strings.Join(fields[:i], ", "))
}

func _Map_I32_Map_I32_I32_Equals(lhs, rhs map[int32]map[int32]int32) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !_Map_I32_I32_Equals(lv, rv) {
			return false
		}
	}
	return true
}

// Equals returns true if all the fields of this ThriftTest_TestMapMap_Result match the
// provided ThriftTest_TestMapMap_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestMapMap_Result) Equals(rhs *ThriftTest_TestMapMap_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Map_I32_Map_I32_I32_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

type _Map_I32_Map_I32_I32_Item_Zapper struct {
	Key   int32
	Value map[int32]int32
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Map_I32_I32_Item_Zapper.
func (v _Map_I32_Map_I32_I32_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt32("key", v.Key)
	err = multierr.Append(err, enc.AddArray("value", (_Map_I32_I32_Zapper)(v.Value)))
	return err
}

type _Map_I32_Map_I32_I32_Zapper map[int32]map[int32]int32

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I32_Map_I32_I32_Zapper.
func (m _Map_I32_Map_I32_I32_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I32_Map_I32_I32_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestMapMap_Result.
func (v *ThriftTest_TestMapMap_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_Map_I32_Map_I32_I32_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMapMap_Result) GetSuccess() (o map[int32]map[int32]int32) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestMapMap_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testMapMap" for this struct.
func (v *ThriftTest_TestMapMap_Result) MethodName() string {
	return "testMapMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestMapMap_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestMulti_Args represents the arguments for the ThriftTest.testMulti function.
//
// The arguments for testMulti are sent and received over the wire as this struct.
type ThriftTest_TestMulti_Args struct {
	Arg0 *int8            `json:"arg0,omitempty"`
	Arg1 *int32           `json:"arg1,omitempty"`
	Arg2 *int64           `json:"arg2,omitempty"`
	Arg3 map[int16]string `json:"arg3,omitempty"`
	Arg4 *Numberz         `json:"arg4,omitempty"`
	Arg5 *UserId          `json:"arg5,omitempty"`
}

type _Map_I16_String_MapItemList map[int16]string

func (m _Map_I16_String_MapItemList) ForEach(f func(wire.MapItem) error) error {
	for k, v := range m {
		kw, err := wire.NewValueI16(k), error(nil)
		if err != nil {
			return err
		}

		vw, err := wire.NewValueString(v), error(nil)
		if err != nil {
			return err
		}
		err = f(wire.MapItem{Key: kw, Value: vw})
		if err != nil {
			return err
		}
	}
	return nil
}

func (m _Map_I16_String_MapItemList) Size() int {
	return len(m)
}

func (_Map_I16_String_MapItemList) KeyType() wire.Type {
	return wire.TI16
}

func (_Map_I16_String_MapItemList) ValueType() wire.Type {
	return wire.TBinary
}

func (_Map_I16_String_MapItemList) Close() {}

// ToWire translates a ThriftTest_TestMulti_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestMulti_Args) ToWire() (wire.Value, error) {
	var (
		fields [6]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg0 != nil {
		w, err = wire.NewValueI8(*(v.Arg0)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Arg1 != nil {
		w, err = wire.NewValueI32(*(v.Arg1)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}
	if v.Arg2 != nil {
		w, err = wire.NewValueI64(*(v.Arg2)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 3, Value: w}
		i++
	}
	if v.Arg3 != nil {
		w, err = wire.NewValueMap(_Map_I16_String_MapItemList(v.Arg3)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 4, Value: w}
		i++
	}
	if v.Arg4 != nil {
		w, err = v.Arg4.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 5, Value: w}
		i++
	}
	if v.Arg5 != nil {
		w, err = v.Arg5.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 6, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Map_I16_String_Read(m wire.MapItemList) (map[int16]string, error) {
	if m.KeyType() != wire.TI16 {
		return nil, nil
	}

	if m.ValueType() != wire.TBinary {
		return nil, nil
	}

	o := make(map[int16]string, m.Size())
	err := m.ForEach(func(x wire.MapItem) error {
		k, err := x.Key.GetI16(), error(nil)
		if err != nil {
			return err
		}

		v, err := x.Value.GetString(), error(nil)
		if err != nil {
			return err
		}

		o[k] = v
		return nil
	})
	m.Close()
	return o, err
}

// FromWire deserializes a ThriftTest_TestMulti_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestMulti_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestMulti_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestMulti_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI8 {
				var x int8
				x, err = field.Value.GetI8(), error(nil)
				v.Arg0 = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.Arg1 = &x
				if err != nil {
					return err
				}

			}
		case 3:
			if field.Value.Type() == wire.TI64 {
				var x int64
				x, err = field.Value.GetI64(), error(nil)
				v.Arg2 = &x
				if err != nil {
					return err
				}

			}
		case 4:
			if field.Value.Type() == wire.TMap {
				v.Arg3, err = _Map_I16_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		case 5:
			if field.Value.Type() == wire.TI32 {
				var x Numberz
				x, err = _Numberz_Read(field.Value)
				v.Arg4 = &x
				if err != nil {
					return err
				}

			}
		case 6:
			if field.Value.Type() == wire.TI64 {
				var x UserId
				x, err = _UserId_Read(field.Value)
				v.Arg5 = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestMulti_Args
// struct.
func (v *ThriftTest_TestMulti_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [6]string
	i := 0
	if v.Arg0 != nil {
		fields[i] = fmt.Sprintf("Arg0: %v", *(v.Arg0))
		i++
	}
	if v.Arg1 != nil {
		fields[i] = fmt.Sprintf("Arg1: %v", *(v.Arg1))
		i++
	}
	if v.Arg2 != nil {
		fields[i] = fmt.Sprintf("Arg2: %v", *(v.Arg2))
		i++
	}
	if v.Arg3 != nil {
		fields[i] = fmt.Sprintf("Arg3: %v", v.Arg3)
		i++
	}
	if v.Arg4 != nil {
		fields[i] = fmt.Sprintf("Arg4: %v", *(v.Arg4))
		i++
	}
	if v.Arg5 != nil {
		fields[i] = fmt.Sprintf("Arg5: %v", *(v.Arg5))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestMulti_Args{%v}", strings.Join(fields[:i], ", "))
}

func _Map_I16_String_Equals(lhs, rhs map[int16]string) bool {
	if len(lhs) != len(rhs) {
		return false
	}

	for lk, lv := range lhs {
		rv, ok := rhs[lk]
		if !ok {
			return false
		}
		if !(lv == rv) {
			return false
		}
	}
	return true
}

func _UserId_EqualsPtr(lhs, rhs *UserId) bool {
	if lhs != nil && rhs != nil {

		x := *lhs
		y := *rhs
		return (x == y)
	}
	return lhs == nil && rhs == nil
}

// Equals returns true if all the fields of this ThriftTest_TestMulti_Args match the
// provided ThriftTest_TestMulti_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestMulti_Args) Equals(rhs *ThriftTest_TestMulti_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_Byte_EqualsPtr(v.Arg0, rhs.Arg0) {
		return false
	}
	if !_I32_EqualsPtr(v.Arg1, rhs.Arg1) {
		return false
	}
	if !_I64_EqualsPtr(v.Arg2, rhs.Arg2) {
		return false
	}
	if !((v.Arg3 == nil && rhs.Arg3 == nil) || (v.Arg3 != nil && rhs.Arg3 != nil && _Map_I16_String_Equals(v.Arg3, rhs.Arg3))) {
		return false
	}
	if !_Numberz_EqualsPtr(v.Arg4, rhs.Arg4) {
		return false
	}
	if !_UserId_EqualsPtr(v.Arg5, rhs.Arg5) {
		return false
	}

	return true
}

type _Map_I16_String_Item_Zapper struct {
	Key   int16
	Value string
}

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I16_String_Item_Zapper.
func (v _Map_I16_String_Item_Zapper) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	enc.AddInt16("key", v.Key)
	enc.AddString("value", v.Value)
	return err
}

type _Map_I16_String_Zapper map[int16]string

// MarshalLogArray implements zapcore.ArrayMarshaler, enabling
// fast logging of _Map_I16_String_Zapper.
func (m _Map_I16_String_Zapper) MarshalLogArray(enc zapcore.ArrayEncoder) (err error) {
	for k, v := range m {
		err = multierr.Append(err, enc.AppendObject(_Map_I16_String_Item_Zapper{Key: k, Value: v}))
	}
	return err
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestMulti_Args.
func (v *ThriftTest_TestMulti_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Arg0 != nil {
		enc.AddInt8("arg0", *v.Arg0)
	}
	if v.Arg1 != nil {
		enc.AddInt32("arg1", *v.Arg1)
	}
	if v.Arg2 != nil {
		enc.AddInt64("arg2", *v.Arg2)
	}
	if v.Arg3 != nil {
		err = multierr.Append(err, enc.AddArray("arg3", (_Map_I16_String_Zapper)(v.Arg3)))
	}
	if v.Arg4 != nil {
		err = multierr.Append(err, enc.AddObject("arg4", *v.Arg4))
	}
	if v.Arg5 != nil {
		enc.AddInt64("arg5", (int64)(*v.Arg5))
	}
	return err
}

// GetArg0 returns the value of Arg0 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMulti_Args) GetArg0() (o int8) {
	if v != nil && v.Arg0 != nil {
		return *v.Arg0
	}

	return
}

// IsSetArg0 returns true if Arg0 is not nil.
func (v *ThriftTest_TestMulti_Args) IsSetArg0() bool {
	return v != nil && v.Arg0 != nil
}

// GetArg1 returns the value of Arg1 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMulti_Args) GetArg1() (o int32) {
	if v != nil && v.Arg1 != nil {
		return *v.Arg1
	}

	return
}

// IsSetArg1 returns true if Arg1 is not nil.
func (v *ThriftTest_TestMulti_Args) IsSetArg1() bool {
	return v != nil && v.Arg1 != nil
}

// GetArg2 returns the value of Arg2 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMulti_Args) GetArg2() (o int64) {
	if v != nil && v.Arg2 != nil {
		return *v.Arg2
	}

	return
}

// IsSetArg2 returns true if Arg2 is not nil.
func (v *ThriftTest_TestMulti_Args) IsSetArg2() bool {
	return v != nil && v.Arg2 != nil
}

// GetArg3 returns the value of Arg3 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMulti_Args) GetArg3() (o map[int16]string) {
	if v != nil && v.Arg3 != nil {
		return v.Arg3
	}

	return
}

// IsSetArg3 returns true if Arg3 is not nil.
func (v *ThriftTest_TestMulti_Args) IsSetArg3() bool {
	return v != nil && v.Arg3 != nil
}

// GetArg4 returns the value of Arg4 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMulti_Args) GetArg4() (o Numberz) {
	if v != nil && v.Arg4 != nil {
		return *v.Arg4
	}

	return
}

// IsSetArg4 returns true if Arg4 is not nil.
func (v *ThriftTest_TestMulti_Args) IsSetArg4() bool {
	return v != nil && v.Arg4 != nil
}

// GetArg5 returns the value of Arg5 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMulti_Args) GetArg5() (o UserId) {
	if v != nil && v.Arg5 != nil {
		return *v.Arg5
	}

	return
}

// IsSetArg5 returns true if Arg5 is not nil.
func (v *ThriftTest_TestMulti_Args) IsSetArg5() bool {
	return v != nil && v.Arg5 != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testMulti" for this struct.
func (v *ThriftTest_TestMulti_Args) MethodName() string {
	return "testMulti"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestMulti_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestMulti_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testMulti
// function.
var ThriftTest_TestMulti_Helper = struct {
	// Args accepts the parameters of testMulti in-order and returns
	// the arguments struct for the function.
	Args func(
		arg0 *int8,
		arg1 *int32,
		arg2 *int64,
		arg3 map[int16]string,
		arg4 *Numberz,
		arg5 *UserId,
	) *ThriftTest_TestMulti_Args

	// IsException returns true if the given error can be thrown
	// by testMulti.
	//
	// An error can be thrown by testMulti only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testMulti
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testMulti into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testMulti
	//
	//   value, err := testMulti(args)
	//   result, err := ThriftTest_TestMulti_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testMulti: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*Xtruct, error) (*ThriftTest_TestMulti_Result, error)

	// UnwrapResponse takes the result struct for testMulti
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testMulti threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestMulti_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestMulti_Result) (*Xtruct, error)
}{}

func init() {
	ThriftTest_TestMulti_Helper.Args = func(
		arg0 *int8,
		arg1 *int32,
		arg2 *int64,
		arg3 map[int16]string,
		arg4 *Numberz,
		arg5 *UserId,
	) *ThriftTest_TestMulti_Args {
		return &ThriftTest_TestMulti_Args{
			Arg0: arg0,
			Arg1: arg1,
			Arg2: arg2,
			Arg3: arg3,
			Arg4: arg4,
			Arg5: arg5,
		}
	}

	ThriftTest_TestMulti_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestMulti_Helper.WrapResponse = func(success *Xtruct, err error) (*ThriftTest_TestMulti_Result, error) {
		if err == nil {
			return &ThriftTest_TestMulti_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestMulti_Helper.UnwrapResponse = func(result *ThriftTest_TestMulti_Result) (success *Xtruct, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestMulti_Result represents the result of a ThriftTest.testMulti function call.
//
// The result of a testMulti execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestMulti_Result struct {
	// Value returned by testMulti after a successful execution.
	Success *Xtruct `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestMulti_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestMulti_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestMulti_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestMulti_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestMulti_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestMulti_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestMulti_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestMulti_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestMulti_Result
// struct.
func (v *ThriftTest_TestMulti_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestMulti_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestMulti_Result match the
// provided ThriftTest_TestMulti_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestMulti_Result) Equals(rhs *ThriftTest_TestMulti_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestMulti_Result.
func (v *ThriftTest_TestMulti_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMulti_Result) GetSuccess() (o *Xtruct) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestMulti_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testMulti" for this struct.
func (v *ThriftTest_TestMulti_Result) MethodName() string {
	return "testMulti"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestMulti_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestMultiException_Args represents the arguments for the ThriftTest.testMultiException function.
//
// The arguments for testMultiException are sent and received over the wire as this struct.
type ThriftTest_TestMultiException_Args struct {
	Arg0 *string `json:"arg0,omitempty"`
	Arg1 *string `json:"arg1,omitempty"`
}

// ToWire translates a ThriftTest_TestMultiException_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestMultiException_Args) ToWire() (wire.Value, error) {
	var (
		fields [2]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Arg0 != nil {
		w, err = wire.NewValueString(*(v.Arg0)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Arg1 != nil {
		w, err = wire.NewValueString(*(v.Arg1)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestMultiException_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestMultiException_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestMultiException_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestMultiException_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Arg0 = &x
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Arg1 = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestMultiException_Args
// struct.
func (v *ThriftTest_TestMultiException_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [2]string
	i := 0
	if v.Arg0 != nil {
		fields[i] = fmt.Sprintf("Arg0: %v", *(v.Arg0))
		i++
	}
	if v.Arg1 != nil {
		fields[i] = fmt.Sprintf("Arg1: %v", *(v.Arg1))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestMultiException_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestMultiException_Args match the
// provided ThriftTest_TestMultiException_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestMultiException_Args) Equals(rhs *ThriftTest_TestMultiException_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Arg0, rhs.Arg0) {
		return false
	}
	if !_String_EqualsPtr(v.Arg1, rhs.Arg1) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestMultiException_Args.
func (v *ThriftTest_TestMultiException_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Arg0 != nil {
		enc.AddString("arg0", *v.Arg0)
	}
	if v.Arg1 != nil {
		enc.AddString("arg1", *v.Arg1)
	}
	return err
}

// GetArg0 returns the value of Arg0 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMultiException_Args) GetArg0() (o string) {
	if v != nil && v.Arg0 != nil {
		return *v.Arg0
	}

	return
}

// IsSetArg0 returns true if Arg0 is not nil.
func (v *ThriftTest_TestMultiException_Args) IsSetArg0() bool {
	return v != nil && v.Arg0 != nil
}

// GetArg1 returns the value of Arg1 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMultiException_Args) GetArg1() (o string) {
	if v != nil && v.Arg1 != nil {
		return *v.Arg1
	}

	return
}

// IsSetArg1 returns true if Arg1 is not nil.
func (v *ThriftTest_TestMultiException_Args) IsSetArg1() bool {
	return v != nil && v.Arg1 != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testMultiException" for this struct.
func (v *ThriftTest_TestMultiException_Args) MethodName() string {
	return "testMultiException"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestMultiException_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestMultiException_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testMultiException
// function.
var ThriftTest_TestMultiException_Helper = struct {
	// Args accepts the parameters of testMultiException in-order and returns
	// the arguments struct for the function.
	Args func(
		arg0 *string,
		arg1 *string,
	) *ThriftTest_TestMultiException_Args

	// IsException returns true if the given error can be thrown
	// by testMultiException.
	//
	// An error can be thrown by testMultiException only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testMultiException
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testMultiException into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testMultiException
	//
	//   value, err := testMultiException(args)
	//   result, err := ThriftTest_TestMultiException_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testMultiException: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*Xtruct, error) (*ThriftTest_TestMultiException_Result, error)

	// UnwrapResponse takes the result struct for testMultiException
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testMultiException threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestMultiException_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestMultiException_Result) (*Xtruct, error)
}{}

func init() {
	ThriftTest_TestMultiException_Helper.Args = func(
		arg0 *string,
		arg1 *string,
	) *ThriftTest_TestMultiException_Args {
		return &ThriftTest_TestMultiException_Args{
			Arg0: arg0,
			Arg1: arg1,
		}
	}

	ThriftTest_TestMultiException_Helper.IsException = func(err error) bool {
		switch err.(type) {
		case *Xception:
			return true
		case *Xception2:
			return true
		default:
			return false
		}
	}

	ThriftTest_TestMultiException_Helper.WrapResponse = func(success *Xtruct, err error) (*ThriftTest_TestMultiException_Result, error) {
		if err == nil {
			return &ThriftTest_TestMultiException_Result{Success: success}, nil
		}

		switch e := err.(type) {
		case *Xception:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for ThriftTest_TestMultiException_Result.Err1")
			}
			return &ThriftTest_TestMultiException_Result{Err1: e}, nil
		case *Xception2:
			if e == nil {
				return nil, errors.New("WrapResponse received non-nil error type with nil value for ThriftTest_TestMultiException_Result.Err2")
			}
			return &ThriftTest_TestMultiException_Result{Err2: e}, nil
		}

		return nil, err
	}
	ThriftTest_TestMultiException_Helper.UnwrapResponse = func(result *ThriftTest_TestMultiException_Result) (success *Xtruct, err error) {
		if result.Err1 != nil {
			err = result.Err1
			return
		}
		if result.Err2 != nil {
			err = result.Err2
			return
		}

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestMultiException_Result represents the result of a ThriftTest.testMultiException function call.
//
// The result of a testMultiException execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestMultiException_Result struct {
	// Value returned by testMultiException after a successful execution.
	Success *Xtruct    `json:"success,omitempty"`
	Err1    *Xception  `json:"err1,omitempty"`
	Err2    *Xception2 `json:"err2,omitempty"`
}

// ToWire translates a ThriftTest_TestMultiException_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestMultiException_Result) ToWire() (wire.Value, error) {
	var (
		fields [3]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}
	if v.Err1 != nil {
		w, err = v.Err1.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}
	if v.Err2 != nil {
		w, err = v.Err2.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 2, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestMultiException_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Xception2_Read(w wire.Value) (*Xception2, error) {
	var v Xception2
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a ThriftTest_TestMultiException_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestMultiException_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestMultiException_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestMultiException_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Err1, err = _Xception_Read(field.Value)
				if err != nil {
					return err
				}

			}
		case 2:
			if field.Value.Type() == wire.TStruct {
				v.Err2, err = _Xception2_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if v.Err1 != nil {
		count++
	}
	if v.Err2 != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestMultiException_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestMultiException_Result
// struct.
func (v *ThriftTest_TestMultiException_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [3]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}
	if v.Err1 != nil {
		fields[i] = fmt.Sprintf("Err1: %v", v.Err1)
		i++
	}
	if v.Err2 != nil {
		fields[i] = fmt.Sprintf("Err2: %v", v.Err2)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestMultiException_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestMultiException_Result match the
// provided ThriftTest_TestMultiException_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestMultiException_Result) Equals(rhs *ThriftTest_TestMultiException_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}
	if !((v.Err1 == nil && rhs.Err1 == nil) || (v.Err1 != nil && rhs.Err1 != nil && v.Err1.Equals(rhs.Err1))) {
		return false
	}
	if !((v.Err2 == nil && rhs.Err2 == nil) || (v.Err2 != nil && rhs.Err2 != nil && v.Err2.Equals(rhs.Err2))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestMultiException_Result.
func (v *ThriftTest_TestMultiException_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	if v.Err1 != nil {
		err = multierr.Append(err, enc.AddObject("err1", v.Err1))
	}
	if v.Err2 != nil {
		err = multierr.Append(err, enc.AddObject("err2", v.Err2))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMultiException_Result) GetSuccess() (o *Xtruct) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestMultiException_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// GetErr1 returns the value of Err1 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMultiException_Result) GetErr1() (o *Xception) {
	if v != nil && v.Err1 != nil {
		return v.Err1
	}

	return
}

// IsSetErr1 returns true if Err1 is not nil.
func (v *ThriftTest_TestMultiException_Result) IsSetErr1() bool {
	return v != nil && v.Err1 != nil
}

// GetErr2 returns the value of Err2 if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestMultiException_Result) GetErr2() (o *Xception2) {
	if v != nil && v.Err2 != nil {
		return v.Err2
	}

	return
}

// IsSetErr2 returns true if Err2 is not nil.
func (v *ThriftTest_TestMultiException_Result) IsSetErr2() bool {
	return v != nil && v.Err2 != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testMultiException" for this struct.
func (v *ThriftTest_TestMultiException_Result) MethodName() string {
	return "testMultiException"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestMultiException_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestNest_Args represents the arguments for the ThriftTest.testNest function.
//
// The arguments for testNest are sent and received over the wire as this struct.
type ThriftTest_TestNest_Args struct {
	Thing *Xtruct2 `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestNest_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestNest_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = v.Thing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

func _Xtruct2_Read(w wire.Value) (*Xtruct2, error) {
	var v Xtruct2
	err := v.FromWire(w)
	return &v, err
}

// FromWire deserializes a ThriftTest_TestNest_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestNest_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestNest_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestNest_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Thing, err = _Xtruct2_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestNest_Args
// struct.
func (v *ThriftTest_TestNest_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", v.Thing)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestNest_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestNest_Args match the
// provided ThriftTest_TestNest_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestNest_Args) Equals(rhs *ThriftTest_TestNest_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Thing == nil && rhs.Thing == nil) || (v.Thing != nil && rhs.Thing != nil && v.Thing.Equals(rhs.Thing))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestNest_Args.
func (v *ThriftTest_TestNest_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		err = multierr.Append(err, enc.AddObject("thing", v.Thing))
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestNest_Args) GetThing() (o *Xtruct2) {
	if v != nil && v.Thing != nil {
		return v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestNest_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testNest" for this struct.
func (v *ThriftTest_TestNest_Args) MethodName() string {
	return "testNest"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestNest_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestNest_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testNest
// function.
var ThriftTest_TestNest_Helper = struct {
	// Args accepts the parameters of testNest in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *Xtruct2,
	) *ThriftTest_TestNest_Args

	// IsException returns true if the given error can be thrown
	// by testNest.
	//
	// An error can be thrown by testNest only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testNest
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testNest into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testNest
	//
	//   value, err := testNest(args)
	//   result, err := ThriftTest_TestNest_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testNest: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*Xtruct2, error) (*ThriftTest_TestNest_Result, error)

	// UnwrapResponse takes the result struct for testNest
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testNest threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestNest_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestNest_Result) (*Xtruct2, error)
}{}

func init() {
	ThriftTest_TestNest_Helper.Args = func(
		thing *Xtruct2,
	) *ThriftTest_TestNest_Args {
		return &ThriftTest_TestNest_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestNest_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestNest_Helper.WrapResponse = func(success *Xtruct2, err error) (*ThriftTest_TestNest_Result, error) {
		if err == nil {
			return &ThriftTest_TestNest_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestNest_Helper.UnwrapResponse = func(result *ThriftTest_TestNest_Result) (success *Xtruct2, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestNest_Result represents the result of a ThriftTest.testNest function call.
//
// The result of a testNest execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestNest_Result struct {
	// Value returned by testNest after a successful execution.
	Success *Xtruct2 `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestNest_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestNest_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestNest_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestNest_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestNest_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestNest_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestNest_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _Xtruct2_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestNest_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestNest_Result
// struct.
func (v *ThriftTest_TestNest_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestNest_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestNest_Result match the
// provided ThriftTest_TestNest_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestNest_Result) Equals(rhs *ThriftTest_TestNest_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestNest_Result.
func (v *ThriftTest_TestNest_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestNest_Result) GetSuccess() (o *Xtruct2) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestNest_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testNest" for this struct.
func (v *ThriftTest_TestNest_Result) MethodName() string {
	return "testNest"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestNest_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestOneway_Args represents the arguments for the ThriftTest.testOneway function.
//
// The arguments for testOneway are sent and received over the wire as this struct.
type ThriftTest_TestOneway_Args struct {
	SecondsToSleep *int32 `json:"secondsToSleep,omitempty"`
}

// ToWire translates a ThriftTest_TestOneway_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestOneway_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.SecondsToSleep != nil {
		w, err = wire.NewValueI32(*(v.SecondsToSleep)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestOneway_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestOneway_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestOneway_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestOneway_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI32 {
				var x int32
				x, err = field.Value.GetI32(), error(nil)
				v.SecondsToSleep = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestOneway_Args
// struct.
func (v *ThriftTest_TestOneway_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.SecondsToSleep != nil {
		fields[i] = fmt.Sprintf("SecondsToSleep: %v", *(v.SecondsToSleep))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestOneway_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestOneway_Args match the
// provided ThriftTest_TestOneway_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestOneway_Args) Equals(rhs *ThriftTest_TestOneway_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_I32_EqualsPtr(v.SecondsToSleep, rhs.SecondsToSleep) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestOneway_Args.
func (v *ThriftTest_TestOneway_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.SecondsToSleep != nil {
		enc.AddInt32("secondsToSleep", *v.SecondsToSleep)
	}
	return err
}

// GetSecondsToSleep returns the value of SecondsToSleep if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestOneway_Args) GetSecondsToSleep() (o int32) {
	if v != nil && v.SecondsToSleep != nil {
		return *v.SecondsToSleep
	}

	return
}

// IsSetSecondsToSleep returns true if SecondsToSleep is not nil.
func (v *ThriftTest_TestOneway_Args) IsSetSecondsToSleep() bool {
	return v != nil && v.SecondsToSleep != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testOneway" for this struct.
func (v *ThriftTest_TestOneway_Args) MethodName() string {
	return "testOneway"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be OneWay for this struct.
func (v *ThriftTest_TestOneway_Args) EnvelopeType() wire.EnvelopeType {
	return wire.OneWay
}

// ThriftTest_TestOneway_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testOneway
// function.
var ThriftTest_TestOneway_Helper = struct {
	// Args accepts the parameters of testOneway in-order and returns
	// the arguments struct for the function.
	Args func(
		secondsToSleep *int32,
	) *ThriftTest_TestOneway_Args
}{}

func init() {
	ThriftTest_TestOneway_Helper.Args = func(
		secondsToSleep *int32,
	) *ThriftTest_TestOneway_Args {
		return &ThriftTest_TestOneway_Args{
			SecondsToSleep: secondsToSleep,
		}
	}

}

// ThriftTest_TestSet_Args represents the arguments for the ThriftTest.testSet function.
//
// The arguments for testSet are sent and received over the wire as this struct.
type ThriftTest_TestSet_Args struct {
	Thing map[int32]struct{} `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestSet_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestSet_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueSet(_Set_I32_mapType_ValueList(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestSet_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestSet_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestSet_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestSet_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TSet {
				v.Thing, err = _Set_I32_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestSet_Args
// struct.
func (v *ThriftTest_TestSet_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", v.Thing)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestSet_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestSet_Args match the
// provided ThriftTest_TestSet_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestSet_Args) Equals(rhs *ThriftTest_TestSet_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Thing == nil && rhs.Thing == nil) || (v.Thing != nil && rhs.Thing != nil && _Set_I32_mapType_Equals(v.Thing, rhs.Thing))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestSet_Args.
func (v *ThriftTest_TestSet_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		err = multierr.Append(err, enc.AddArray("thing", (_Set_I32_mapType_Zapper)(v.Thing)))
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestSet_Args) GetThing() (o map[int32]struct{}) {
	if v != nil && v.Thing != nil {
		return v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestSet_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testSet" for this struct.
func (v *ThriftTest_TestSet_Args) MethodName() string {
	return "testSet"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestSet_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestSet_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testSet
// function.
var ThriftTest_TestSet_Helper = struct {
	// Args accepts the parameters of testSet in-order and returns
	// the arguments struct for the function.
	Args func(
		thing map[int32]struct{},
	) *ThriftTest_TestSet_Args

	// IsException returns true if the given error can be thrown
	// by testSet.
	//
	// An error can be thrown by testSet only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testSet
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testSet into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testSet
	//
	//   value, err := testSet(args)
	//   result, err := ThriftTest_TestSet_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testSet: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(map[int32]struct{}, error) (*ThriftTest_TestSet_Result, error)

	// UnwrapResponse takes the result struct for testSet
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testSet threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestSet_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestSet_Result) (map[int32]struct{}, error)
}{}

func init() {
	ThriftTest_TestSet_Helper.Args = func(
		thing map[int32]struct{},
	) *ThriftTest_TestSet_Args {
		return &ThriftTest_TestSet_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestSet_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestSet_Helper.WrapResponse = func(success map[int32]struct{}, err error) (*ThriftTest_TestSet_Result, error) {
		if err == nil {
			return &ThriftTest_TestSet_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestSet_Helper.UnwrapResponse = func(result *ThriftTest_TestSet_Result) (success map[int32]struct{}, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestSet_Result represents the result of a ThriftTest.testSet function call.
//
// The result of a testSet execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestSet_Result struct {
	// Value returned by testSet after a successful execution.
	Success map[int32]struct{} `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestSet_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestSet_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueSet(_Set_I32_mapType_ValueList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestSet_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestSet_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestSet_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestSet_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestSet_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TSet {
				v.Success, err = _Set_I32_mapType_Read(field.Value.GetSet())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestSet_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestSet_Result
// struct.
func (v *ThriftTest_TestSet_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestSet_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestSet_Result match the
// provided ThriftTest_TestSet_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestSet_Result) Equals(rhs *ThriftTest_TestSet_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Set_I32_mapType_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestSet_Result.
func (v *ThriftTest_TestSet_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddArray("success", (_Set_I32_mapType_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestSet_Result) GetSuccess() (o map[int32]struct{}) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestSet_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testSet" for this struct.
func (v *ThriftTest_TestSet_Result) MethodName() string {
	return "testSet"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestSet_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestString_Args represents the arguments for the ThriftTest.testString function.
//
// The arguments for testString are sent and received over the wire as this struct.
type ThriftTest_TestString_Args struct {
	Thing *string `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestString_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestString_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueString(*(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestString_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestString_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestString_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestString_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestString_Args
// struct.
func (v *ThriftTest_TestString_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", *(v.Thing))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestString_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestString_Args match the
// provided ThriftTest_TestString_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestString_Args) Equals(rhs *ThriftTest_TestString_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Thing, rhs.Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestString_Args.
func (v *ThriftTest_TestString_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		enc.AddString("thing", *v.Thing)
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestString_Args) GetThing() (o string) {
	if v != nil && v.Thing != nil {
		return *v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestString_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testString" for this struct.
func (v *ThriftTest_TestString_Args) MethodName() string {
	return "testString"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestString_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestString_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testString
// function.
var ThriftTest_TestString_Helper = struct {
	// Args accepts the parameters of testString in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *string,
	) *ThriftTest_TestString_Args

	// IsException returns true if the given error can be thrown
	// by testString.
	//
	// An error can be thrown by testString only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testString
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testString into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testString
	//
	//   value, err := testString(args)
	//   result, err := ThriftTest_TestString_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testString: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(string, error) (*ThriftTest_TestString_Result, error)

	// UnwrapResponse takes the result struct for testString
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testString threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestString_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestString_Result) (string, error)
}{}

func init() {
	ThriftTest_TestString_Helper.Args = func(
		thing *string,
	) *ThriftTest_TestString_Args {
		return &ThriftTest_TestString_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestString_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestString_Helper.WrapResponse = func(success string, err error) (*ThriftTest_TestString_Result, error) {
		if err == nil {
			return &ThriftTest_TestString_Result{Success: &success}, nil
		}

		return nil, err
	}
	ThriftTest_TestString_Helper.UnwrapResponse = func(result *ThriftTest_TestString_Result) (success string, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestString_Result represents the result of a ThriftTest.testString function call.
//
// The result of a testString execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestString_Result struct {
	// Value returned by testString after a successful execution.
	Success *string `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestString_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestString_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueString(*(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestString_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestString_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestString_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestString_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestString_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TBinary {
				var x string
				x, err = field.Value.GetString(), error(nil)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestString_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestString_Result
// struct.
func (v *ThriftTest_TestString_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestString_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestString_Result match the
// provided ThriftTest_TestString_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestString_Result) Equals(rhs *ThriftTest_TestString_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_String_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestString_Result.
func (v *ThriftTest_TestString_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddString("success", *v.Success)
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestString_Result) GetSuccess() (o string) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestString_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testString" for this struct.
func (v *ThriftTest_TestString_Result) MethodName() string {
	return "testString"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestString_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestStringMap_Args represents the arguments for the ThriftTest.testStringMap function.
//
// The arguments for testStringMap are sent and received over the wire as this struct.
type ThriftTest_TestStringMap_Args struct {
	Thing map[string]string `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestStringMap_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestStringMap_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Thing)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestStringMap_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestStringMap_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestStringMap_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestStringMap_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TMap {
				v.Thing, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestStringMap_Args
// struct.
func (v *ThriftTest_TestStringMap_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", v.Thing)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestStringMap_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestStringMap_Args match the
// provided ThriftTest_TestStringMap_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestStringMap_Args) Equals(rhs *ThriftTest_TestStringMap_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Thing == nil && rhs.Thing == nil) || (v.Thing != nil && rhs.Thing != nil && _Map_String_String_Equals(v.Thing, rhs.Thing))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestStringMap_Args.
func (v *ThriftTest_TestStringMap_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		err = multierr.Append(err, enc.AddObject("thing", (_Map_String_String_Zapper)(v.Thing)))
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestStringMap_Args) GetThing() (o map[string]string) {
	if v != nil && v.Thing != nil {
		return v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestStringMap_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testStringMap" for this struct.
func (v *ThriftTest_TestStringMap_Args) MethodName() string {
	return "testStringMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestStringMap_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestStringMap_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testStringMap
// function.
var ThriftTest_TestStringMap_Helper = struct {
	// Args accepts the parameters of testStringMap in-order and returns
	// the arguments struct for the function.
	Args func(
		thing map[string]string,
	) *ThriftTest_TestStringMap_Args

	// IsException returns true if the given error can be thrown
	// by testStringMap.
	//
	// An error can be thrown by testStringMap only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testStringMap
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testStringMap into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testStringMap
	//
	//   value, err := testStringMap(args)
	//   result, err := ThriftTest_TestStringMap_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testStringMap: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(map[string]string, error) (*ThriftTest_TestStringMap_Result, error)

	// UnwrapResponse takes the result struct for testStringMap
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testStringMap threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestStringMap_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestStringMap_Result) (map[string]string, error)
}{}

func init() {
	ThriftTest_TestStringMap_Helper.Args = func(
		thing map[string]string,
	) *ThriftTest_TestStringMap_Args {
		return &ThriftTest_TestStringMap_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestStringMap_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestStringMap_Helper.WrapResponse = func(success map[string]string, err error) (*ThriftTest_TestStringMap_Result, error) {
		if err == nil {
			return &ThriftTest_TestStringMap_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestStringMap_Helper.UnwrapResponse = func(result *ThriftTest_TestStringMap_Result) (success map[string]string, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestStringMap_Result represents the result of a ThriftTest.testStringMap function call.
//
// The result of a testStringMap execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestStringMap_Result struct {
	// Value returned by testStringMap after a successful execution.
	Success map[string]string `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestStringMap_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestStringMap_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = wire.NewValueMap(_Map_String_String_MapItemList(v.Success)), error(nil)
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestStringMap_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestStringMap_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestStringMap_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestStringMap_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestStringMap_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TMap {
				v.Success, err = _Map_String_String_Read(field.Value.GetMap())
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestStringMap_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestStringMap_Result
// struct.
func (v *ThriftTest_TestStringMap_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestStringMap_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestStringMap_Result match the
// provided ThriftTest_TestStringMap_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestStringMap_Result) Equals(rhs *ThriftTest_TestStringMap_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && _Map_String_String_Equals(v.Success, rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestStringMap_Result.
func (v *ThriftTest_TestStringMap_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", (_Map_String_String_Zapper)(v.Success)))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestStringMap_Result) GetSuccess() (o map[string]string) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestStringMap_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testStringMap" for this struct.
func (v *ThriftTest_TestStringMap_Result) MethodName() string {
	return "testStringMap"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestStringMap_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestStruct_Args represents the arguments for the ThriftTest.testStruct function.
//
// The arguments for testStruct are sent and received over the wire as this struct.
type ThriftTest_TestStruct_Args struct {
	Thing *Xtruct `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestStruct_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestStruct_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = v.Thing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestStruct_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestStruct_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestStruct_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestStruct_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TStruct {
				v.Thing, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestStruct_Args
// struct.
func (v *ThriftTest_TestStruct_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", v.Thing)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestStruct_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestStruct_Args match the
// provided ThriftTest_TestStruct_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestStruct_Args) Equals(rhs *ThriftTest_TestStruct_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Thing == nil && rhs.Thing == nil) || (v.Thing != nil && rhs.Thing != nil && v.Thing.Equals(rhs.Thing))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestStruct_Args.
func (v *ThriftTest_TestStruct_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		err = multierr.Append(err, enc.AddObject("thing", v.Thing))
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestStruct_Args) GetThing() (o *Xtruct) {
	if v != nil && v.Thing != nil {
		return v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestStruct_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testStruct" for this struct.
func (v *ThriftTest_TestStruct_Args) MethodName() string {
	return "testStruct"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestStruct_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestStruct_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testStruct
// function.
var ThriftTest_TestStruct_Helper = struct {
	// Args accepts the parameters of testStruct in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *Xtruct,
	) *ThriftTest_TestStruct_Args

	// IsException returns true if the given error can be thrown
	// by testStruct.
	//
	// An error can be thrown by testStruct only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testStruct
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testStruct into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testStruct
	//
	//   value, err := testStruct(args)
	//   result, err := ThriftTest_TestStruct_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testStruct: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(*Xtruct, error) (*ThriftTest_TestStruct_Result, error)

	// UnwrapResponse takes the result struct for testStruct
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testStruct threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestStruct_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestStruct_Result) (*Xtruct, error)
}{}

func init() {
	ThriftTest_TestStruct_Helper.Args = func(
		thing *Xtruct,
	) *ThriftTest_TestStruct_Args {
		return &ThriftTest_TestStruct_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestStruct_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestStruct_Helper.WrapResponse = func(success *Xtruct, err error) (*ThriftTest_TestStruct_Result, error) {
		if err == nil {
			return &ThriftTest_TestStruct_Result{Success: success}, nil
		}

		return nil, err
	}
	ThriftTest_TestStruct_Helper.UnwrapResponse = func(result *ThriftTest_TestStruct_Result) (success *Xtruct, err error) {

		if result.Success != nil {
			success = result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestStruct_Result represents the result of a ThriftTest.testStruct function call.
//
// The result of a testStruct execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestStruct_Result struct {
	// Value returned by testStruct after a successful execution.
	Success *Xtruct `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestStruct_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestStruct_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestStruct_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestStruct_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestStruct_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestStruct_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestStruct_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TStruct {
				v.Success, err = _Xtruct_Read(field.Value)
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestStruct_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestStruct_Result
// struct.
func (v *ThriftTest_TestStruct_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", v.Success)
		i++
	}

	return fmt.Sprintf("ThriftTest_TestStruct_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestStruct_Result match the
// provided ThriftTest_TestStruct_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestStruct_Result) Equals(rhs *ThriftTest_TestStruct_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !((v.Success == nil && rhs.Success == nil) || (v.Success != nil && rhs.Success != nil && v.Success.Equals(rhs.Success))) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestStruct_Result.
func (v *ThriftTest_TestStruct_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		err = multierr.Append(err, enc.AddObject("success", v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestStruct_Result) GetSuccess() (o *Xtruct) {
	if v != nil && v.Success != nil {
		return v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestStruct_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testStruct" for this struct.
func (v *ThriftTest_TestStruct_Result) MethodName() string {
	return "testStruct"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestStruct_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestTypedef_Args represents the arguments for the ThriftTest.testTypedef function.
//
// The arguments for testTypedef are sent and received over the wire as this struct.
type ThriftTest_TestTypedef_Args struct {
	Thing *UserId `json:"thing,omitempty"`
}

// ToWire translates a ThriftTest_TestTypedef_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestTypedef_Args) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Thing != nil {
		w, err = v.Thing.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 1, Value: w}
		i++
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestTypedef_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestTypedef_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestTypedef_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestTypedef_Args) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 1:
			if field.Value.Type() == wire.TI64 {
				var x UserId
				x, err = _UserId_Read(field.Value)
				v.Thing = &x
				if err != nil {
					return err
				}

			}
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestTypedef_Args
// struct.
func (v *ThriftTest_TestTypedef_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Thing != nil {
		fields[i] = fmt.Sprintf("Thing: %v", *(v.Thing))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestTypedef_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestTypedef_Args match the
// provided ThriftTest_TestTypedef_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestTypedef_Args) Equals(rhs *ThriftTest_TestTypedef_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_UserId_EqualsPtr(v.Thing, rhs.Thing) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestTypedef_Args.
func (v *ThriftTest_TestTypedef_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Thing != nil {
		enc.AddInt64("thing", (int64)(*v.Thing))
	}
	return err
}

// GetThing returns the value of Thing if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestTypedef_Args) GetThing() (o UserId) {
	if v != nil && v.Thing != nil {
		return *v.Thing
	}

	return
}

// IsSetThing returns true if Thing is not nil.
func (v *ThriftTest_TestTypedef_Args) IsSetThing() bool {
	return v != nil && v.Thing != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testTypedef" for this struct.
func (v *ThriftTest_TestTypedef_Args) MethodName() string {
	return "testTypedef"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestTypedef_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestTypedef_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testTypedef
// function.
var ThriftTest_TestTypedef_Helper = struct {
	// Args accepts the parameters of testTypedef in-order and returns
	// the arguments struct for the function.
	Args func(
		thing *UserId,
	) *ThriftTest_TestTypedef_Args

	// IsException returns true if the given error can be thrown
	// by testTypedef.
	//
	// An error can be thrown by testTypedef only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testTypedef
	// given its return value and error.
	//
	// This allows mapping values and errors returned by
	// testTypedef into a serializable result struct.
	// WrapResponse returns a non-nil error if the provided
	// error cannot be thrown by testTypedef
	//
	//   value, err := testTypedef(args)
	//   result, err := ThriftTest_TestTypedef_Helper.WrapResponse(value, err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testTypedef: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(UserId, error) (*ThriftTest_TestTypedef_Result, error)

	// UnwrapResponse takes the result struct for testTypedef
	// and returns the value or error returned by it.
	//
	// The error is non-nil only if testTypedef threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   value, err := ThriftTest_TestTypedef_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestTypedef_Result) (UserId, error)
}{}

func init() {
	ThriftTest_TestTypedef_Helper.Args = func(
		thing *UserId,
	) *ThriftTest_TestTypedef_Args {
		return &ThriftTest_TestTypedef_Args{
			Thing: thing,
		}
	}

	ThriftTest_TestTypedef_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestTypedef_Helper.WrapResponse = func(success UserId, err error) (*ThriftTest_TestTypedef_Result, error) {
		if err == nil {
			return &ThriftTest_TestTypedef_Result{Success: &success}, nil
		}

		return nil, err
	}
	ThriftTest_TestTypedef_Helper.UnwrapResponse = func(result *ThriftTest_TestTypedef_Result) (success UserId, err error) {

		if result.Success != nil {
			success = *result.Success
			return
		}

		err = errors.New("expected a non-void result")
		return
	}

}

// ThriftTest_TestTypedef_Result represents the result of a ThriftTest.testTypedef function call.
//
// The result of a testTypedef execution is sent and received over the wire as this struct.
//
// Success is set only if the function did not throw an exception.
type ThriftTest_TestTypedef_Result struct {
	// Value returned by testTypedef after a successful execution.
	Success *UserId `json:"success,omitempty"`
}

// ToWire translates a ThriftTest_TestTypedef_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestTypedef_Result) ToWire() (wire.Value, error) {
	var (
		fields [1]wire.Field
		i      int = 0
		w      wire.Value
		err    error
	)

	if v.Success != nil {
		w, err = v.Success.ToWire()
		if err != nil {
			return w, err
		}
		fields[i] = wire.Field{ID: 0, Value: w}
		i++
	}

	if i != 1 {
		return wire.Value{}, fmt.Errorf("ThriftTest_TestTypedef_Result should have exactly one field: got %v fields", i)
	}

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestTypedef_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestTypedef_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestTypedef_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestTypedef_Result) FromWire(w wire.Value) error {
	var err error

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		case 0:
			if field.Value.Type() == wire.TI64 {
				var x UserId
				x, err = _UserId_Read(field.Value)
				v.Success = &x
				if err != nil {
					return err
				}

			}
		}
	}

	count := 0
	if v.Success != nil {
		count++
	}
	if count != 1 {
		return fmt.Errorf("ThriftTest_TestTypedef_Result should have exactly one field: got %v fields", count)
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestTypedef_Result
// struct.
func (v *ThriftTest_TestTypedef_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [1]string
	i := 0
	if v.Success != nil {
		fields[i] = fmt.Sprintf("Success: %v", *(v.Success))
		i++
	}

	return fmt.Sprintf("ThriftTest_TestTypedef_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestTypedef_Result match the
// provided ThriftTest_TestTypedef_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestTypedef_Result) Equals(rhs *ThriftTest_TestTypedef_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}
	if !_UserId_EqualsPtr(v.Success, rhs.Success) {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestTypedef_Result.
func (v *ThriftTest_TestTypedef_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	if v.Success != nil {
		enc.AddInt64("success", (int64)(*v.Success))
	}
	return err
}

// GetSuccess returns the value of Success if it is set or its
// zero value if it is unset.
func (v *ThriftTest_TestTypedef_Result) GetSuccess() (o UserId) {
	if v != nil && v.Success != nil {
		return *v.Success
	}

	return
}

// IsSetSuccess returns true if Success is not nil.
func (v *ThriftTest_TestTypedef_Result) IsSetSuccess() bool {
	return v != nil && v.Success != nil
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testTypedef" for this struct.
func (v *ThriftTest_TestTypedef_Result) MethodName() string {
	return "testTypedef"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestTypedef_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}

// ThriftTest_TestVoid_Args represents the arguments for the ThriftTest.testVoid function.
//
// The arguments for testVoid are sent and received over the wire as this struct.
type ThriftTest_TestVoid_Args struct {
}

// ToWire translates a ThriftTest_TestVoid_Args struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestVoid_Args) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestVoid_Args struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestVoid_Args struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestVoid_Args
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestVoid_Args) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestVoid_Args
// struct.
func (v *ThriftTest_TestVoid_Args) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("ThriftTest_TestVoid_Args{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestVoid_Args match the
// provided ThriftTest_TestVoid_Args.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestVoid_Args) Equals(rhs *ThriftTest_TestVoid_Args) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestVoid_Args.
func (v *ThriftTest_TestVoid_Args) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the arguments.
//
// This will always be "testVoid" for this struct.
func (v *ThriftTest_TestVoid_Args) MethodName() string {
	return "testVoid"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Call for this struct.
func (v *ThriftTest_TestVoid_Args) EnvelopeType() wire.EnvelopeType {
	return wire.Call
}

// ThriftTest_TestVoid_Helper provides functions that aid in handling the
// parameters and return values of the ThriftTest.testVoid
// function.
var ThriftTest_TestVoid_Helper = struct {
	// Args accepts the parameters of testVoid in-order and returns
	// the arguments struct for the function.
	Args func() *ThriftTest_TestVoid_Args

	// IsException returns true if the given error can be thrown
	// by testVoid.
	//
	// An error can be thrown by testVoid only if the
	// corresponding exception type was mentioned in the 'throws'
	// section for it in the Thrift file.
	IsException func(error) bool

	// WrapResponse returns the result struct for testVoid
	// given the error returned by it. The provided error may
	// be nil if testVoid did not fail.
	//
	// This allows mapping errors returned by testVoid into a
	// serializable result struct. WrapResponse returns a
	// non-nil error if the provided error cannot be thrown by
	// testVoid
	//
	//   err := testVoid(args)
	//   result, err := ThriftTest_TestVoid_Helper.WrapResponse(err)
	//   if err != nil {
	//     return fmt.Errorf("unexpected error from testVoid: %v", err)
	//   }
	//   serialize(result)
	WrapResponse func(error) (*ThriftTest_TestVoid_Result, error)

	// UnwrapResponse takes the result struct for testVoid
	// and returns the erorr returned by it (if any).
	//
	// The error is non-nil only if testVoid threw an
	// exception.
	//
	//   result := deserialize(bytes)
	//   err := ThriftTest_TestVoid_Helper.UnwrapResponse(result)
	UnwrapResponse func(*ThriftTest_TestVoid_Result) error
}{}

func init() {
	ThriftTest_TestVoid_Helper.Args = func() *ThriftTest_TestVoid_Args {
		return &ThriftTest_TestVoid_Args{}
	}

	ThriftTest_TestVoid_Helper.IsException = func(err error) bool {
		switch err.(type) {
		default:
			return false
		}
	}

	ThriftTest_TestVoid_Helper.WrapResponse = func(err error) (*ThriftTest_TestVoid_Result, error) {
		if err == nil {
			return &ThriftTest_TestVoid_Result{}, nil
		}

		return nil, err
	}
	ThriftTest_TestVoid_Helper.UnwrapResponse = func(result *ThriftTest_TestVoid_Result) (err error) {
		return
	}

}

// ThriftTest_TestVoid_Result represents the result of a ThriftTest.testVoid function call.
//
// The result of a testVoid execution is sent and received over the wire as this struct.
type ThriftTest_TestVoid_Result struct {
}

// ToWire translates a ThriftTest_TestVoid_Result struct into a Thrift-level intermediate
// representation. This intermediate representation may be serialized
// into bytes using a ThriftRW protocol implementation.
//
// An error is returned if the struct or any of its fields failed to
// validate.
//
//   x, err := v.ToWire()
//   if err != nil {
//     return err
//   }
//
//   if err := binaryProtocol.Encode(x, writer); err != nil {
//     return err
//   }
func (v *ThriftTest_TestVoid_Result) ToWire() (wire.Value, error) {
	var (
		fields [0]wire.Field
		i      int = 0
	)

	return wire.NewValueStruct(wire.Struct{Fields: fields[:i]}), nil
}

// FromWire deserializes a ThriftTest_TestVoid_Result struct from its Thrift-level
// representation. The Thrift-level representation may be obtained
// from a ThriftRW protocol implementation.
//
// An error is returned if we were unable to build a ThriftTest_TestVoid_Result struct
// from the provided intermediate representation.
//
//   x, err := binaryProtocol.Decode(reader, wire.TStruct)
//   if err != nil {
//     return nil, err
//   }
//
//   var v ThriftTest_TestVoid_Result
//   if err := v.FromWire(x); err != nil {
//     return nil, err
//   }
//   return &v, nil
func (v *ThriftTest_TestVoid_Result) FromWire(w wire.Value) error {

	for _, field := range w.GetStruct().Fields {
		switch field.ID {
		}
	}

	return nil
}

// String returns a readable string representation of a ThriftTest_TestVoid_Result
// struct.
func (v *ThriftTest_TestVoid_Result) String() string {
	if v == nil {
		return "<nil>"
	}

	var fields [0]string
	i := 0

	return fmt.Sprintf("ThriftTest_TestVoid_Result{%v}", strings.Join(fields[:i], ", "))
}

// Equals returns true if all the fields of this ThriftTest_TestVoid_Result match the
// provided ThriftTest_TestVoid_Result.
//
// This function performs a deep comparison.
func (v *ThriftTest_TestVoid_Result) Equals(rhs *ThriftTest_TestVoid_Result) bool {
	if v == nil {
		return rhs == nil
	} else if rhs == nil {
		return false
	}

	return true
}

// MarshalLogObject implements zapcore.ObjectMarshaler, enabling
// fast logging of ThriftTest_TestVoid_Result.
func (v *ThriftTest_TestVoid_Result) MarshalLogObject(enc zapcore.ObjectEncoder) (err error) {
	if v == nil {
		return nil
	}
	return err
}

// MethodName returns the name of the Thrift function as specified in
// the IDL, for which this struct represent the result.
//
// This will always be "testVoid" for this struct.
func (v *ThriftTest_TestVoid_Result) MethodName() string {
	return "testVoid"
}

// EnvelopeType returns the kind of value inside this struct.
//
// This will always be Reply for this struct.
func (v *ThriftTest_TestVoid_Result) EnvelopeType() wire.EnvelopeType {
	return wire.Reply
}
